---
title: Tavern
tags:
 - Dev Guide
description: Want to contribute to Tavern? Start here!
permalink: dev-guide/tavern
---

## Overview

Before reading this guide, please check out the [admin guide](/admin-guide/tavern) to better understand how Tavern is deployed and managed. If you would like to help contribute to Tavern, please take a look at our [open issues](https://github.com/spellshift/realm/issues?q=is%3Aopen+is%3Aissue+label%3Atavern).

## GraphQL API

### Creating a New Model

1. Initialize the schema `cd tavern && go run entgo.io/ent/cmd/ent init <NAME>`
2. Update the generated file in `tavern/internal/ent/schema/<NAME>.go`
3. Ensure you include a `func (<NAME>) Annotations() []schema.Annotation` method which returns a `entgql.QueryField()` annotation to tell entgo to generate a GraphQL root query for this model (if you'd like it to be queryable from the root query)
4. Update `tavern/internal/graphql/gqlgen.yml` to include the ent types in the `autobind:` section (e.g.`- github.com/spellshift/realm/tavern/internal/ent/<NAME>`)
5. **Optionally** update the `models:` section of `tavern/internal/graphql/gqlgen.yml` to bind any GraphQL enum types to their respective `entgo` generated types (e.g. `github.com/spellshift/realm/tavern/internal/ent/<NAME>.<ENUM_FIELD>`)
6. Run `go generate ./tavern/...` from the project root
7. If you added an annotation for a root query field (see above), you will notice auto-generated the `query.resolvers.go` file has been updated with new methods to query your model (e.g. `func (r *queryResolver) <NAME>s ...`)
    * This must be implemented (e.g. `return r.client.<NAME>.Query().All(ctx)` where NAME is the name of your model)

### Adding Mutations

1. Update the `mutation.graphql` schema file to include your new mutation and please include it in the section for the model it's mutating if applicable (e.g. createUser should be defined near all the related User mutations)
    * **Note:** Input types such as `Create<NAME>Input` or `Update<NAME>Input` will already be generated if you [added the appropriate annotations to your ent schema](https://entgo.io/docs/tutorial-todo-gql#install-and-configure-entgql). If you require custom input mutations (e.g. `ClaimTasksInput`) then add them to the `inputs.graphql` file (Golang code will be generated in tavern/internal/graphql/models e.g. `models.ClaimTasksInput`).
2. Run `go generate ./...`
3. Implement generated the generated mutation resolver method in `tavern/internal/graphql/mutation.resolvers.go`
    * Depending on the mutation you're trying to implement, a one liner such as `return r.client.<NAME>.Create().SetInput(input).Save(ctx)` might be sufficient
4. Please write a unit test for your new mutation by defining YAML test cases in a new `testdata/mutations` subdirectory with your mutations name (e.g. `tavern/internal/graphql/testdata/mutations/mymutation/SomeTest.yml`)

### Code Generation Reference

* After making a change, remember to run `go generate ./...` from the project root.
* `tavern/internal/ent/schema` is a directory which defines our graph using database models (ents) and the relations between them
* `tavern/generate.go` is responsible for generating ents defined by the ent schema as well as updating the GraphQL schema and generating related code
* `tavern/internal/ent/entc.go` is responsible for generating code for the entgo <-> 99designs/gqlgen GraphQL integration
* `tavern/internal/graphql/schema/mutation.graphql` defines all mutations supported by our API
* `tavern/internal/graphql/schema/query.graphql` is a GraphQL schema automatically generated by ent, providing useful types derived from our ent schemas as well as root-level queries defined by entgo annotations
* `tavern/internal/graphql/schema/scalars.graphql` defines scalar GraphQL types that can be used to help with Go bindings (See [gqlgen docs](https://gqlgen.com/reference/scalars/) for more info)
* `tavern/internal/graphql/schema/inputs.graphql` defines custom GraphQL inputs that can be used with your mutations (e.g. outside of the default auto-generated CRUD inputs)

### YAML Test Reference (GraphQL)

|Field|Description|Required|
|-----|-----------|--------|
|state| SQL queries that define the initial db state before the query is run.| no |
|requestor| Holds information about the authenticated context making the query. | no |
|requestor.beacon_token| Session token corresponding to the user for authentication. You may create a user with a predetermined session token using the `state` field. | no |
|query| GraphQL query or mutation to be executed | yes |
|variables| A map of variables that will be passed with your GraphQL Query to the server | no |
|expected| A map that defines the expected response that the server should return | no |
|expected_error| An expected message that should be included in the query when it fails | no |

### Resources

* [Relay Documentation](https://relay.dev/graphql/connections.htm)
* [entgo.io GraphQL Integration Docs](https://entgo.io/docs/graphql)
* [Ent + GraphQL Tutorial](https://entgo.io/docs/tutorial-todo-gql)
* [Example Ent + GraphQL project](https://github.com/ent/contrib/tree/master/entgql/internal/todo)
* [GQLGen Repo](https://github.com/99designs/gqlgen)

## GRPC API

Tavern also supports a gRPC API for agents to claim tasks and report execution output. This API is defined by our c2.proto spec and is still under active development.

### Downloading Files

You may download files from Tavern utilizing the `DownloadFile` gRPC method. This method streams responses, each of which will contain a chunk of the desired file. We rely on the [ordering guarantees](https://grpc.io/docs/languages/go/basics/#defining-the-service) provided by gRPC to ensure the file is assembled correctly. This API also sets two headers to ensure the integrity of files:

* `sha3-256-checksum`: Set to the SHA3 hash of the entire file.
* `file-size`: Set to the number of bytes contained by the file.

## Performance Profiling

Tavern supports built in performance monitoring and debugging via the Golang [pprof tool](https://go.dev/blog/pprof) developed by Google. To run tavern with profiling enabled, ensure the `ENABLE_PPROF=1` environment variable is set.

### Install Graphviz

Ensure you have an updated version of [Graphviz](https://graphviz.org/about/) installed for visualizing profile outputs.

```bash
apt install -y graphviz
```

### Collect a Profile

1. Start Tavern with profiling enabled: `ENABLE_PPROF=1 go run ./tavern`.
2. Collect a Profile in desired format (e.g. png): `go tool pprof -png -seconds=10 http://127.0.0.1:8000/debug/pprof/allocs?seconds=10 > .pprof/allocs.png`
    a. Replace "allocs" with the [name of the profile](https://pkg.go.dev/runtime/pprof#Profile) to collect.
    b. Replace the value of seconds with the amount of time you need to reproduce performance issues.
    c. Read more about the available profiling URL parameters [here](https://pkg.go.dev/net/http/pprof#hdr-Parameters).
    d. `go tool pprof` does not need to run on the same host as Tavern, just ensure you provide the correct HTTP url in the command. Note that Graphviz must be installed on the system you're running `pprof` from.
3. Reproduce any interactions with Tavern that you'd like to collect profiling information for.
4. A graph visualization of the requested performance profile should now be saved locally, take a look and see what's going on üïµÔ∏è.

## Agent Development

Tavern provides an HTTP(s) [gRPC API](https://grpc.io/) that agents may use directly to claim tasks and submit execution results. This is the standard request flow, and is supported as a core function of realm. For more information, please consult our [API Specification](https://github.com/spellshift/realm/blob/main/tavern/internal/c2/proto/c2.proto).

### Reverse Shell Architecture

The reverse shell in Tavern is a powerful feature that allows for interactive sessions with agents. It's a complex system with several moving parts, so this section will provide a detailed overview of its architecture.

#### Overview

The reverse shell system is designed to be highly scalable and resilient. It uses a combination of gRPC, WebSockets, and a pub/sub messaging system to create a bidirectional communication channel between the agent and the user. The system is designed to work in a distributed fashion, where the server that hosts the WebSocket connection need not be the same server that hosts the gRPC stream.

#### Components

The reverse shell system is composed of the following components:

* **gRPC Server**: The gRPC server is the entry point for the agent. It exposes the `ReverseShell` service, which is a bidirectional gRPC stream. The agent connects to this service to initiate a reverse shell session.
* **WebSocket Server**: The WebSocket server is the entry point for the user. It exposes a WebSocket endpoint that the user can connect to to interact with the reverse shell.
* **Pub/Sub Messaging System**: The pub/sub messaging system is the backbone of the reverse shell. It's used to decouple the gRPC server and the WebSocket server, and to provide a reliable and scalable way to transport messages between them. The system uses two topics:
  * **Input Topic**: The input topic is used to send messages from the user (via the WebSocket) to the agent (via the gRPC stream).
  * **Output Topic**: The output topic is used to send messages from the agent (via the gRPC stream) to the user (via the WebSocket).
* **Mux**: The `Mux` is a multiplexer that sits between the pub/sub system and the gRPC/WebSocket servers. It's responsible for routing messages between the two. There are two `Mux` instances:
  * **wsMux**: The `wsMux` is used by the WebSocket server. It subscribes to the output topic and publishes to the input topic.
  * **grpcMux**: The `grpcMux` is used by the gRPC server. It subscribes to the input topic and publishes to the output topic.
* **Stream**: A `Stream` represents a single reverse shell session. It's responsible for managing the connection between the `Mux` and the gRPC/WebSocket client.
* **sessionBuffer**: The `sessionBuffer` is used to order messages within a `Stream`. This is important because multiple users can be connected to the same shell session, and their messages need to be delivered in the correct order.

#### Communication Flow

1. The agent connects to the `ReverseShell` gRPC service.
2. The gRPC server creates a new `Shell` entity, a new `Stream`, and registers the `Stream` with the `grpcMux`.
3. The user connects to the WebSocket endpoint.
4. The WebSocket server creates a new `Stream` and registers it with the `wsMux`.
5. When the user sends a message, it's sent to the WebSocket server, which publishes it to the input topic via the `wsMux`.
6. The `grpcMux` receives the message from the input topic and sends it to the agent via the gRPC stream.
7. When the agent sends a message, it's sent to the gRPC server, which publishes it to the output topic via the `grpcMux`.
8. The `wsMux` receives the message from the output topic and sends it to the user via the WebSocket.

#### Distributed Architecture

The reverse shell system is designed to be distributed. The gRPC server and the WebSocket server can be running on different machines. This is made possible by the pub/sub messaging system, which decouples the two servers. This allows the system to be scaled horizontally by adding more gRPC or WebSocket servers as needed.

#### Message Ordering and Multi-User Sessions

The reverse shell supports multi-user sessions, where multiple users can be connected to the same shell session. To ensure that messages are delivered in the correct order, the `sessionBuffer` is used. The `sessionBuffer` assigns a unique order key to each user's session, and then it orders the messages based on that key. This ensures that messages from different users are not interleaved, and that they are delivered in the order that they were sent.

If you wish to develop an agent using a different transport method (e.g. DNS), your development will need to include a C2. The role of the C2 is to handle agent communication, and translate the chosen transport method into HTTP(s) requests to Tavern's gRPC API. We recommend reusing the existing protobuf definitions for simplicity and forward compatability. This enables developers to use any transport mechanism with Tavern. If you plan to build a C2 for a common protocol for use with Tavern, consider [submitting a PR](https://github.com/spellshift/realm/pulls).

### Agent Loop Lifecycle

1. Claim [Tasks](/user-guide/terminology#task)
2. Execute [Tasks](/user-guide/terminology#task) (happens in parallel and may not finish within one loop)
3. Report available output from [Task](/user-guide/terminology#task) execution
4. Sleep for an interval and repeat

## Custom oauth2 backend

If you can't use the default google oauth2 backend Realm has a flexible implementation that allows you to implement your own backends.

For example to add Hashicorp Vault as an OIDC backend you'll need to:

1. Setup an OIDC provider in vault - <https://developer.hashicorp.com/vault/docs/secrets/identity/oidc-provider>
2. Get the relevant variables from the '.well-known/openid-configuration` endpoint: `authorization_endpoint`,`token_endpoint`,`userinfo_endpoint`,`scopes_supported`
3. Open the `tavern/config.go` file and find where the `oauth2.Config` is initalized.
4. You'll need to change `Endpoint: google.Endpoint` to  `oauth2.Endpoint{}` and fill in the `AuthURL` and `TokenURL` with `authorization_endpoint` and `token_endpoint` respectively.
5. Update the `cfg.userProfiles` link with the `userinfo_endpoint`
6. Update `Scopes:` with the scopes in `scopes_supported`

For example using vault might look like:

```go
// ConfigureOAuthFromEnv sets OAuth config values from the environment
func ConfigureOAuthFromEnv(redirectPath string) func(*Config) {
    return func(cfg *Config) {
        var (
            clientID     = EnvOAuthClientID.String()
            clientSecret = EnvOAuthClientSecret.String()
            domain       = EnvOAuthDomain.String()
        )

        // .....
        // .....

        // Vault OAuth backend
        cfg.oauth = oauth2.Config{
            ClientID:     clientID,
            ClientSecret: clientSecret,
            RedirectURL:  domain + redirectPath,
            Scopes: []string{
                "openid",
            },
            Endpoint: oauth2.Endpoint{
                AuthURL:  "https://vault.example.com/ui/vault/identity/oidc/provider/default/authorize",
                TokenURL: "https://vault.example.com/v1/identity/oidc/provider/default/token",
            },
        }
        cfg.userProfiles = "https://vault.example.com/v1/identity/oidc/provider/default/userinfo"
    }
}

```

_Keep in mind `/default/` in vault corresponds to the name of the OIDC provider and may be different in your environemnet. You may need to include / create additional scopes to get things like profile pictures and users names from vault into Tavern_
