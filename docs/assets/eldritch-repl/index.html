<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eldritch REPL</title>
    <style>
        body {
            font-family: monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            margin: 0;
            overflow-y: scroll;
        }
        #terminal {
            white-space: pre-wrap;
            word-wrap: break-word;
            outline: none;
        }
        .prompt {
            color: #569cd6;
            margin-right: 0px; /* Spacing handled by content */
        }
        .continuation {
            color: #569cd6;
        }
        .cursor {
            background-color: #d4d4d4;
            color: #1e1e1e;
        }
        /* Hide the actual input but keep it functional */
        #hidden-input {
            position: absolute;
            opacity: 0;
            top: 0;
            left: -9999px;
        }
    </style>
</head>
<body>
    <h1>Eldritch REPL (WASM + Shared Logic)</h1>
    <div id="terminal"></div>
    <div id="current-line"></div>
    <textarea id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>

    <script type="module">
        import init, { WasmRepl } from './pkg/eldritchv2.js';

        let repl;
        const termEl = document.getElementById('terminal');
        const currentLineEl = document.getElementById('current-line');
        const inputEl = document.getElementById('hidden-input');

        // Persistence
        const HISTORY_KEY = 'eldritch_history';

        // Output handling
        window.repl_print = (s) => {
            printLine(s);
        };

        function printLine(text) {
            const div = document.createElement('div');
            div.innerText = text;
            termEl.appendChild(div);
            window.scrollTo(0, document.body.scrollHeight);
        }

        async function main() {
            await init();
            repl = new WasmRepl();

            // Load history
            try {
                const saved = localStorage.getItem(HISTORY_KEY);
                if (saved) {
                    repl.load_history(JSON.parse(saved));
                }
            } catch(e) { console.error(e); }

            printLine("Eldritch REPL initialized.\nType code and press Enter.\n");
            render();

            // Focus hidden input
            document.body.addEventListener('click', () => inputEl.focus());
            inputEl.focus();
        }

        function render() {
            const state = repl.get_state();

            // Render prompt and buffer with cursor
            const promptSpan = `<span class="prompt">${escape(state.prompt)}</span>`;

            const buf = state.buffer;
            const cur = state.cursor;

            let inputHtml = '';

            // Ensure cursor is within bounds
            const safeCur = Math.min(Math.max(0, cur), buf.length);

            const before = buf.substring(0, safeCur);
            const charAtCursor = buf.substring(safeCur, safeCur + 1) || ' ';
            const after = buf.substring(safeCur + 1);

            inputHtml = escape(before) + `<span class="cursor">${escape(charAtCursor)}</span>` + escape(after);

            currentLineEl.innerHTML = promptSpan + inputHtml;
            window.scrollTo(0, document.body.scrollHeight);
        }

        function escape(s) {
            return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }

        function saveHistory() {
            // Get history from Repl
            const hist = repl.get_history();
            localStorage.setItem(HISTORY_KEY, JSON.stringify(hist));
        }

        inputEl.addEventListener('keydown', (e) => {
            // Prevent default browser actions for handled keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab', 'Backspace', 'Enter'].includes(e.key)) {
                e.preventDefault();
            }
            if (e.key === 'c' && e.ctrlKey) e.preventDefault();
            if (e.key === 'l' && e.ctrlKey) e.preventDefault();

            // Handle Key via Rust
            // We map JS event to simple "Key" + Modifiers
            // But WasmRepl expects specific strings for keys it knows, or single chars.

            let key = e.key;

            const result = repl.handle_key(key, e.ctrlKey, e.altKey, e.metaKey);

            if (result.should_print && result.output !== undefined) {
                // Command executed and produced output (or error)
                // First, commit the current line to the terminal display
                // Wait, the Repl has already cleared the buffer inside handle_key(Submit)
                // We need to capture the "what was just typed" to print it to history?
                // The Repl logic clears buffer on Submit.
                // Does `Repl` return the submitted code? Yes, `ReplAction::Submit(code)`.
                // But `handle_key` returns `ExecutionResult`.
                // We need to print the command that was just executed to the terminal log,
                // because `render()` will show an empty prompt now.
                //
                // Issue: `handle_key` in `wasm.rs` swallows the submitted code.
                // We probably want to print the *previous* state or the submitted code before showing output.
                //
                // FIX: `wasm.rs` should return the code executed OR we assume the UI handles "echo".
                // In CLI `repl.rs`, we print the buffer before clearing.
                // In `wasm.rs`, we don't have easy access to the buffer *before* the action unless we query it first.
                //
                // Better approach: When `handle_key` returns a result that implies execution,
                // it should probably include the "echo" of the command if needed?
                // OR `render()` logic handles the active line, but once submitted, it's gone from `repl`.
                //
                // Let's modify JS to:
                // 1. Get state.
                // 2. Call handle_key.
                // 3. If "Submit" happened (how do we know? `should_print` is true usually implies output or error),
                //    we need to know what was submitted to print ">>> command".
                //
                // Actually, `wasm.rs` `execute` could verify if we should echo?
                // Or simply: The `Repl` engine clears the buffer.
                // If we want to mimic a terminal, we should print the command to the scrollback.
                //
                // I should update `wasm.rs` to include `echo_command` in `ExecutionResult`?
                // Or I can just manually manage it in JS if I knew what it was.
                //
                // Let's modify `wasm.rs` to return `echo: Option<String>` in `ExecutionResult`.
                // Wait, `repl.rs` `handle_input` returns `Submit(String)`.
                // `wasm.rs` consumes it.
                // I will update `wasm.rs` now to pass that back.
            }

            // Check output
            if (result.output) {
                printLine(result.output);
            }

            // If we just submitted, we need to print the *prompt + command* that was submitted?
            // The `render()` will show a fresh prompt.
            // The previous command is gone.
            // THIS IS A PROBLEM.
            // I need to update `wasm.rs` to return the executed command so I can print it.

            // Re-render
            render();

            if (result.should_print) {
                saveHistory();
            }
        });

        inputEl.addEventListener('paste', (e) => {
             e.preventDefault();
             const text = (e.clipboardData || window.clipboardData).getData('text');
             if (text) {
                 // We need to echo the pasted text as prompts?
                 // `wasm.rs` `handle_paste` returns output.
                 // But it doesn't return the "echo" of what was pasted.
                 // If I paste `if True:\n  pass`, I want to see:
                 // >>> if True:
                 // ...   pass
                 // (output)
                 //
                 // `handle_paste` in `wasm.rs` is a bit black-box.
                 // It runs the loop.
                 // We should probably change `handle_paste` to return a list of "events" to render?
                 // Or just print inside `handle_paste`?
                 // `repl_print` prints output.
                 // We could add `repl_echo(prompt, line)` callback?

                 const res = repl.handle_paste(text);
                 if (res.output) printLine(res.output);
                 render();
             }
        });
    </script>
</body>
</html>
