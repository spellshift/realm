#![deny(warnings)]

extern crate eldritch;
extern crate golem;

mod inter;

use anyhow::{anyhow, Result};
use clap::{Arg, Command};
use eldritch::runtime::{messages::AsyncMessage, Message};
use pb::eldritch::Tome;
use std::collections::HashMap;
use std::fs;
use std::process;

// Cryptography & Embedding related imports
use aes_gcm::{
    aead::{Aead, NewAead},
    Aes256Gcm, Key, Nonce,
};
use pbkdf2::pbkdf2_hmac;
use sha2::Sha256;

// Include generated crypto configuration and embedded encrypted files
include!(concat!(env!("OUT_DIR"), "/crypto_config.rs"));
// This static variable GOLEM_ENCRYPTED_TOMES is generated by include_dir_codegen::embed in build.rs
static GOLEM_ENCRYPTED_TOMES: include_dir::Dir<'_> = include_dir!(concat!(env!("OUT_DIR"), "/encrypted_tomes"));


struct ParsedTome {
    pub eldritch: String,
}

async fn run_tomes(tomes: Vec<ParsedTome>) -> Result<Vec<String>> {
    let mut runtimes = Vec::new();
    let mut idx = 1;
    for tome in tomes {
        let runtime = eldritch::start(
            idx,
            Tome {
                eldritch: tome.eldritch,
                parameters: HashMap::new(),
                file_names: Vec::new(),
            },
        )
        .await;
        runtimes.push(runtime);
        idx += 1;
    }

    let mut result = Vec::new();
    let mut errors = Vec::new();
    for runtime in &mut runtimes {
        runtime.finish().await;

        for msg in runtime.messages() {
            match msg {
                Message::Async(AsyncMessage::ReportText(m)) => result.push(m.text()),
                Message::Async(AsyncMessage::ReportError(m)) => errors.push(m.error),
                _ => {}
            }
        }
    }
    if !errors.is_empty() {
        return Err(anyhow!("{:?}", errors));
    }
    Ok(result)
}

fn main() -> anyhow::Result<()> {
    let matches = Command::new("golem")
        .arg(
            Arg::with_name("INPUT")
                .help("Set the tomes to run")
                .multiple_occurrences(true)
                .required(false),
        )
        .arg(
            Arg::with_name("interactive")
                .help("Run the interactive REPL")
                .short('i')
                .multiple_occurrences(false)
                .required(false),
        )
        .arg(
            Arg::new("password")
                .long("password")
                .short('p')
                .value_name("PASSWORD")
                .help("Password to decrypt embedded tomes")
                .required(false) // Tomes from INPUT don't need it
                .takes_value(true),
        )
        .get_matches();

    if matches.contains_id("INPUT") {
        // Read Tomes
        let tome_files = matches.try_get_many::<String>("INPUT").unwrap().unwrap();
        let mut parsed_tomes: Vec<ParsedTome> = Vec::new();
        for tome in tome_files {
            let tome_path = tome.to_string().clone();
            let tome_contents = fs::read_to_string(tome_path.clone())?;
            parsed_tomes.push(ParsedTome {
                eldritch: tome_contents,
            });
        }

        let runtime = tokio::runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .unwrap();

        let (error_code, _result) = match runtime.block_on(run_tomes(parsed_tomes)) {
            Ok(response) => (0, response),
            Err(error) => {
                eprint!("failed to execute tome {:?}", error);
                (-1, Vec::new())
            }
        };

        process::exit(error_code);
    } else if matches.contains_id("interactive") {
        inter::interactive_main()?;
    } else {
        // Handle embedded tomes (potentially encrypted)
        let mut parsed_tomes: Vec<ParsedTome> = Vec::new();

        let password = match matches.get_one::<String>("password") {
            Some(p) => p,
            None => {
                eprintln!("Password required for encrypted embedded tomes. Use --password <PASSWORD> or -p <PASSWORD>");
                process::exit(1);
            }
        };

        // Derive candidate AES key from CLI password and compile-time KDF_SALT
        let mut candidate_aes_key = [0u8; 32]; // AES-256 key size
        pbkdf2_hmac::<Sha256>(
            password.as_bytes(),
            KDF_SALT.as_bytes(),
            10_000, // Iterations, must match build.rs
            &mut candidate_aes_key,
        );

        // Verify password by comparing derived key with compile-time AES_KEY
        if candidate_aes_key != *AES_KEY {
            eprintln!("Invalid password.");
            process::exit(1);
        }

        // Password is valid, proceed to decrypt and load tomes
        let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(AES_KEY));

        for file in GOLEM_ENCRYPTED_TOMES.files() {
            if file.path().file_name().map_or(false, |name| name == "main.eldritch") {
                let encrypted_content = file.contents();
                let nonce = Nonce::from_slice(AES_NONCE);
                match cipher.decrypt(nonce, encrypted_content) {
                    Ok(decrypted_data) => {
                        match String::from_utf8(decrypted_data) {
                            Ok(tome_contents) => {
                                parsed_tomes.push(ParsedTome { eldritch: tome_contents });
                            }
                            Err(e) => {
                                eprintln!("Failed to convert decrypted tome to UTF-8 string: {}. Skipping.", e);
                                // Optionally, exit or handle more gracefully
                            }
                        }
                    }
                    Err(e) => {
                        eprintln!("Failed to decrypt tome '{}': {}. Skipping.", file.path().display(), e);
                        // Optionally, exit or handle more gracefully
                    }
                }
            }
        }
        
        if parsed_tomes.is_empty() {
            println!("No 'main.eldritch' tomes found or decrypted from embedded assets.");
            // process::exit(0); // Or some other behavior if no tomes are fine
        }


        let runtime = tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()
            .unwrap();

        let (error_code, result) = match runtime.block_on(run_tomes(parsed_tomes)) {
            Ok(response) => (0, response),
            Err(error) => {
                eprint!("error executing tomes {:?}", error);
                (-1, Vec::new())
            }
        };

        if !result.is_empty() {
            println!("{:?}", result);
        }
        process::exit(error_code);
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    #[tokio::test]
    async fn test_golem_execute_tomes_in_parallel() -> anyhow::Result<()> {
        let parsed_tomes = Vec::from([ParsedTome {
            eldritch: r#"print("hello world")"#.to_string(),
        }]);

        let out = run_tomes(parsed_tomes).await?;
        assert_eq!("hello world\n".to_string(), out.join(""));
        Ok(())
    }
}
