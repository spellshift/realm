use crate::agent::ImixAgent;
use crate::task::TaskRegistry;
use pb::c2::{ReportTaskOutputRequest, ShellTaskOutput, TaskContext, TaskOutput};
use pb::config::Config;
use std::sync::{Arc, Mutex};
use transport::MockTransport;

#[tokio::test]
async fn test_agent_output_aggregation() {
    let _ = pretty_env_logger::try_init();

    // 1. Setup Mock Transport
    let mut transport = MockTransport::default();
    let actual_requests = Arc::new(Mutex::new(Vec::new()));
    let requests_clone = actual_requests.clone();

    // We expect 3 calls:
    // 1. Task 100
    // 2. Shell Task 500
    // 3. Shell Task 600
    transport
        .expect_report_task_output()
        .times(3)
        .returning(move |req| {
            requests_clone.lock().unwrap().push(req);
            Ok(pb::c2::ReportTaskOutputResponse {})
        });

    transport.expect_is_active().returning(|| true);
    // clone() needs to be mocked if it's called.
    // ImixAgent uses T: Transport + Sync + 'static.
    // It stores Arc<RwLock<T>>. It doesn't clone the transport unless get_usable_transport calls clone.
    // But get_usable_transport calls `guard.clone()`.
    // So we need to mock clone.
    transport.expect_clone().returning(|| {
        let mut t = MockTransport::default();
        // This is tricky. If we return a NEW mock, the expectations won't be on it.
        // But if `MockTransport` supports sharing expectations via clone, we don't need to mock clone?
        // Wait, the `mock!` block had `impl Clone for Transport`.
        // If I mock `clone` explicitly, I am overriding the default behavior.
        // But `Transport` trait requires `Clone` (in ImixAgent bounds? No, T: Transport. Transport trait requires Clone?
        // Let's check `implants/lib/transport/src/lib.rs`.
        // `pub trait Transport: Clone + Send + Sync + 'static`? No.
        // `implants/lib/transport/src/transport.rs` likely defines the trait.
        t
    });

    // Actually, looking at `agent.rs`:
    // `impl<T: Transport + Sync + 'static> ImixAgent<T>`
    // It calls `guard.clone()` in `get_usable_transport`.
    // So `T` must be `Clone`.
    // `mock!` macro implements `Clone` for the struct.
    // If I add `expect_clone`, I might be interfering.
    // Let's try WITHOUT expecting clone first. If `MockTransport` implements Clone logic that preserves expectations, it's fine.
    // But wait, `MockTransport` is generated by `mock!`.
    // If `mock!` defines `impl Clone`, then calling `clone()` calls that implementation.
    // That implementation usually returns a new handle to the same mock state.
    // However, `ImixAgent` stores `T`.
    // When `flush_outputs` runs:
    // `let mut transport = self.transport.write().await;`
    // `transport.report_task_output(output).await`
    // It uses the stored transport directly. It does NOT clone it.
    // `get_usable_transport` is NOT called in `flush_outputs`.
    // So I don't need to worry about `clone` for `flush_outputs`.

    // 2. Setup Agent
    let handle = tokio::runtime::Handle::current();
    let task_registry = Arc::new(TaskRegistry::new());
    let (tx, _rx) = tokio::sync::mpsc::channel(1);
    let agent = Arc::new(ImixAgent::new(
        Config::default(),
        transport,
        handle,
        task_registry,
        tx,
    ));

    // 3. Send outputs

    // Task Output (Task ID 100)
    let task_out_1 = ReportTaskOutputRequest {
        context: Some(TaskContext {
            task_id: 100,
            jwt: "jwt".into(),
        }),
        output: Some(TaskOutput {
            id: 100,
            output: "Part 1".into(),
            error: None,
            exec_started_at: None,
            exec_finished_at: None,
        }),
        shell_task_output: None,
    };
    agent.output_tx.send(task_out_1).unwrap();

    let task_out_2 = ReportTaskOutputRequest {
        context: Some(TaskContext {
            task_id: 100,
            jwt: "jwt".into(),
        }),
        output: Some(TaskOutput {
            id: 100,
            output: " Part 2".into(),
            error: None,
            exec_started_at: None,
            exec_finished_at: None,
        }),
        shell_task_output: None,
    };
    agent.output_tx.send(task_out_2).unwrap();

    // Shell Task Output (Shell Task ID 500)
    let shell_out_1 = ReportTaskOutputRequest {
        context: None,
        output: None,
        shell_task_output: Some(ShellTaskOutput {
            id: 500,
            output: "Shell 1".into(),
            error: None,
            exec_started_at: None,
            exec_finished_at: None,
        }),
    };
    agent.output_tx.send(shell_out_1).unwrap();

    let shell_out_2 = ReportTaskOutputRequest {
        context: None,
        output: None,
        shell_task_output: Some(ShellTaskOutput {
            id: 500,
            output: " continued".into(),
            error: None,
            exec_started_at: None,
            exec_finished_at: None,
        }),
    };
    agent.output_tx.send(shell_out_2).unwrap();

    // Another Shell Task Output (Shell Task ID 600)
    let shell_out_3 = ReportTaskOutputRequest {
        context: None,
        output: None,
        shell_task_output: Some(ShellTaskOutput {
            id: 600,
            output: "Shell 2".into(),
            error: None,
            exec_started_at: None,
            exec_finished_at: None,
        }),
    };
    agent.output_tx.send(shell_out_3).unwrap();

    // 4. Flush outputs
    agent.flush_outputs().await;

    // 5. Verify
    let reqs = actual_requests.lock().unwrap();
    assert_eq!(reqs.len(), 3, "Should have 3 aggregated requests");

    // Check Task 100
    let task_100 = reqs
        .iter()
        .find(|r| r.context.as_ref().map(|c| c.task_id) == Some(100))
        .expect("Task 100 output missing");

    assert_eq!(task_100.output.as_ref().unwrap().output, "Part 1 Part 2");
    assert!(task_100.shell_task_output.is_none());

    // Check Shell 500
    let shell_500 = reqs
        .iter()
        .find(|r| r.shell_task_output.as_ref().map(|s| s.id) == Some(500))
        .expect("Shell 500 output missing");

    assert_eq!(
        shell_500.shell_task_output.as_ref().unwrap().output,
        "Shell 1 continued"
    );
    assert!(shell_500.output.is_none());
    assert!(shell_500.context.is_none());

    // Check Shell 600
    let shell_600 = reqs
        .iter()
        .find(|r| r.shell_task_output.as_ref().map(|s| s.id) == Some(600))
        .expect("Shell 600 output missing");

    assert_eq!(
        shell_600.shell_task_output.as_ref().unwrap().output,
        "Shell 2"
    );
    assert!(shell_600.output.is_none());
}
