<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eldritch REPL</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            font-family: monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            margin: 0;
            overflow-y: scroll;
        }

        #terminal {
            white-space: pre-wrap;
            word-wrap: break-word;
            outline: none;
        }

        #current-line {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .prompt {
            color: #569cd6;
            margin-right: 0px;
            /* Spacing handled by content */
        }

        .continuation {
            color: #569cd6;
        }

        .cursor {
            background-color: #d4d4d4;
            color: #1e1e1e;
        }

        /* Visual indicator when not focused */
        body.not-focused .cursor {
            background-color: transparent;
            border: 1px solid #d4d4d4;
            color: #d4d4d4;
        }

        body.not-focused {
            opacity: 0.8;
        }

        /* Hide the actual input but keep it functional */
        #hidden-input {
            position: fixed;
            opacity: 0;
            top: 0;
            left: -9999px;
        }
    </style>
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZZ8G47GCT4"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-ZZ8G47GCT4');
</script>

<body>
    <h1>Eldritch v0.3 REPL (WASM)</h1>
    <div class="position-fixed top-0 end-0 p-3" style="z-index: 1000">
        <a href="https://github.com/spellshift/realm/issues/new?template=feedback.md&title=%5Bfeedback%5D%5Beldritchv0.3%5D%20Feedback%20Title"
            target="_blank" class="btn btn-dark btn-lg shadow">
            <i class="fab fa-github me-2"></i>Leave Feedback
        </a>
    </div>
    <h2><a Leave Feedback</a>
    </h2>
    <div id="terminal"></div>
    <div id="current-line"></div>
    <textarea id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>

    <script type="module">
        import init, { WasmRepl } from './pkg/eldritchv2.js';

        let repl;
        const termEl = document.getElementById('terminal');
        const currentLineEl = document.getElementById('current-line');
        const inputEl = document.getElementById('hidden-input');

        // Persistence
        const HISTORY_KEY = 'eldritch_history';

        // Output handling
        window.repl_print = (s) => {
            // This is kept for backward compatibility if any direct calls remain,
            // but the primary output path should now be through handle_key/execute returns.
            printLine(s);
        };

        function printLine(text) {
            const div = document.createElement('div');
            div.innerText = text;
            termEl.appendChild(div);
            window.scrollTo(0, document.body.scrollHeight);
        }

        async function main() {
            await init();
            repl = new WasmRepl();

            // Load history
            try {
                const saved = localStorage.getItem(HISTORY_KEY);
                if (saved) {
                    repl.load_history(JSON.parse(saved));
                }
            } catch (e) { console.error(e); }

            printLine("stdlib fakes registered, enjoy our demo environment!");
            render();

            // Focus handling
            inputEl.addEventListener('focus', () => {
                document.body.classList.remove('not-focused');
                render(); // Re-render to update cursor style if needed
            });

            inputEl.addEventListener('blur', () => {
                document.body.classList.add('not-focused');
                render();
            });

            // Focus hidden input on click anywhere
            document.body.addEventListener('click', () => {
                // If the user has selected text, do not steal focus,
                // otherwise they cannot copy the text.
                const sel = window.getSelection();
                if (sel && sel.toString().length > 0) {
                    return;
                }
                inputEl.focus();
            });

            // Initial focus
            inputEl.focus();
        }

        function render() {
            const state = repl.get_state();

            // Render prompt and buffer with cursor
            const promptSpan = `<span class="prompt">${escape(state.prompt)}</span>`;

            const buf = state.buffer;
            const cur = state.cursor;

            let inputHtml = '';

            // Ensure cursor is within bounds
            const safeCur = Math.min(Math.max(0, cur), buf.length);

            const before = buf.substring(0, safeCur);
            const charAtCursor = buf.substring(safeCur, safeCur + 1) || ' ';
            const after = buf.substring(safeCur + 1);

            inputHtml = escape(before) + `<span class="cursor">${escape(charAtCursor)}</span>` + escape(after);

            // Handle multi-line indentation alignment
            if (state.prompt.length > 0) {
                const padding = ' '.repeat(state.prompt.length);
                inputHtml = inputHtml.replace(/\n/g, '\n' + padding);
            }

            currentLineEl.innerHTML = promptSpan + inputHtml;
            window.scrollTo(0, document.body.scrollHeight);
        }

        function escape(s) {
            return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }

        function saveHistory() {
            // Get history from Repl
            const hist = repl.get_history();
            localStorage.setItem(HISTORY_KEY, JSON.stringify(hist));
        }

        inputEl.addEventListener('keydown', (e) => {
            // Prevent default browser actions for handled keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab', 'Backspace', 'Enter'].includes(e.key)) {
                e.preventDefault();
            }
            if (e.key === 'c' && e.ctrlKey) e.preventDefault();
            if (e.key === 'l' && e.ctrlKey) e.preventDefault();
            if (e.key === 'a' && e.ctrlKey) e.preventDefault();
            if (e.key === 'e' && e.ctrlKey) e.preventDefault();

            // Handle Key via Rust
            let key = e.key;

            // Pass shiftKey to handle_key
            const result = repl.handle_key(key, e.ctrlKey, e.altKey, e.metaKey, e.shiftKey);

            // Handle clear screen
            if (result.clear) {
                termEl.innerHTML = '';
            }

            // Handle echo (the command or line accepted) FIRST
            if (result.echo) {
                printLine(result.echo);
            }

            // Then output
            if (result.output) {
                printLine(result.output);
            }

            // Re-render
            render();

            if (result.output || result.echo) {
                saveHistory();
            }
        });

        inputEl.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text');
            if (text) {
                const res = repl.handle_paste(text);
                if (res.echo) printLine(res.echo);
                if (res.output) printLine(res.output);
                render();
            }
        });

        main();
    </script>
</body>

</html>
