// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/kcarretto/realm/tavern/ent/file"
	"github.com/kcarretto/realm/tavern/ent/job"
	"github.com/kcarretto/realm/tavern/ent/predicate"
	"github.com/kcarretto/realm/tavern/ent/tag"
	"github.com/kcarretto/realm/tavern/ent/target"
	"github.com/kcarretto/realm/tavern/ent/task"
	"github.com/kcarretto/realm/tavern/ent/tome"
	"github.com/kcarretto/realm/tavern/ent/user"
)

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Predicates []predicate.File  `json:"-"`
	Not        *FileWhereInput   `json:"not,omitempty"`
	Or         []*FileWhereInput `json:"or,omitempty"`
	And        []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "lastModifiedAt" field predicates.
	LastModifiedAt      *time.Time  `json:"lastmodifiedat,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastmodifiedatNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastmodifiedatIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastmodifiedatNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastmodifiedatGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastmodifiedatGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastmodifiedatLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastmodifiedatLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "size" field predicates.
	Size      *int  `json:"size,omitempty"`
	SizeNEQ   *int  `json:"sizeNEQ,omitempty"`
	SizeIn    []int `json:"sizeIn,omitempty"`
	SizeNotIn []int `json:"sizeNotIn,omitempty"`
	SizeGT    *int  `json:"sizeGT,omitempty"`
	SizeGTE   *int  `json:"sizeGTE,omitempty"`
	SizeLT    *int  `json:"sizeLT,omitempty"`
	SizeLTE   *int  `json:"sizeLTE,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileWhereInput) AddPredicates(predicates ...predicate.File) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileWhereInput is returned in case the FileWhereInput is empty.
var ErrEmptyFileWhereInput = errors.New("ent: empty predicate FileWhereInput")

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, file.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, file.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, file.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, file.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, file.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, file.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, file.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, file.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, file.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, file.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, file.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, file.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, file.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, file.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, file.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, file.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, file.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, file.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, file.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, file.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, file.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, file.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, file.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, file.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, file.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, file.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, file.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, file.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, file.NameContainsFold(*i.NameContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, file.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, file.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, file.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, file.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, file.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, file.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, file.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, file.SizeLTE(*i.SizeLTE))
	}
	if i.Hash != nil {
		predicates = append(predicates, file.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, file.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, file.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, file.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, file.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, file.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, file.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, file.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, file.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, file.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, file.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, file.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, file.HashContainsFold(*i.HashContainsFold))
	}

	if i.HasCreatedBy != nil {
		p := file.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasCreatedByWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// JobWhereInput represents a where input for filtering Job queries.
type JobWhereInput struct {
	Predicates []predicate.Job  `json:"-"`
	Not        *JobWhereInput   `json:"not,omitempty"`
	Or         []*JobWhereInput `json:"or,omitempty"`
	And        []*JobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "lastModifiedAt" field predicates.
	LastModifiedAt      *time.Time  `json:"lastmodifiedat,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastmodifiedatNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastmodifiedatIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastmodifiedatNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastmodifiedatGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastmodifiedatGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastmodifiedatLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastmodifiedatLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "createdBy" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "tome" edge predicates.
	HasTome     *bool             `json:"hasTome,omitempty"`
	HasTomeWith []*TomeWhereInput `json:"hasTomeWith,omitempty"`

	// "bundle" edge predicates.
	HasBundle     *bool             `json:"hasBundle,omitempty"`
	HasBundleWith []*FileWhereInput `json:"hasBundleWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobWhereInput) AddPredicates(predicates ...predicate.Job) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobWhereInput filter on the JobQuery builder.
func (i *JobWhereInput) Filter(q *JobQuery) (*JobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobWhereInput is returned in case the JobWhereInput is empty.
var ErrEmptyJobWhereInput = errors.New("ent: empty predicate JobWhereInput")

// P returns a predicate for filtering jobs.
// An error is returned if the input is empty or invalid.
func (i *JobWhereInput) P() (predicate.Job, error) {
	var predicates []predicate.Job
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, job.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Job, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, job.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Job, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, job.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, job.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, job.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, job.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, job.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, job.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, job.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, job.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, job.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, job.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, job.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, job.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, job.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, job.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, job.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, job.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, job.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, job.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, job.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, job.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, job.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, job.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, job.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, job.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, job.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, job.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, job.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, job.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, job.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, job.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, job.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, job.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, job.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, job.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, job.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, job.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, job.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, job.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasCreatedBy != nil {
		p := job.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasCreatedByWith(with...))
	}
	if i.HasTome != nil {
		p := job.HasTome()
		if !*i.HasTome {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTomeWith) > 0 {
		with := make([]predicate.Tome, 0, len(i.HasTomeWith))
		for _, w := range i.HasTomeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTomeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasTomeWith(with...))
	}
	if i.HasBundle != nil {
		p := job.HasBundle()
		if !*i.HasBundle {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBundleWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasBundleWith))
		for _, w := range i.HasBundleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBundleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasBundleWith(with...))
	}
	if i.HasTasks != nil {
		p := job.HasTasks()
		if !*i.HasTasks {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return job.And(predicates...), nil
	}
}

// TagWhereInput represents a where input for filtering Tag queries.
type TagWhereInput struct {
	Predicates []predicate.Tag  `json:"-"`
	Not        *TagWhereInput   `json:"not,omitempty"`
	Or         []*TagWhereInput `json:"or,omitempty"`
	And        []*TagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *tag.Kind  `json:"kind,omitempty"`
	KindNEQ   *tag.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []tag.Kind `json:"kindIn,omitempty"`
	KindNotIn []tag.Kind `json:"kindNotIn,omitempty"`

	// "targets" edge predicates.
	HasTargets     *bool               `json:"hasTargets,omitempty"`
	HasTargetsWith []*TargetWhereInput `json:"hasTargetsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TagWhereInput) AddPredicates(predicates ...predicate.Tag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TagWhereInput filter on the TagQuery builder.
func (i *TagWhereInput) Filter(q *TagQuery) (*TagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTagWhereInput is returned in case the TagWhereInput is empty.
var ErrEmptyTagWhereInput = errors.New("ent: empty predicate TagWhereInput")

// P returns a predicate for filtering tags.
// An error is returned if the input is empty or invalid.
func (i *TagWhereInput) P() (predicate.Tag, error) {
	var predicates []predicate.Tag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tag.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tag.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, tag.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, tag.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, tag.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, tag.KindNotIn(i.KindNotIn...))
	}

	if i.HasTargets != nil {
		p := tag.HasTargets()
		if !*i.HasTargets {
			p = tag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetsWith) > 0 {
		with := make([]predicate.Target, 0, len(i.HasTargetsWith))
		for _, w := range i.HasTargetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTargetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tag.HasTargetsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tag.And(predicates...), nil
	}
}

// TargetWhereInput represents a where input for filtering Target queries.
type TargetWhereInput struct {
	Predicates []predicate.Target  `json:"-"`
	Not        *TargetWhereInput   `json:"not,omitempty"`
	Or         []*TargetWhereInput `json:"or,omitempty"`
	And        []*TargetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tags" edge predicates.
	HasTags     *bool            `json:"hasTags,omitempty"`
	HasTagsWith []*TagWhereInput `json:"hasTagsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TargetWhereInput) AddPredicates(predicates ...predicate.Target) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TargetWhereInput filter on the TargetQuery builder.
func (i *TargetWhereInput) Filter(q *TargetQuery) (*TargetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTargetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTargetWhereInput is returned in case the TargetWhereInput is empty.
var ErrEmptyTargetWhereInput = errors.New("ent: empty predicate TargetWhereInput")

// P returns a predicate for filtering targets.
// An error is returned if the input is empty or invalid.
func (i *TargetWhereInput) P() (predicate.Target, error) {
	var predicates []predicate.Target
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, target.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Target, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, target.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Target, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, target.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, target.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, target.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, target.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, target.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, target.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, target.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, target.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, target.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, target.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, target.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, target.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, target.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, target.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, target.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, target.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, target.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, target.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, target.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, target.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, target.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, target.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasTags != nil {
		p := target.HasTags()
		if !*i.HasTags {
			p = target.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTagsWith) > 0 {
		with := make([]predicate.Tag, 0, len(i.HasTagsWith))
		for _, w := range i.HasTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, target.HasTagsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTargetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return target.And(predicates...), nil
	}
}

// TaskWhereInput represents a where input for filtering Task queries.
type TaskWhereInput struct {
	Predicates []predicate.Task  `json:"-"`
	Not        *TaskWhereInput   `json:"not,omitempty"`
	Or         []*TaskWhereInput `json:"or,omitempty"`
	And        []*TaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "job" edge predicates.
	HasJob     *bool            `json:"hasJob,omitempty"`
	HasJobWith []*JobWhereInput `json:"hasJobWith,omitempty"`

	// "target" edge predicates.
	HasTarget     *bool               `json:"hasTarget,omitempty"`
	HasTargetWith []*TargetWhereInput `json:"hasTargetWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TaskWhereInput) AddPredicates(predicates ...predicate.Task) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TaskWhereInput filter on the TaskQuery builder.
func (i *TaskWhereInput) Filter(q *TaskQuery) (*TaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTaskWhereInput is returned in case the TaskWhereInput is empty.
var ErrEmptyTaskWhereInput = errors.New("ent: empty predicate TaskWhereInput")

// P returns a predicate for filtering tasks.
// An error is returned if the input is empty or invalid.
func (i *TaskWhereInput) P() (predicate.Task, error) {
	var predicates []predicate.Task
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, task.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Task, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, task.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Task, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, task.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, task.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, task.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, task.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, task.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, task.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, task.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, task.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, task.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, task.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, task.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, task.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, task.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, task.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, task.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, task.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, task.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, task.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, task.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, task.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, task.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, task.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasJob != nil {
		p := task.HasJob()
		if !*i.HasJob {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasJobWith(with...))
	}
	if i.HasTarget != nil {
		p := task.HasTarget()
		if !*i.HasTarget {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetWith) > 0 {
		with := make([]predicate.Target, 0, len(i.HasTargetWith))
		for _, w := range i.HasTargetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTargetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasTargetWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return task.And(predicates...), nil
	}
}

// TomeWhereInput represents a where input for filtering Tome queries.
type TomeWhereInput struct {
	Predicates []predicate.Tome  `json:"-"`
	Not        *TomeWhereInput   `json:"not,omitempty"`
	Or         []*TomeWhereInput `json:"or,omitempty"`
	And        []*TomeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "parameters" field predicates.
	Parameters             *string  `json:"parameters,omitempty"`
	ParametersNEQ          *string  `json:"parametersNEQ,omitempty"`
	ParametersIn           []string `json:"parametersIn,omitempty"`
	ParametersNotIn        []string `json:"parametersNotIn,omitempty"`
	ParametersGT           *string  `json:"parametersGT,omitempty"`
	ParametersGTE          *string  `json:"parametersGTE,omitempty"`
	ParametersLT           *string  `json:"parametersLT,omitempty"`
	ParametersLTE          *string  `json:"parametersLTE,omitempty"`
	ParametersContains     *string  `json:"parametersContains,omitempty"`
	ParametersHasPrefix    *string  `json:"parametersHasPrefix,omitempty"`
	ParametersHasSuffix    *string  `json:"parametersHasSuffix,omitempty"`
	ParametersEqualFold    *string  `json:"parametersEqualFold,omitempty"`
	ParametersContainsFold *string  `json:"parametersContainsFold,omitempty"`

	// "size" field predicates.
	Size      *int  `json:"size,omitempty"`
	SizeNEQ   *int  `json:"sizeNEQ,omitempty"`
	SizeIn    []int `json:"sizeIn,omitempty"`
	SizeNotIn []int `json:"sizeNotIn,omitempty"`
	SizeGT    *int  `json:"sizeGT,omitempty"`
	SizeGTE   *int  `json:"sizeGTE,omitempty"`
	SizeLT    *int  `json:"sizeLT,omitempty"`
	SizeLTE   *int  `json:"sizeLTE,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "lastModifiedAt" field predicates.
	LastModifiedAt      *time.Time  `json:"lastmodifiedat,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastmodifiedatNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastmodifiedatIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastmodifiedatNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastmodifiedatGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastmodifiedatGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastmodifiedatLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastmodifiedatLTE,omitempty"`

	// "eldritch" field predicates.
	Eldritch             *string  `json:"eldritch,omitempty"`
	EldritchNEQ          *string  `json:"eldritchNEQ,omitempty"`
	EldritchIn           []string `json:"eldritchIn,omitempty"`
	EldritchNotIn        []string `json:"eldritchNotIn,omitempty"`
	EldritchGT           *string  `json:"eldritchGT,omitempty"`
	EldritchGTE          *string  `json:"eldritchGTE,omitempty"`
	EldritchLT           *string  `json:"eldritchLT,omitempty"`
	EldritchLTE          *string  `json:"eldritchLTE,omitempty"`
	EldritchContains     *string  `json:"eldritchContains,omitempty"`
	EldritchHasPrefix    *string  `json:"eldritchHasPrefix,omitempty"`
	EldritchHasSuffix    *string  `json:"eldritchHasSuffix,omitempty"`
	EldritchEqualFold    *string  `json:"eldritchEqualFold,omitempty"`
	EldritchContainsFold *string  `json:"eldritchContainsFold,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TomeWhereInput) AddPredicates(predicates ...predicate.Tome) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TomeWhereInput filter on the TomeQuery builder.
func (i *TomeWhereInput) Filter(q *TomeQuery) (*TomeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTomeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTomeWhereInput is returned in case the TomeWhereInput is empty.
var ErrEmptyTomeWhereInput = errors.New("ent: empty predicate TomeWhereInput")

// P returns a predicate for filtering tomes.
// An error is returned if the input is empty or invalid.
func (i *TomeWhereInput) P() (predicate.Tome, error) {
	var predicates []predicate.Tome
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tome.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tome, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tome.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tome, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tome.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tome.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tome.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tome.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tome.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tome.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tome.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tome.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tome.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tome.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tome.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tome.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tome.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tome.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tome.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tome.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tome.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tome.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tome.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tome.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tome.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tome.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, tome.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, tome.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, tome.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, tome.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, tome.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, tome.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, tome.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, tome.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, tome.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, tome.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, tome.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, tome.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, tome.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Parameters != nil {
		predicates = append(predicates, tome.ParametersEQ(*i.Parameters))
	}
	if i.ParametersNEQ != nil {
		predicates = append(predicates, tome.ParametersNEQ(*i.ParametersNEQ))
	}
	if len(i.ParametersIn) > 0 {
		predicates = append(predicates, tome.ParametersIn(i.ParametersIn...))
	}
	if len(i.ParametersNotIn) > 0 {
		predicates = append(predicates, tome.ParametersNotIn(i.ParametersNotIn...))
	}
	if i.ParametersGT != nil {
		predicates = append(predicates, tome.ParametersGT(*i.ParametersGT))
	}
	if i.ParametersGTE != nil {
		predicates = append(predicates, tome.ParametersGTE(*i.ParametersGTE))
	}
	if i.ParametersLT != nil {
		predicates = append(predicates, tome.ParametersLT(*i.ParametersLT))
	}
	if i.ParametersLTE != nil {
		predicates = append(predicates, tome.ParametersLTE(*i.ParametersLTE))
	}
	if i.ParametersContains != nil {
		predicates = append(predicates, tome.ParametersContains(*i.ParametersContains))
	}
	if i.ParametersHasPrefix != nil {
		predicates = append(predicates, tome.ParametersHasPrefix(*i.ParametersHasPrefix))
	}
	if i.ParametersHasSuffix != nil {
		predicates = append(predicates, tome.ParametersHasSuffix(*i.ParametersHasSuffix))
	}
	if i.ParametersEqualFold != nil {
		predicates = append(predicates, tome.ParametersEqualFold(*i.ParametersEqualFold))
	}
	if i.ParametersContainsFold != nil {
		predicates = append(predicates, tome.ParametersContainsFold(*i.ParametersContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, tome.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, tome.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, tome.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, tome.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, tome.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, tome.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, tome.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, tome.SizeLTE(*i.SizeLTE))
	}
	if i.Hash != nil {
		predicates = append(predicates, tome.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, tome.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, tome.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, tome.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, tome.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, tome.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, tome.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, tome.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, tome.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, tome.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, tome.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, tome.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, tome.HashContainsFold(*i.HashContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, tome.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, tome.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, tome.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, tome.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, tome.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, tome.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, tome.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, tome.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, tome.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, tome.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, tome.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, tome.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, tome.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, tome.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, tome.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, tome.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Eldritch != nil {
		predicates = append(predicates, tome.EldritchEQ(*i.Eldritch))
	}
	if i.EldritchNEQ != nil {
		predicates = append(predicates, tome.EldritchNEQ(*i.EldritchNEQ))
	}
	if len(i.EldritchIn) > 0 {
		predicates = append(predicates, tome.EldritchIn(i.EldritchIn...))
	}
	if len(i.EldritchNotIn) > 0 {
		predicates = append(predicates, tome.EldritchNotIn(i.EldritchNotIn...))
	}
	if i.EldritchGT != nil {
		predicates = append(predicates, tome.EldritchGT(*i.EldritchGT))
	}
	if i.EldritchGTE != nil {
		predicates = append(predicates, tome.EldritchGTE(*i.EldritchGTE))
	}
	if i.EldritchLT != nil {
		predicates = append(predicates, tome.EldritchLT(*i.EldritchLT))
	}
	if i.EldritchLTE != nil {
		predicates = append(predicates, tome.EldritchLTE(*i.EldritchLTE))
	}
	if i.EldritchContains != nil {
		predicates = append(predicates, tome.EldritchContains(*i.EldritchContains))
	}
	if i.EldritchHasPrefix != nil {
		predicates = append(predicates, tome.EldritchHasPrefix(*i.EldritchHasPrefix))
	}
	if i.EldritchHasSuffix != nil {
		predicates = append(predicates, tome.EldritchHasSuffix(*i.EldritchHasSuffix))
	}
	if i.EldritchEqualFold != nil {
		predicates = append(predicates, tome.EldritchEqualFold(*i.EldritchEqualFold))
	}
	if i.EldritchContainsFold != nil {
		predicates = append(predicates, tome.EldritchContainsFold(*i.EldritchContainsFold))
	}

	if i.HasFiles != nil {
		p := tome.HasFiles()
		if !*i.HasFiles {
			p = tome.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tome.HasFilesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTomeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tome.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "Name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "OAuthID" field predicates.
	OAuthID             *string  `json:"oauthid,omitempty"`
	OAuthIDNEQ          *string  `json:"oauthidNEQ,omitempty"`
	OAuthIDIn           []string `json:"oauthidIn,omitempty"`
	OAuthIDNotIn        []string `json:"oauthidNotIn,omitempty"`
	OAuthIDGT           *string  `json:"oauthidGT,omitempty"`
	OAuthIDGTE          *string  `json:"oauthidGTE,omitempty"`
	OAuthIDLT           *string  `json:"oauthidLT,omitempty"`
	OAuthIDLTE          *string  `json:"oauthidLTE,omitempty"`
	OAuthIDContains     *string  `json:"oauthidContains,omitempty"`
	OAuthIDHasPrefix    *string  `json:"oauthidHasPrefix,omitempty"`
	OAuthIDHasSuffix    *string  `json:"oauthidHasSuffix,omitempty"`
	OAuthIDEqualFold    *string  `json:"oauthidEqualFold,omitempty"`
	OAuthIDContainsFold *string  `json:"oauthidContainsFold,omitempty"`

	// "PhotoURL" field predicates.
	PhotoURL             *string  `json:"photourl,omitempty"`
	PhotoURLNEQ          *string  `json:"photourlNEQ,omitempty"`
	PhotoURLIn           []string `json:"photourlIn,omitempty"`
	PhotoURLNotIn        []string `json:"photourlNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photourlGT,omitempty"`
	PhotoURLGTE          *string  `json:"photourlGTE,omitempty"`
	PhotoURLLT           *string  `json:"photourlLT,omitempty"`
	PhotoURLLTE          *string  `json:"photourlLTE,omitempty"`
	PhotoURLContains     *string  `json:"photourlContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photourlHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photourlHasSuffix,omitempty"`
	PhotoURLEqualFold    *string  `json:"photourlEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photourlContainsFold,omitempty"`

	// "IsActivated" field predicates.
	IsActivated    *bool `json:"isactivated,omitempty"`
	IsActivatedNEQ *bool `json:"isactivatedNEQ,omitempty"`

	// "IsAdmin" field predicates.
	IsAdmin    *bool `json:"isadmin,omitempty"`
	IsAdminNEQ *bool `json:"isadminNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.OAuthID != nil {
		predicates = append(predicates, user.OAuthIDEQ(*i.OAuthID))
	}
	if i.OAuthIDNEQ != nil {
		predicates = append(predicates, user.OAuthIDNEQ(*i.OAuthIDNEQ))
	}
	if len(i.OAuthIDIn) > 0 {
		predicates = append(predicates, user.OAuthIDIn(i.OAuthIDIn...))
	}
	if len(i.OAuthIDNotIn) > 0 {
		predicates = append(predicates, user.OAuthIDNotIn(i.OAuthIDNotIn...))
	}
	if i.OAuthIDGT != nil {
		predicates = append(predicates, user.OAuthIDGT(*i.OAuthIDGT))
	}
	if i.OAuthIDGTE != nil {
		predicates = append(predicates, user.OAuthIDGTE(*i.OAuthIDGTE))
	}
	if i.OAuthIDLT != nil {
		predicates = append(predicates, user.OAuthIDLT(*i.OAuthIDLT))
	}
	if i.OAuthIDLTE != nil {
		predicates = append(predicates, user.OAuthIDLTE(*i.OAuthIDLTE))
	}
	if i.OAuthIDContains != nil {
		predicates = append(predicates, user.OAuthIDContains(*i.OAuthIDContains))
	}
	if i.OAuthIDHasPrefix != nil {
		predicates = append(predicates, user.OAuthIDHasPrefix(*i.OAuthIDHasPrefix))
	}
	if i.OAuthIDHasSuffix != nil {
		predicates = append(predicates, user.OAuthIDHasSuffix(*i.OAuthIDHasSuffix))
	}
	if i.OAuthIDEqualFold != nil {
		predicates = append(predicates, user.OAuthIDEqualFold(*i.OAuthIDEqualFold))
	}
	if i.OAuthIDContainsFold != nil {
		predicates = append(predicates, user.OAuthIDContainsFold(*i.OAuthIDContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, user.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, user.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, user.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, user.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, user.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, user.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, user.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, user.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, user.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, user.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, user.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, user.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, user.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.IsActivated != nil {
		predicates = append(predicates, user.IsActivatedEQ(*i.IsActivated))
	}
	if i.IsActivatedNEQ != nil {
		predicates = append(predicates, user.IsActivatedNEQ(*i.IsActivatedNEQ))
	}
	if i.IsAdmin != nil {
		predicates = append(predicates, user.IsAdminEQ(*i.IsAdmin))
	}
	if i.IsAdminNEQ != nil {
		predicates = append(predicates, user.IsAdminNEQ(*i.IsAdminNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
