// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/kcarretto/realm/tavern/ent"
	"github.com/kcarretto/realm/tavern/graphql/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	File struct {
		CreatedAt      func(childComplexity int) int
		Hash           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Size           func(childComplexity int) int
	}

	Job struct {
		Bundle         func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Tasks          func(childComplexity int) int
		Tome           func(childComplexity int) int
	}

	Mutation struct {
		ClaimTasks func(childComplexity int, input models.ClaimTasksInput) int
		CreateJob  func(childComplexity int, sessionIDs []int, input ent.CreateJobInput) int
		UpdateUser func(childComplexity int, userID int, input ent.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Files    func(childComplexity int) int
		Jobs     func(childComplexity int) int
		Node     func(childComplexity int, id int) int
		Nodes    func(childComplexity int, ids []int) int
		Sessions func(childComplexity int) int
		Tags     func(childComplexity int) int
		Tomes    func(childComplexity int) int
		Users    func(childComplexity int) int
	}

	Session struct {
		AgentIdentifier func(childComplexity int) int
		HostIdentifier  func(childComplexity int) int
		Hostname        func(childComplexity int) int
		ID              func(childComplexity int) int
		Identifier      func(childComplexity int) int
		LastSeenAt      func(childComplexity int) int
		Principal       func(childComplexity int) int
		Tags            func(childComplexity int) int
		Tasks           func(childComplexity int) int
	}

	Tag struct {
		ID       func(childComplexity int) int
		Kind     func(childComplexity int) int
		Name     func(childComplexity int) int
		Sessions func(childComplexity int) int
	}

	Task struct {
		ClaimedAt      func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Error          func(childComplexity int) int
		ExecFinishedAt func(childComplexity int) int
		ExecStartedAt  func(childComplexity int) int
		ID             func(childComplexity int) int
		Job            func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Output         func(childComplexity int) int
		Session        func(childComplexity int) int
	}

	Tome struct {
		CreatedAt      func(childComplexity int) int
		Description    func(childComplexity int) int
		Eldritch       func(childComplexity int) int
		Files          func(childComplexity int) int
		Hash           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Parameters     func(childComplexity int) int
	}

	User struct {
		ID          func(childComplexity int) int
		IsActivated func(childComplexity int) int
		IsAdmin     func(childComplexity int) int
		Name        func(childComplexity int) int
		PhotoURL    func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "File.createdat":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.hash":
		if e.complexity.File.Hash == nil {
			break
		}

		return e.complexity.File.Hash(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.lastmodifiedat":
		if e.complexity.File.LastModifiedAt == nil {
			break
		}

		return e.complexity.File.LastModifiedAt(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "Job.bundle":
		if e.complexity.Job.Bundle == nil {
			break
		}

		return e.complexity.Job.Bundle(childComplexity), true

	case "Job.createdat":
		if e.complexity.Job.CreatedAt == nil {
			break
		}

		return e.complexity.Job.CreatedAt(childComplexity), true

	case "Job.id":
		if e.complexity.Job.ID == nil {
			break
		}

		return e.complexity.Job.ID(childComplexity), true

	case "Job.lastmodifiedat":
		if e.complexity.Job.LastModifiedAt == nil {
			break
		}

		return e.complexity.Job.LastModifiedAt(childComplexity), true

	case "Job.name":
		if e.complexity.Job.Name == nil {
			break
		}

		return e.complexity.Job.Name(childComplexity), true

	case "Job.tasks":
		if e.complexity.Job.Tasks == nil {
			break
		}

		return e.complexity.Job.Tasks(childComplexity), true

	case "Job.tome":
		if e.complexity.Job.Tome == nil {
			break
		}

		return e.complexity.Job.Tome(childComplexity), true

	case "Mutation.claimTasks":
		if e.complexity.Mutation.ClaimTasks == nil {
			break
		}

		args, err := ec.field_Mutation_claimTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ClaimTasks(childComplexity, args["input"].(models.ClaimTasksInput)), true

	case "Mutation.createJob":
		if e.complexity.Mutation.CreateJob == nil {
			break
		}

		args, err := ec.field_Mutation_createJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateJob(childComplexity, args["sessionIDs"].([]int), args["input"].(ent.CreateJobInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["userID"].(int), args["input"].(ent.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.files":
		if e.complexity.Query.Files == nil {
			break
		}

		return e.complexity.Query.Files(childComplexity), true

	case "Query.jobs":
		if e.complexity.Query.Jobs == nil {
			break
		}

		return e.complexity.Query.Jobs(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.sessions":
		if e.complexity.Query.Sessions == nil {
			break
		}

		return e.complexity.Query.Sessions(childComplexity), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		return e.complexity.Query.Tags(childComplexity), true

	case "Query.tomes":
		if e.complexity.Query.Tomes == nil {
			break
		}

		return e.complexity.Query.Tomes(childComplexity), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "Session.agentidentifier":
		if e.complexity.Session.AgentIdentifier == nil {
			break
		}

		return e.complexity.Session.AgentIdentifier(childComplexity), true

	case "Session.hostidentifier":
		if e.complexity.Session.HostIdentifier == nil {
			break
		}

		return e.complexity.Session.HostIdentifier(childComplexity), true

	case "Session.hostname":
		if e.complexity.Session.Hostname == nil {
			break
		}

		return e.complexity.Session.Hostname(childComplexity), true

	case "Session.id":
		if e.complexity.Session.ID == nil {
			break
		}

		return e.complexity.Session.ID(childComplexity), true

	case "Session.identifier":
		if e.complexity.Session.Identifier == nil {
			break
		}

		return e.complexity.Session.Identifier(childComplexity), true

	case "Session.lastseenat":
		if e.complexity.Session.LastSeenAt == nil {
			break
		}

		return e.complexity.Session.LastSeenAt(childComplexity), true

	case "Session.principal":
		if e.complexity.Session.Principal == nil {
			break
		}

		return e.complexity.Session.Principal(childComplexity), true

	case "Session.tags":
		if e.complexity.Session.Tags == nil {
			break
		}

		return e.complexity.Session.Tags(childComplexity), true

	case "Session.tasks":
		if e.complexity.Session.Tasks == nil {
			break
		}

		return e.complexity.Session.Tasks(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.kind":
		if e.complexity.Tag.Kind == nil {
			break
		}

		return e.complexity.Tag.Kind(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Tag.sessions":
		if e.complexity.Tag.Sessions == nil {
			break
		}

		return e.complexity.Tag.Sessions(childComplexity), true

	case "Task.claimedat":
		if e.complexity.Task.ClaimedAt == nil {
			break
		}

		return e.complexity.Task.ClaimedAt(childComplexity), true

	case "Task.createdat":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.error":
		if e.complexity.Task.Error == nil {
			break
		}

		return e.complexity.Task.Error(childComplexity), true

	case "Task.execfinishedat":
		if e.complexity.Task.ExecFinishedAt == nil {
			break
		}

		return e.complexity.Task.ExecFinishedAt(childComplexity), true

	case "Task.execstartedat":
		if e.complexity.Task.ExecStartedAt == nil {
			break
		}

		return e.complexity.Task.ExecStartedAt(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.job":
		if e.complexity.Task.Job == nil {
			break
		}

		return e.complexity.Task.Job(childComplexity), true

	case "Task.lastmodifiedat":
		if e.complexity.Task.LastModifiedAt == nil {
			break
		}

		return e.complexity.Task.LastModifiedAt(childComplexity), true

	case "Task.output":
		if e.complexity.Task.Output == nil {
			break
		}

		return e.complexity.Task.Output(childComplexity), true

	case "Task.session":
		if e.complexity.Task.Session == nil {
			break
		}

		return e.complexity.Task.Session(childComplexity), true

	case "Tome.createdat":
		if e.complexity.Tome.CreatedAt == nil {
			break
		}

		return e.complexity.Tome.CreatedAt(childComplexity), true

	case "Tome.description":
		if e.complexity.Tome.Description == nil {
			break
		}

		return e.complexity.Tome.Description(childComplexity), true

	case "Tome.eldritch":
		if e.complexity.Tome.Eldritch == nil {
			break
		}

		return e.complexity.Tome.Eldritch(childComplexity), true

	case "Tome.files":
		if e.complexity.Tome.Files == nil {
			break
		}

		return e.complexity.Tome.Files(childComplexity), true

	case "Tome.hash":
		if e.complexity.Tome.Hash == nil {
			break
		}

		return e.complexity.Tome.Hash(childComplexity), true

	case "Tome.id":
		if e.complexity.Tome.ID == nil {
			break
		}

		return e.complexity.Tome.ID(childComplexity), true

	case "Tome.lastmodifiedat":
		if e.complexity.Tome.LastModifiedAt == nil {
			break
		}

		return e.complexity.Tome.LastModifiedAt(childComplexity), true

	case "Tome.name":
		if e.complexity.Tome.Name == nil {
			break
		}

		return e.complexity.Tome.Name(childComplexity), true

	case "Tome.parameters":
		if e.complexity.Tome.Parameters == nil {
			break
		}

		return e.complexity.Tome.Parameters(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isactivated":
		if e.complexity.User.IsActivated == nil {
			break
		}

		return e.complexity.User.IsActivated(childComplexity), true

	case "User.isadmin":
		if e.complexity.User.IsAdmin == nil {
			break
		}

		return e.complexity.User.IsAdmin(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.photourl":
		if e.complexity.User.PhotoURL == nil {
			break
		}

		return e.complexity.User.PhotoURL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputClaimTasksInput,
		ec.unmarshalInputCreateJobInput,
		ec.unmarshalInputFileOrder,
		ec.unmarshalInputFileWhereInput,
		ec.unmarshalInputJobOrder,
		ec.unmarshalInputJobWhereInput,
		ec.unmarshalInputSessionOrder,
		ec.unmarshalInputSessionWhereInput,
		ec.unmarshalInputTagOrder,
		ec.unmarshalInputTagWhereInput,
		ec.unmarshalInputTaskOrder,
		ec.unmarshalInputTaskWhereInput,
		ec.unmarshalInputTomeOrder,
		ec.unmarshalInputTomeWhereInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/scalars.graphql", Input: `scalar Time`, BuiltIn: false},
	{Name: "../schema/query.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateJobInput is used for create Job object.
Input was generated by ent.
"""
input CreateJobInput {
  """Name of the job"""
  name: String!
  tomeID: ID!
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type File implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdat: Time! @goField(name: "CreatedAt", forceResolver: false)
  """Timestamp of when this ent was last updated"""
  lastmodifiedat: Time! @goField(name: "LastModifiedAt", forceResolver: false)
  """The name of the file, used to reference it for downloads"""
  name: String!
  """The size of the file in bytes"""
  size: Int!
  """A SHA3 digest of the content field"""
  hash: String!
}
"""Ordering options for File connections"""
input FileOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Files."""
  field: FileOrderField!
}
"""Properties by which File connections can be ordered."""
enum FileOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
FileWhereInput is used for filtering File objects.
Input was generated by ent.
"""
input FileWhereInput {
  not: FileWhereInput
  and: [FileWhereInput!]
  or: [FileWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """createdAt field predicates"""
  createdat: Time
  createdatNEQ: Time
  createdatIn: [Time!]
  createdatNotIn: [Time!]
  createdatGT: Time
  createdatGTE: Time
  createdatLT: Time
  createdatLTE: Time
  """lastModifiedAt field predicates"""
  lastmodifiedat: Time
  lastmodifiedatNEQ: Time
  lastmodifiedatIn: [Time!]
  lastmodifiedatNotIn: [Time!]
  lastmodifiedatGT: Time
  lastmodifiedatGTE: Time
  lastmodifiedatLT: Time
  lastmodifiedatLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """size field predicates"""
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """hash field predicates"""
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashEqualFold: String
  hashContainsFold: String
}
type Job implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdat: Time! @goField(name: "CreatedAt", forceResolver: false)
  """Timestamp of when this ent was last updated"""
  lastmodifiedat: Time! @goField(name: "LastModifiedAt", forceResolver: false)
  """Name of the job"""
  name: String!
  tome: Tome!
  bundle: File
  tasks: [Task!]
}
"""Ordering options for Job connections"""
input JobOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Jobs."""
  field: JobOrderField!
}
"""Properties by which Job connections can be ordered."""
enum JobOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
JobWhereInput is used for filtering Job objects.
Input was generated by ent.
"""
input JobWhereInput {
  not: JobWhereInput
  and: [JobWhereInput!]
  or: [JobWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """createdAt field predicates"""
  createdat: Time
  createdatNEQ: Time
  createdatIn: [Time!]
  createdatNotIn: [Time!]
  createdatGT: Time
  createdatGTE: Time
  createdatLT: Time
  createdatLTE: Time
  """lastModifiedAt field predicates"""
  lastmodifiedat: Time
  lastmodifiedatNEQ: Time
  lastmodifiedatIn: [Time!]
  lastmodifiedatNotIn: [Time!]
  lastmodifiedatGT: Time
  lastmodifiedatGTE: Time
  lastmodifiedatLT: Time
  lastmodifiedatLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """tome edge predicates"""
  hasTome: Boolean
  hasTomeWith: [TomeWhereInput!]
  """bundle edge predicates"""
  hasBundle: Boolean
  hasBundleWith: [FileWhereInput!]
  """tasks edge predicates"""
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/kcarretto/realm/tavern/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  files: [File!]!
  jobs: [Job!]!
  sessions: [Session!]!
  tags: [Tag!]!
  tomes: [Tome!]!
  users: [User!]!
}
type Session implements Node {
  id: ID!
  """The identity the session is authenticated as (e.g. 'root')"""
  principal: String
  """The hostname of the system the session is running on."""
  hostname: String
  """Unique identifier for the session. Unique to each instance of the session."""
  identifier: String!
  """Identifies the agent that the session is running as (e.g. 'imix')."""
  agentidentifier: String @goField(name: "AgentIdentifier", forceResolver: false)
  """Unique identifier for the host the session is running on."""
  hostidentifier: String @goField(name: "HostIdentifier", forceResolver: false)
  """Timestamp of when a task was last claimed or updated for a target"""
  lastseenat: Time @goField(name: "LastSeenAt", forceResolver: false)
  tags: [Tag!]
  tasks: [Task!]
}
"""Ordering options for Session connections"""
input SessionOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Sessions."""
  field: SessionOrderField!
}
"""Properties by which Session connections can be ordered."""
enum SessionOrderField {
  LAST_SEEN_AT
}
"""
SessionWhereInput is used for filtering Session objects.
Input was generated by ent.
"""
input SessionWhereInput {
  not: SessionWhereInput
  and: [SessionWhereInput!]
  or: [SessionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """principal field predicates"""
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalIsNil: Boolean
  principalNotNil: Boolean
  principalEqualFold: String
  principalContainsFold: String
  """hostname field predicates"""
  hostname: String
  hostnameNEQ: String
  hostnameIn: [String!]
  hostnameNotIn: [String!]
  hostnameGT: String
  hostnameGTE: String
  hostnameLT: String
  hostnameLTE: String
  hostnameContains: String
  hostnameHasPrefix: String
  hostnameHasSuffix: String
  hostnameIsNil: Boolean
  hostnameNotNil: Boolean
  hostnameEqualFold: String
  hostnameContainsFold: String
  """identifier field predicates"""
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """agentIdentifier field predicates"""
  agentidentifier: String
  agentidentifierNEQ: String
  agentidentifierIn: [String!]
  agentidentifierNotIn: [String!]
  agentidentifierGT: String
  agentidentifierGTE: String
  agentidentifierLT: String
  agentidentifierLTE: String
  agentidentifierContains: String
  agentidentifierHasPrefix: String
  agentidentifierHasSuffix: String
  agentidentifierIsNil: Boolean
  agentidentifierNotNil: Boolean
  agentidentifierEqualFold: String
  agentidentifierContainsFold: String
  """hostIdentifier field predicates"""
  hostidentifier: String
  hostidentifierNEQ: String
  hostidentifierIn: [String!]
  hostidentifierNotIn: [String!]
  hostidentifierGT: String
  hostidentifierGTE: String
  hostidentifierLT: String
  hostidentifierLTE: String
  hostidentifierContains: String
  hostidentifierHasPrefix: String
  hostidentifierHasSuffix: String
  hostidentifierIsNil: Boolean
  hostidentifierNotNil: Boolean
  hostidentifierEqualFold: String
  hostidentifierContainsFold: String
  """lastSeenAt field predicates"""
  lastseenat: Time
  lastseenatNEQ: Time
  lastseenatIn: [Time!]
  lastseenatNotIn: [Time!]
  lastseenatGT: Time
  lastseenatGTE: Time
  lastseenatLT: Time
  lastseenatLTE: Time
  lastseenatIsNil: Boolean
  lastseenatNotNil: Boolean
  """tags edge predicates"""
  hasTags: Boolean
  hasTagsWith: [TagWhereInput!]
  """tasks edge predicates"""
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
}
type Tag implements Node {
  id: ID!
  """Name of the tag"""
  name: String!
  """Describes the type of tag this is"""
  kind: TagTagKind!
  sessions: [Session!]!
}
"""Ordering options for Tag connections"""
input TagOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tags."""
  field: TagOrderField!
}
"""Properties by which Tag connections can be ordered."""
enum TagOrderField {
  NAME
}
"""TagTagKind is enum for the field kind"""
enum TagTagKind @goModel(model: "github.com/kcarretto/realm/tavern/ent/tag.Kind") {
  group
  service
}
"""
TagWhereInput is used for filtering Tag objects.
Input was generated by ent.
"""
input TagWhereInput {
  not: TagWhereInput
  and: [TagWhereInput!]
  or: [TagWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """kind field predicates"""
  kind: TagTagKind
  kindNEQ: TagTagKind
  kindIn: [TagTagKind!]
  kindNotIn: [TagTagKind!]
  """sessions edge predicates"""
  hasSessions: Boolean
  hasSessionsWith: [SessionWhereInput!]
}
type Task implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdat: Time! @goField(name: "CreatedAt", forceResolver: false)
  """Timestamp of when this ent was last updated"""
  lastmodifiedat: Time! @goField(name: "LastModifiedAt", forceResolver: false)
  """Timestamp of when the task was claimed, null if not yet claimed"""
  claimedat: Time @goField(name: "ClaimedAt", forceResolver: false)
  """Timestamp of when execution of the task started, null if not yet started"""
  execstartedat: Time @goField(name: "ExecStartedAt", forceResolver: false)
  """Timestamp of when execution of the task finished, null if not yet finished"""
  execfinishedat: Time @goField(name: "ExecFinishedAt", forceResolver: false)
  """Output from executing the task"""
  output: String
  """Error, if any, produced while executing the Task"""
  error: String
  job: Job!
  session: Session!
}
"""Ordering options for Task connections"""
input TaskOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tasks."""
  field: TaskOrderField!
}
"""Properties by which Task connections can be ordered."""
enum TaskOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLAIMED_AT
  EXEC_STARTED_AT
  EXEC_FINISHED_AT
}
"""
TaskWhereInput is used for filtering Task objects.
Input was generated by ent.
"""
input TaskWhereInput {
  not: TaskWhereInput
  and: [TaskWhereInput!]
  or: [TaskWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """createdAt field predicates"""
  createdat: Time
  createdatNEQ: Time
  createdatIn: [Time!]
  createdatNotIn: [Time!]
  createdatGT: Time
  createdatGTE: Time
  createdatLT: Time
  createdatLTE: Time
  """lastModifiedAt field predicates"""
  lastmodifiedat: Time
  lastmodifiedatNEQ: Time
  lastmodifiedatIn: [Time!]
  lastmodifiedatNotIn: [Time!]
  lastmodifiedatGT: Time
  lastmodifiedatGTE: Time
  lastmodifiedatLT: Time
  lastmodifiedatLTE: Time
  """claimedAt field predicates"""
  claimedat: Time
  claimedatNEQ: Time
  claimedatIn: [Time!]
  claimedatNotIn: [Time!]
  claimedatGT: Time
  claimedatGTE: Time
  claimedatLT: Time
  claimedatLTE: Time
  claimedatIsNil: Boolean
  claimedatNotNil: Boolean
  """execStartedAt field predicates"""
  execstartedat: Time
  execstartedatNEQ: Time
  execstartedatIn: [Time!]
  execstartedatNotIn: [Time!]
  execstartedatGT: Time
  execstartedatGTE: Time
  execstartedatLT: Time
  execstartedatLTE: Time
  execstartedatIsNil: Boolean
  execstartedatNotNil: Boolean
  """execFinishedAt field predicates"""
  execfinishedat: Time
  execfinishedatNEQ: Time
  execfinishedatIn: [Time!]
  execfinishedatNotIn: [Time!]
  execfinishedatGT: Time
  execfinishedatGTE: Time
  execfinishedatLT: Time
  execfinishedatLTE: Time
  execfinishedatIsNil: Boolean
  execfinishedatNotNil: Boolean
  """output field predicates"""
  output: String
  outputNEQ: String
  outputIn: [String!]
  outputNotIn: [String!]
  outputGT: String
  outputGTE: String
  outputLT: String
  outputLTE: String
  outputContains: String
  outputHasPrefix: String
  outputHasSuffix: String
  outputIsNil: Boolean
  outputNotNil: Boolean
  outputEqualFold: String
  outputContainsFold: String
  """error field predicates"""
  error: String
  errorNEQ: String
  errorIn: [String!]
  errorNotIn: [String!]
  errorGT: String
  errorGTE: String
  errorLT: String
  errorLTE: String
  errorContains: String
  errorHasPrefix: String
  errorHasSuffix: String
  errorIsNil: Boolean
  errorNotNil: Boolean
  errorEqualFold: String
  errorContainsFold: String
  """job edge predicates"""
  hasJob: Boolean
  hasJobWith: [JobWhereInput!]
  """session edge predicates"""
  hasSession: Boolean
  hasSessionWith: [SessionWhereInput!]
}
type Tome implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdat: Time! @goField(name: "CreatedAt", forceResolver: false)
  """Timestamp of when this ent was last updated"""
  lastmodifiedat: Time! @goField(name: "LastModifiedAt", forceResolver: false)
  """Name of the tome"""
  name: String!
  """Information about the tome"""
  description: String!
  """JSON string describing what parameters are used with the tome"""
  parameters: String
  """A SHA3 digest of the eldritch field"""
  hash: String!
  """Eldritch script that will be executed when the tome is run"""
  eldritch: String!
  files: [File!]
}
"""Ordering options for Tome connections"""
input TomeOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tomes."""
  field: TomeOrderField!
}
"""Properties by which Tome connections can be ordered."""
enum TomeOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
TomeWhereInput is used for filtering Tome objects.
Input was generated by ent.
"""
input TomeWhereInput {
  not: TomeWhereInput
  and: [TomeWhereInput!]
  or: [TomeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """createdAt field predicates"""
  createdat: Time
  createdatNEQ: Time
  createdatIn: [Time!]
  createdatNotIn: [Time!]
  createdatGT: Time
  createdatGTE: Time
  createdatLT: Time
  createdatLTE: Time
  """lastModifiedAt field predicates"""
  lastmodifiedat: Time
  lastmodifiedatNEQ: Time
  lastmodifiedatIn: [Time!]
  lastmodifiedatNotIn: [Time!]
  lastmodifiedatGT: Time
  lastmodifiedatGTE: Time
  lastmodifiedatLT: Time
  lastmodifiedatLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionEqualFold: String
  descriptionContainsFold: String
  """parameters field predicates"""
  parameters: String
  parametersNEQ: String
  parametersIn: [String!]
  parametersNotIn: [String!]
  parametersGT: String
  parametersGTE: String
  parametersLT: String
  parametersLTE: String
  parametersContains: String
  parametersHasPrefix: String
  parametersHasSuffix: String
  parametersIsNil: Boolean
  parametersNotNil: Boolean
  parametersEqualFold: String
  parametersContainsFold: String
  """hash field predicates"""
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashEqualFold: String
  hashContainsFold: String
  """eldritch field predicates"""
  eldritch: String
  eldritchNEQ: String
  eldritchIn: [String!]
  eldritchNotIn: [String!]
  eldritchGT: String
  eldritchGTE: String
  eldritchLT: String
  eldritchLTE: String
  eldritchContains: String
  eldritchHasPrefix: String
  eldritchHasSuffix: String
  eldritchEqualFold: String
  eldritchContainsFold: String
  """files edge predicates"""
  hasFiles: Boolean
  hasFilesWith: [FileWhereInput!]
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  """The name displayed for the user"""
  name: String
  """URL to the user's profile photo."""
  photourl: String
  """True if the user is active and able to authenticate"""
  isactivated: Boolean
  """True if the user is an Admin"""
  isadmin: Boolean
}
type User implements Node {
  id: ID!
  """The name displayed for the user"""
  name: String!
  """URL to the user's profile photo."""
  photourl: String! @goField(name: "PhotoURL", forceResolver: false)
  """True if the user is active and able to authenticate"""
  isactivated: Boolean! @goField(name: "IsActivated", forceResolver: false)
  """True if the user is an Admin"""
  isadmin: Boolean! @goField(name: "IsAdmin", forceResolver: false)
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """Name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """PhotoURL field predicates"""
  photourl: String
  photourlNEQ: String
  photourlIn: [String!]
  photourlNotIn: [String!]
  photourlGT: String
  photourlGTE: String
  photourlLT: String
  photourlLTE: String
  photourlContains: String
  photourlHasPrefix: String
  photourlHasSuffix: String
  photourlEqualFold: String
  photourlContainsFold: String
  """IsActivated field predicates"""
  isactivated: Boolean
  isactivatedNEQ: Boolean
  """IsAdmin field predicates"""
  isadmin: Boolean
  isadminNEQ: Boolean
}
`, BuiltIn: false},
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
    ###
    # Job
    ###
    createJob(sessionIDs: [ID!]!, input: CreateJobInput!): Job

    ###
    # Task
    ###
    claimTasks(input: ClaimTasksInput!,): [Task!]!

    ### 
    # User
    ###  
    updateUser(userID: ID!, input: UpdateUserInput!): User
}`, BuiltIn: false},
	{Name: "../schema/inputs.graphql", Input: `input ClaimTasksInput {
  """The identity the session is authenticated as (e.g. 'root')"""
  principal: String!

  """The hostname of the system the session is running on."""
  hostname: String!

  """Unique identifier of the session, each running instance will be different."""
  sessionIdentifier: String!

  """Unique identifier of the underlying host system the session is running on."""
  hostIdentifier: String!

  """Name of the agent program the session is running as (e.g. 'imix')"""
  agentIdentifier: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
