// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

func (a *Asset) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := a.Edges.totalCount[0][alias]
	if nodes, err := a.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return a.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (a *Asset) Links(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*LinkOrder, where *LinkWhereInput,
) (*LinkConnection, error) {
	opts := []LinkPaginateOption{
		WithLinkOrder(orderBy),
		WithLinkFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := a.Edges.totalCount[1][alias]
	if nodes, err := a.NamedLinks(alias); err == nil || hasTotalCount {
		pager, err := newLinkPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &LinkConnection{Edges: []*LinkEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return a.QueryLinks().Paginate(ctx, after, first, before, last, opts...)
}

func (a *Asset) Creator(ctx context.Context) (*User, error) {
	result, err := a.Edges.CreatorOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryCreator().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Beacon) Host(ctx context.Context) (*Host, error) {
	result, err := b.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryHost().Only(ctx)
	}
	return result, err
}

func (b *Beacon) Process(ctx context.Context) (*HostProcess, error) {
	result, err := b.Edges.ProcessOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryProcess().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Beacon) Tasks(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TaskOrder, where *TaskWhereInput,
) (*TaskConnection, error) {
	opts := []TaskPaginateOption{
		WithTaskOrder(orderBy),
		WithTaskFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := b.Edges.totalCount[2][alias]
	if nodes, err := b.NamedTasks(alias); err == nil || hasTotalCount {
		pager, err := newTaskPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TaskConnection{Edges: []*TaskEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return b.QueryTasks().Paginate(ctx, after, first, before, last, opts...)
}

func (b *Beacon) Shells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := b.Edges.totalCount[3][alias]
	if nodes, err := b.NamedShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return b.QueryShells().Paginate(ctx, after, first, before, last, opts...)
}

func (bt *BuildTask) Builder(ctx context.Context) (*Builder, error) {
	result, err := bt.Edges.BuilderOrErr()
	if IsNotLoaded(err) {
		result, err = bt.QueryBuilder().Only(ctx)
	}
	return result, err
}

func (bt *BuildTask) Artifact(ctx context.Context) (*Asset, error) {
	result, err := bt.Edges.ArtifactOrErr()
	if IsNotLoaded(err) {
		result, err = bt.QueryArtifact().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Builder) BuildTasks(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*BuildTaskOrder, where *BuildTaskWhereInput,
) (*BuildTaskConnection, error) {
	opts := []BuildTaskPaginateOption{
		WithBuildTaskOrder(orderBy),
		WithBuildTaskFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := b.Edges.totalCount[0][alias]
	if nodes, err := b.NamedBuildTasks(alias); err == nil || hasTotalCount {
		pager, err := newBuildTaskPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &BuildTaskConnection{Edges: []*BuildTaskEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return b.QueryBuildTasks().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Tags(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TagOrder, where *TagWhereInput,
) (*TagConnection, error) {
	opts := []TagPaginateOption{
		WithTagOrder(orderBy),
		WithTagFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[0][alias]
	if nodes, err := h.NamedTags(alias); err == nil || hasTotalCount {
		pager, err := newTagPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TagConnection{Edges: []*TagEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryTags().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Beacons(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*BeaconOrder, where *BeaconWhereInput,
) (*BeaconConnection, error) {
	opts := []BeaconPaginateOption{
		WithBeaconOrder(orderBy),
		WithBeaconFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[1][alias]
	if nodes, err := h.NamedBeacons(alias); err == nil || hasTotalCount {
		pager, err := newBeaconPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &BeaconConnection{Edges: []*BeaconEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryBeacons().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Files(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostFileOrder, where *HostFileWhereInput,
) (*HostFileConnection, error) {
	opts := []HostFilePaginateOption{
		WithHostFileOrder(orderBy),
		WithHostFileFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[2][alias]
	if nodes, err := h.NamedFiles(alias); err == nil || hasTotalCount {
		pager, err := newHostFilePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostFileConnection{Edges: []*HostFileEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryFiles().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Processes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostProcessOrder, where *HostProcessWhereInput,
) (*HostProcessConnection, error) {
	opts := []HostProcessPaginateOption{
		WithHostProcessOrder(orderBy),
		WithHostProcessFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[3][alias]
	if nodes, err := h.NamedProcesses(alias); err == nil || hasTotalCount {
		pager, err := newHostProcessPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostProcessConnection{Edges: []*HostProcessEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryProcesses().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Credentials(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostCredentialOrder, where *HostCredentialWhereInput,
) (*HostCredentialConnection, error) {
	opts := []HostCredentialPaginateOption{
		WithHostCredentialOrder(orderBy),
		WithHostCredentialFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[4][alias]
	if nodes, err := h.NamedCredentials(alias); err == nil || hasTotalCount {
		pager, err := newHostCredentialPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostCredentialConnection{Edges: []*HostCredentialEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryCredentials().Paginate(ctx, after, first, before, last, opts...)
}

func (hc *HostCredential) Host(ctx context.Context) (*Host, error) {
	result, err := hc.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = hc.QueryHost().Only(ctx)
	}
	return result, err
}

func (hc *HostCredential) Task(ctx context.Context) (*Task, error) {
	result, err := hc.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = hc.QueryTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (hc *HostCredential) ShellTask(ctx context.Context) (*ShellTask, error) {
	result, err := hc.Edges.ShellTaskOrErr()
	if IsNotLoaded(err) {
		result, err = hc.QueryShellTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (hf *HostFile) Host(ctx context.Context) (*Host, error) {
	result, err := hf.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = hf.QueryHost().Only(ctx)
	}
	return result, err
}

func (hf *HostFile) Task(ctx context.Context) (*Task, error) {
	result, err := hf.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = hf.QueryTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (hf *HostFile) ShellTask(ctx context.Context) (*ShellTask, error) {
	result, err := hf.Edges.ShellTaskOrErr()
	if IsNotLoaded(err) {
		result, err = hf.QueryShellTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (hp *HostProcess) Host(ctx context.Context) (*Host, error) {
	result, err := hp.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = hp.QueryHost().Only(ctx)
	}
	return result, err
}

func (hp *HostProcess) Task(ctx context.Context) (*Task, error) {
	result, err := hp.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = hp.QueryTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (hp *HostProcess) ShellTask(ctx context.Context) (*ShellTask, error) {
	result, err := hp.Edges.ShellTaskOrErr()
	if IsNotLoaded(err) {
		result, err = hp.QueryShellTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (hp *HostProcess) Beacon(ctx context.Context) (result []*Beacon, err error) {
	if fc := graphql.GetFieldContext(ctx); fc != nil && fc.Field.Alias != "" {
		result, err = hp.NamedBeacon(graphql.GetFieldContext(ctx).Field.Alias)
	} else {
		result, err = hp.Edges.BeaconOrErr()
	}
	if IsNotLoaded(err) {
		result, err = hp.QueryBeacon().All(ctx)
	}
	return result, err
}

func (l *Link) Asset(ctx context.Context) (*Asset, error) {
	result, err := l.Edges.AssetOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryAsset().Only(ctx)
	}
	return result, err
}

func (l *Link) Creator(ctx context.Context) (*User, error) {
	result, err := l.Edges.CreatorOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryCreator().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (po *Portal) Task(ctx context.Context) (*Task, error) {
	result, err := po.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (po *Portal) ShellTask(ctx context.Context) (*ShellTask, error) {
	result, err := po.Edges.ShellTaskOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryShellTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (po *Portal) Beacon(ctx context.Context) (*Beacon, error) {
	result, err := po.Edges.BeaconOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryBeacon().Only(ctx)
	}
	return result, err
}

func (po *Portal) Owner(ctx context.Context) (*User, error) {
	result, err := po.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryOwner().Only(ctx)
	}
	return result, err
}

func (po *Portal) ActiveUsers(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*UserOrder, where *UserWhereInput,
) (*UserConnection, error) {
	opts := []UserPaginateOption{
		WithUserOrder(orderBy),
		WithUserFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := po.Edges.totalCount[4][alias]
	if nodes, err := po.NamedActiveUsers(alias); err == nil || hasTotalCount {
		pager, err := newUserPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &UserConnection{Edges: []*UserEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return po.QueryActiveUsers().Paginate(ctx, after, first, before, last, opts...)
}

func (q *Quest) Tome(ctx context.Context) (*Tome, error) {
	result, err := q.Edges.TomeOrErr()
	if IsNotLoaded(err) {
		result, err = q.QueryTome().Only(ctx)
	}
	return result, err
}

func (q *Quest) Bundle(ctx context.Context) (*Asset, error) {
	result, err := q.Edges.BundleOrErr()
	if IsNotLoaded(err) {
		result, err = q.QueryBundle().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (q *Quest) Tasks(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TaskOrder, where *TaskWhereInput,
) (*TaskConnection, error) {
	opts := []TaskPaginateOption{
		WithTaskOrder(orderBy),
		WithTaskFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := q.Edges.totalCount[2][alias]
	if nodes, err := q.NamedTasks(alias); err == nil || hasTotalCount {
		pager, err := newTaskPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TaskConnection{Edges: []*TaskEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return q.QueryTasks().Paginate(ctx, after, first, before, last, opts...)
}

func (q *Quest) Creator(ctx context.Context) (*User, error) {
	result, err := q.Edges.CreatorOrErr()
	if IsNotLoaded(err) {
		result, err = q.QueryCreator().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Repository) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := r.Edges.totalCount[0][alias]
	if nodes, err := r.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return r.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (r *Repository) Owner(ctx context.Context) (*User, error) {
	result, err := r.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryOwner().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (s *Shell) Task(ctx context.Context) (*Task, error) {
	result, err := s.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (s *Shell) Beacon(ctx context.Context) (*Beacon, error) {
	result, err := s.Edges.BeaconOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryBeacon().Only(ctx)
	}
	return result, err
}

func (s *Shell) Owner(ctx context.Context) (*User, error) {
	result, err := s.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryOwner().Only(ctx)
	}
	return result, err
}

func (s *Shell) Portals(ctx context.Context) (result []*Portal, err error) {
	if fc := graphql.GetFieldContext(ctx); fc != nil && fc.Field.Alias != "" {
		result, err = s.NamedPortals(graphql.GetFieldContext(ctx).Field.Alias)
	} else {
		result, err = s.Edges.PortalsOrErr()
	}
	if IsNotLoaded(err) {
		result, err = s.QueryPortals().All(ctx)
	}
	return result, err
}

func (s *Shell) ActiveUsers(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*UserOrder, where *UserWhereInput,
) (*UserConnection, error) {
	opts := []UserPaginateOption{
		WithUserOrder(orderBy),
		WithUserFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := s.Edges.totalCount[4][alias]
	if nodes, err := s.NamedActiveUsers(alias); err == nil || hasTotalCount {
		pager, err := newUserPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &UserConnection{Edges: []*UserEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return s.QueryActiveUsers().Paginate(ctx, after, first, before, last, opts...)
}

func (s *Shell) ShellTasks(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellTaskOrder, where *ShellTaskWhereInput,
) (*ShellTaskConnection, error) {
	opts := []ShellTaskPaginateOption{
		WithShellTaskOrder(orderBy),
		WithShellTaskFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := s.Edges.totalCount[5][alias]
	if nodes, err := s.NamedShellTasks(alias); err == nil || hasTotalCount {
		pager, err := newShellTaskPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellTaskConnection{Edges: []*ShellTaskEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return s.QueryShellTasks().Paginate(ctx, after, first, before, last, opts...)
}

func (st *ShellTask) Shell(ctx context.Context) (*Shell, error) {
	result, err := st.Edges.ShellOrErr()
	if IsNotLoaded(err) {
		result, err = st.QueryShell().Only(ctx)
	}
	return result, err
}

func (st *ShellTask) Creator(ctx context.Context) (*User, error) {
	result, err := st.Edges.CreatorOrErr()
	if IsNotLoaded(err) {
		result, err = st.QueryCreator().Only(ctx)
	}
	return result, err
}

func (st *ShellTask) ReportedCredentials(ctx context.Context) (result []*HostCredential, err error) {
	if fc := graphql.GetFieldContext(ctx); fc != nil && fc.Field.Alias != "" {
		result, err = st.NamedReportedCredentials(graphql.GetFieldContext(ctx).Field.Alias)
	} else {
		result, err = st.Edges.ReportedCredentialsOrErr()
	}
	if IsNotLoaded(err) {
		result, err = st.QueryReportedCredentials().All(ctx)
	}
	return result, err
}

func (st *ShellTask) ReportedFiles(ctx context.Context) (result []*HostFile, err error) {
	if fc := graphql.GetFieldContext(ctx); fc != nil && fc.Field.Alias != "" {
		result, err = st.NamedReportedFiles(graphql.GetFieldContext(ctx).Field.Alias)
	} else {
		result, err = st.Edges.ReportedFilesOrErr()
	}
	if IsNotLoaded(err) {
		result, err = st.QueryReportedFiles().All(ctx)
	}
	return result, err
}

func (st *ShellTask) ReportedProcesses(ctx context.Context) (result []*HostProcess, err error) {
	if fc := graphql.GetFieldContext(ctx); fc != nil && fc.Field.Alias != "" {
		result, err = st.NamedReportedProcesses(graphql.GetFieldContext(ctx).Field.Alias)
	} else {
		result, err = st.Edges.ReportedProcessesOrErr()
	}
	if IsNotLoaded(err) {
		result, err = st.QueryReportedProcesses().All(ctx)
	}
	return result, err
}

func (t *Tag) Hosts(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostOrder, where *HostWhereInput,
) (*HostConnection, error) {
	opts := []HostPaginateOption{
		WithHostOrder(orderBy),
		WithHostFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[0][alias]
	if nodes, err := t.NamedHosts(alias); err == nil || hasTotalCount {
		pager, err := newHostPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostConnection{Edges: []*HostEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryHosts().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Task) Quest(ctx context.Context) (*Quest, error) {
	result, err := t.Edges.QuestOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryQuest().Only(ctx)
	}
	return result, err
}

func (t *Task) Beacon(ctx context.Context) (*Beacon, error) {
	result, err := t.Edges.BeaconOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryBeacon().Only(ctx)
	}
	return result, err
}

func (t *Task) ReportedFiles(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostFileOrder, where *HostFileWhereInput,
) (*HostFileConnection, error) {
	opts := []HostFilePaginateOption{
		WithHostFileOrder(orderBy),
		WithHostFileFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[2][alias]
	if nodes, err := t.NamedReportedFiles(alias); err == nil || hasTotalCount {
		pager, err := newHostFilePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostFileConnection{Edges: []*HostFileEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryReportedFiles().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Task) ReportedProcesses(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostProcessOrder, where *HostProcessWhereInput,
) (*HostProcessConnection, error) {
	opts := []HostProcessPaginateOption{
		WithHostProcessOrder(orderBy),
		WithHostProcessFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[3][alias]
	if nodes, err := t.NamedReportedProcesses(alias); err == nil || hasTotalCount {
		pager, err := newHostProcessPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostProcessConnection{Edges: []*HostProcessEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryReportedProcesses().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Task) ReportedCredentials(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostCredentialOrder, where *HostCredentialWhereInput,
) (*HostCredentialConnection, error) {
	opts := []HostCredentialPaginateOption{
		WithHostCredentialOrder(orderBy),
		WithHostCredentialFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[4][alias]
	if nodes, err := t.NamedReportedCredentials(alias); err == nil || hasTotalCount {
		pager, err := newHostCredentialPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostCredentialConnection{Edges: []*HostCredentialEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryReportedCredentials().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Task) Shells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[5][alias]
	if nodes, err := t.NamedShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryShells().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Tome) Assets(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*AssetOrder, where *AssetWhereInput,
) (*AssetConnection, error) {
	opts := []AssetPaginateOption{
		WithAssetOrder(orderBy),
		WithAssetFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[0][alias]
	if nodes, err := t.NamedAssets(alias); err == nil || hasTotalCount {
		pager, err := newAssetPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &AssetConnection{Edges: []*AssetEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryAssets().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Tome) Uploader(ctx context.Context) (*User, error) {
	result, err := t.Edges.UploaderOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryUploader().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (t *Tome) Repository(ctx context.Context) (*Repository, error) {
	result, err := t.Edges.RepositoryOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryRepository().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (t *Tome) ScheduledHosts(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostOrder, where *HostWhereInput,
) (*HostConnection, error) {
	opts := []HostPaginateOption{
		WithHostOrder(orderBy),
		WithHostFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[3][alias]
	if nodes, err := t.NamedScheduledHosts(alias); err == nil || hasTotalCount {
		pager, err := newHostPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostConnection{Edges: []*HostEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryScheduledHosts().Paginate(ctx, after, first, before, last, opts...)
}

func (u *User) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := u.Edges.totalCount[0][alias]
	if nodes, err := u.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return u.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (u *User) ActiveShells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := u.Edges.totalCount[1][alias]
	if nodes, err := u.NamedActiveShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return u.QueryActiveShells().Paginate(ctx, after, first, before, last, opts...)
}
