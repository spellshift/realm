// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

func (b *Beacon) Host(ctx context.Context) (*Host, error) {
	result, err := b.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryHost().Only(ctx)
	}
	return result, err
}

func (b *Beacon) Tasks(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TaskOrder, where *TaskWhereInput,
) (*TaskConnection, error) {
	opts := []TaskPaginateOption{
		WithTaskOrder(orderBy),
		WithTaskFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := b.Edges.totalCount[1][alias]
	if nodes, err := b.NamedTasks(alias); err == nil || hasTotalCount {
		pager, err := newTaskPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TaskConnection{Edges: []*TaskEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return b.QueryTasks().Paginate(ctx, after, first, before, last, opts...)
}

func (b *Beacon) Shells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := b.Edges.totalCount[2][alias]
	if nodes, err := b.NamedShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return b.QueryShells().Paginate(ctx, after, first, before, last, opts...)
}

func (f *File) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := f.Edges.totalCount[0][alias]
	if nodes, err := f.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return f.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (f *File) Links(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*LinkOrder, where *LinkWhereInput,
) (*LinkConnection, error) {
	opts := []LinkPaginateOption{
		WithLinkOrder(orderBy),
		WithLinkFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := f.Edges.totalCount[1][alias]
	if nodes, err := f.NamedLinks(alias); err == nil || hasTotalCount {
		pager, err := newLinkPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &LinkConnection{Edges: []*LinkEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return f.QueryLinks().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Tags(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TagOrder, where *TagWhereInput,
) (*TagConnection, error) {
	opts := []TagPaginateOption{
		WithTagOrder(orderBy),
		WithTagFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[0][alias]
	if nodes, err := h.NamedTags(alias); err == nil || hasTotalCount {
		pager, err := newTagPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TagConnection{Edges: []*TagEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryTags().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Beacons(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*BeaconOrder, where *BeaconWhereInput,
) (*BeaconConnection, error) {
	opts := []BeaconPaginateOption{
		WithBeaconOrder(orderBy),
		WithBeaconFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[1][alias]
	if nodes, err := h.NamedBeacons(alias); err == nil || hasTotalCount {
		pager, err := newBeaconPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &BeaconConnection{Edges: []*BeaconEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryBeacons().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Files(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostFileOrder, where *HostFileWhereInput,
) (*HostFileConnection, error) {
	opts := []HostFilePaginateOption{
		WithHostFileOrder(orderBy),
		WithHostFileFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[2][alias]
	if nodes, err := h.NamedFiles(alias); err == nil || hasTotalCount {
		pager, err := newHostFilePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostFileConnection{Edges: []*HostFileEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryFiles().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Processes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostProcessOrder, where *HostProcessWhereInput,
) (*HostProcessConnection, error) {
	opts := []HostProcessPaginateOption{
		WithHostProcessOrder(orderBy),
		WithHostProcessFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[3][alias]
	if nodes, err := h.NamedProcesses(alias); err == nil || hasTotalCount {
		pager, err := newHostProcessPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostProcessConnection{Edges: []*HostProcessEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryProcesses().Paginate(ctx, after, first, before, last, opts...)
}

func (h *Host) Credentials(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostCredentialOrder, where *HostCredentialWhereInput,
) (*HostCredentialConnection, error) {
	opts := []HostCredentialPaginateOption{
		WithHostCredentialOrder(orderBy),
		WithHostCredentialFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := h.Edges.totalCount[4][alias]
	if nodes, err := h.NamedCredentials(alias); err == nil || hasTotalCount {
		pager, err := newHostCredentialPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostCredentialConnection{Edges: []*HostCredentialEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return h.QueryCredentials().Paginate(ctx, after, first, before, last, opts...)
}

func (hc *HostCredential) Host(ctx context.Context) (*Host, error) {
	result, err := hc.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = hc.QueryHost().Only(ctx)
	}
	return result, err
}

func (hc *HostCredential) Task(ctx context.Context) (*Task, error) {
	result, err := hc.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = hc.QueryTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (hf *HostFile) Host(ctx context.Context) (*Host, error) {
	result, err := hf.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = hf.QueryHost().Only(ctx)
	}
	return result, err
}

func (hf *HostFile) Task(ctx context.Context) (*Task, error) {
	result, err := hf.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = hf.QueryTask().Only(ctx)
	}
	return result, err
}

func (hp *HostProcess) Host(ctx context.Context) (*Host, error) {
	result, err := hp.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = hp.QueryHost().Only(ctx)
	}
	return result, err
}

func (hp *HostProcess) Task(ctx context.Context) (*Task, error) {
	result, err := hp.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = hp.QueryTask().Only(ctx)
	}
	return result, err
}

func (po *Portal) Task(ctx context.Context) (*Task, error) {
	result, err := po.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryTask().Only(ctx)
	}
	return result, err
}

func (po *Portal) Beacon(ctx context.Context) (*Beacon, error) {
	result, err := po.Edges.BeaconOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryBeacon().Only(ctx)
	}
	return result, err
}

func (po *Portal) Owner(ctx context.Context) (*User, error) {
	result, err := po.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryOwner().Only(ctx)
	}
	return result, err
}

func (po *Portal) ActiveUsers(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*UserOrder, where *UserWhereInput,
) (*UserConnection, error) {
	opts := []UserPaginateOption{
		WithUserOrder(orderBy),
		WithUserFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := po.Edges.totalCount[3][alias]
	if nodes, err := po.NamedActiveUsers(alias); err == nil || hasTotalCount {
		pager, err := newUserPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &UserConnection{Edges: []*UserEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return po.QueryActiveUsers().Paginate(ctx, after, first, before, last, opts...)
}

func (q *Quest) Tome(ctx context.Context) (*Tome, error) {
	result, err := q.Edges.TomeOrErr()
	if IsNotLoaded(err) {
		result, err = q.QueryTome().Only(ctx)
	}
	return result, err
}

func (q *Quest) Bundle(ctx context.Context) (*File, error) {
	result, err := q.Edges.BundleOrErr()
	if IsNotLoaded(err) {
		result, err = q.QueryBundle().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (q *Quest) Tasks(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TaskOrder, where *TaskWhereInput,
) (*TaskConnection, error) {
	opts := []TaskPaginateOption{
		WithTaskOrder(orderBy),
		WithTaskFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := q.Edges.totalCount[2][alias]
	if nodes, err := q.NamedTasks(alias); err == nil || hasTotalCount {
		pager, err := newTaskPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TaskConnection{Edges: []*TaskEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return q.QueryTasks().Paginate(ctx, after, first, before, last, opts...)
}

func (q *Quest) Creator(ctx context.Context) (*User, error) {
	result, err := q.Edges.CreatorOrErr()
	if IsNotLoaded(err) {
		result, err = q.QueryCreator().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Repository) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := r.Edges.totalCount[0][alias]
	if nodes, err := r.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return r.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (r *Repository) Owner(ctx context.Context) (*User, error) {
	result, err := r.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryOwner().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (s *Shell) Task(ctx context.Context) (*Task, error) {
	result, err := s.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryTask().Only(ctx)
	}
	return result, err
}

func (s *Shell) Beacon(ctx context.Context) (*Beacon, error) {
	result, err := s.Edges.BeaconOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryBeacon().Only(ctx)
	}
	return result, err
}

func (s *Shell) Owner(ctx context.Context) (*User, error) {
	result, err := s.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryOwner().Only(ctx)
	}
	return result, err
}

func (s *Shell) ActiveUsers(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*UserOrder, where *UserWhereInput,
) (*UserConnection, error) {
	opts := []UserPaginateOption{
		WithUserOrder(orderBy),
		WithUserFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := s.Edges.totalCount[3][alias]
	if nodes, err := s.NamedActiveUsers(alias); err == nil || hasTotalCount {
		pager, err := newUserPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &UserConnection{Edges: []*UserEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return s.QueryActiveUsers().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Tag) Hosts(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostOrder, where *HostWhereInput,
) (*HostConnection, error) {
	opts := []HostPaginateOption{
		WithHostOrder(orderBy),
		WithHostFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[0][alias]
	if nodes, err := t.NamedHosts(alias); err == nil || hasTotalCount {
		pager, err := newHostPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostConnection{Edges: []*HostEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryHosts().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Task) Quest(ctx context.Context) (*Quest, error) {
	result, err := t.Edges.QuestOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryQuest().Only(ctx)
	}
	return result, err
}

func (t *Task) Beacon(ctx context.Context) (*Beacon, error) {
	result, err := t.Edges.BeaconOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryBeacon().Only(ctx)
	}
	return result, err
}

func (t *Task) ReportedFiles(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostFileOrder, where *HostFileWhereInput,
) (*HostFileConnection, error) {
	opts := []HostFilePaginateOption{
		WithHostFileOrder(orderBy),
		WithHostFileFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[2][alias]
	if nodes, err := t.NamedReportedFiles(alias); err == nil || hasTotalCount {
		pager, err := newHostFilePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostFileConnection{Edges: []*HostFileEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryReportedFiles().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Task) ReportedProcesses(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostProcessOrder, where *HostProcessWhereInput,
) (*HostProcessConnection, error) {
	opts := []HostProcessPaginateOption{
		WithHostProcessOrder(orderBy),
		WithHostProcessFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[3][alias]
	if nodes, err := t.NamedReportedProcesses(alias); err == nil || hasTotalCount {
		pager, err := newHostProcessPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostProcessConnection{Edges: []*HostProcessEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryReportedProcesses().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Task) ReportedCredentials(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostCredentialOrder, where *HostCredentialWhereInput,
) (*HostCredentialConnection, error) {
	opts := []HostCredentialPaginateOption{
		WithHostCredentialOrder(orderBy),
		WithHostCredentialFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[4][alias]
	if nodes, err := t.NamedReportedCredentials(alias); err == nil || hasTotalCount {
		pager, err := newHostCredentialPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostCredentialConnection{Edges: []*HostCredentialEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryReportedCredentials().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Task) Shells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[5][alias]
	if nodes, err := t.NamedShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryShells().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Tome) Files(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*FileOrder, where *FileWhereInput,
) (*FileConnection, error) {
	opts := []FilePaginateOption{
		WithFileOrder(orderBy),
		WithFileFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := t.Edges.totalCount[0][alias]
	if nodes, err := t.NamedFiles(alias); err == nil || hasTotalCount {
		pager, err := newFilePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &FileConnection{Edges: []*FileEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return t.QueryFiles().Paginate(ctx, after, first, before, last, opts...)
}

func (t *Tome) Uploader(ctx context.Context) (*User, error) {
	result, err := t.Edges.UploaderOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryUploader().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (t *Tome) Repository(ctx context.Context) (*Repository, error) {
	result, err := t.Edges.RepositoryOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryRepository().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (u *User) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := u.Edges.totalCount[0][alias]
	if nodes, err := u.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return u.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (u *User) ActiveShells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := u.Edges.totalCount[1][alias]
	if nodes, err := u.NamedActiveShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return u.QueryActiveShells().Paginate(ctx, after, first, before, last, opts...)
}
