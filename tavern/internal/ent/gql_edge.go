// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

func (_m *Beacon) Host(ctx context.Context) (*Host, error) {
	result, err := _m.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryHost().Only(ctx)
	}
	return result, err
}

func (_m *Beacon) Tasks(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TaskOrder, where *TaskWhereInput,
) (*TaskConnection, error) {
	opts := []TaskPaginateOption{
		WithTaskOrder(orderBy),
		WithTaskFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[1][alias]
	if nodes, err := _m.NamedTasks(alias); err == nil || hasTotalCount {
		pager, err := newTaskPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TaskConnection{Edges: []*TaskEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryTasks().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Beacon) Shells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[2][alias]
	if nodes, err := _m.NamedShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryShells().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *File) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[0][alias]
	if nodes, err := _m.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Host) Tags(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TagOrder, where *TagWhereInput,
) (*TagConnection, error) {
	opts := []TagPaginateOption{
		WithTagOrder(orderBy),
		WithTagFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[0][alias]
	if nodes, err := _m.NamedTags(alias); err == nil || hasTotalCount {
		pager, err := newTagPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TagConnection{Edges: []*TagEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryTags().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Host) Beacons(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*BeaconOrder, where *BeaconWhereInput,
) (*BeaconConnection, error) {
	opts := []BeaconPaginateOption{
		WithBeaconOrder(orderBy),
		WithBeaconFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[1][alias]
	if nodes, err := _m.NamedBeacons(alias); err == nil || hasTotalCount {
		pager, err := newBeaconPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &BeaconConnection{Edges: []*BeaconEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryBeacons().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Host) Files(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostFileOrder, where *HostFileWhereInput,
) (*HostFileConnection, error) {
	opts := []HostFilePaginateOption{
		WithHostFileOrder(orderBy),
		WithHostFileFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[2][alias]
	if nodes, err := _m.NamedFiles(alias); err == nil || hasTotalCount {
		pager, err := newHostFilePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostFileConnection{Edges: []*HostFileEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryFiles().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Host) Processes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostProcessOrder, where *HostProcessWhereInput,
) (*HostProcessConnection, error) {
	opts := []HostProcessPaginateOption{
		WithHostProcessOrder(orderBy),
		WithHostProcessFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[3][alias]
	if nodes, err := _m.NamedProcesses(alias); err == nil || hasTotalCount {
		pager, err := newHostProcessPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostProcessConnection{Edges: []*HostProcessEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryProcesses().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Host) Credentials(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostCredentialOrder, where *HostCredentialWhereInput,
) (*HostCredentialConnection, error) {
	opts := []HostCredentialPaginateOption{
		WithHostCredentialOrder(orderBy),
		WithHostCredentialFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[4][alias]
	if nodes, err := _m.NamedCredentials(alias); err == nil || hasTotalCount {
		pager, err := newHostCredentialPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostCredentialConnection{Edges: []*HostCredentialEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryCredentials().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *HostCredential) Host(ctx context.Context) (*Host, error) {
	result, err := _m.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryHost().Only(ctx)
	}
	return result, err
}

func (_m *HostCredential) Task(ctx context.Context) (*Task, error) {
	result, err := _m.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryTask().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (_m *HostFile) Host(ctx context.Context) (*Host, error) {
	result, err := _m.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryHost().Only(ctx)
	}
	return result, err
}

func (_m *HostFile) Task(ctx context.Context) (*Task, error) {
	result, err := _m.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryTask().Only(ctx)
	}
	return result, err
}

func (_m *HostProcess) Host(ctx context.Context) (*Host, error) {
	result, err := _m.Edges.HostOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryHost().Only(ctx)
	}
	return result, err
}

func (_m *HostProcess) Task(ctx context.Context) (*Task, error) {
	result, err := _m.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryTask().Only(ctx)
	}
	return result, err
}

func (_m *Quest) Tome(ctx context.Context) (*Tome, error) {
	result, err := _m.Edges.TomeOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryTome().Only(ctx)
	}
	return result, err
}

func (_m *Quest) Bundle(ctx context.Context) (*File, error) {
	result, err := _m.Edges.BundleOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryBundle().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (_m *Quest) Tasks(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TaskOrder, where *TaskWhereInput,
) (*TaskConnection, error) {
	opts := []TaskPaginateOption{
		WithTaskOrder(orderBy),
		WithTaskFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[2][alias]
	if nodes, err := _m.NamedTasks(alias); err == nil || hasTotalCount {
		pager, err := newTaskPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TaskConnection{Edges: []*TaskEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryTasks().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Quest) Creator(ctx context.Context) (*User, error) {
	result, err := _m.Edges.CreatorOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryCreator().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (_m *Repository) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[0][alias]
	if nodes, err := _m.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Repository) Owner(ctx context.Context) (*User, error) {
	result, err := _m.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryOwner().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (_m *Shell) Task(ctx context.Context) (*Task, error) {
	result, err := _m.Edges.TaskOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryTask().Only(ctx)
	}
	return result, err
}

func (_m *Shell) Beacon(ctx context.Context) (*Beacon, error) {
	result, err := _m.Edges.BeaconOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryBeacon().Only(ctx)
	}
	return result, err
}

func (_m *Shell) Owner(ctx context.Context) (*User, error) {
	result, err := _m.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryOwner().Only(ctx)
	}
	return result, err
}

func (_m *Shell) ActiveUsers(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*UserOrder, where *UserWhereInput,
) (*UserConnection, error) {
	opts := []UserPaginateOption{
		WithUserOrder(orderBy),
		WithUserFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[3][alias]
	if nodes, err := _m.NamedActiveUsers(alias); err == nil || hasTotalCount {
		pager, err := newUserPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &UserConnection{Edges: []*UserEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryActiveUsers().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Tag) Hosts(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostOrder, where *HostWhereInput,
) (*HostConnection, error) {
	opts := []HostPaginateOption{
		WithHostOrder(orderBy),
		WithHostFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[0][alias]
	if nodes, err := _m.NamedHosts(alias); err == nil || hasTotalCount {
		pager, err := newHostPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostConnection{Edges: []*HostEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryHosts().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Task) Quest(ctx context.Context) (*Quest, error) {
	result, err := _m.Edges.QuestOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryQuest().Only(ctx)
	}
	return result, err
}

func (_m *Task) Beacon(ctx context.Context) (*Beacon, error) {
	result, err := _m.Edges.BeaconOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryBeacon().Only(ctx)
	}
	return result, err
}

func (_m *Task) ReportedFiles(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostFileOrder, where *HostFileWhereInput,
) (*HostFileConnection, error) {
	opts := []HostFilePaginateOption{
		WithHostFileOrder(orderBy),
		WithHostFileFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[2][alias]
	if nodes, err := _m.NamedReportedFiles(alias); err == nil || hasTotalCount {
		pager, err := newHostFilePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostFileConnection{Edges: []*HostFileEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryReportedFiles().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Task) ReportedProcesses(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostProcessOrder, where *HostProcessWhereInput,
) (*HostProcessConnection, error) {
	opts := []HostProcessPaginateOption{
		WithHostProcessOrder(orderBy),
		WithHostProcessFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[3][alias]
	if nodes, err := _m.NamedReportedProcesses(alias); err == nil || hasTotalCount {
		pager, err := newHostProcessPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostProcessConnection{Edges: []*HostProcessEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryReportedProcesses().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Task) ReportedCredentials(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*HostCredentialOrder, where *HostCredentialWhereInput,
) (*HostCredentialConnection, error) {
	opts := []HostCredentialPaginateOption{
		WithHostCredentialOrder(orderBy),
		WithHostCredentialFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[4][alias]
	if nodes, err := _m.NamedReportedCredentials(alias); err == nil || hasTotalCount {
		pager, err := newHostCredentialPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &HostCredentialConnection{Edges: []*HostCredentialEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryReportedCredentials().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Task) Shells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[5][alias]
	if nodes, err := _m.NamedShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryShells().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Tome) Files(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*FileOrder, where *FileWhereInput,
) (*FileConnection, error) {
	opts := []FilePaginateOption{
		WithFileOrder(orderBy),
		WithFileFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[0][alias]
	if nodes, err := _m.NamedFiles(alias); err == nil || hasTotalCount {
		pager, err := newFilePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &FileConnection{Edges: []*FileEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryFiles().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *Tome) Uploader(ctx context.Context) (*User, error) {
	result, err := _m.Edges.UploaderOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryUploader().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (_m *Tome) Repository(ctx context.Context) (*Repository, error) {
	result, err := _m.Edges.RepositoryOrErr()
	if IsNotLoaded(err) {
		result, err = _m.QueryRepository().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (_m *User) Tomes(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*TomeOrder, where *TomeWhereInput,
) (*TomeConnection, error) {
	opts := []TomePaginateOption{
		WithTomeOrder(orderBy),
		WithTomeFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[0][alias]
	if nodes, err := _m.NamedTomes(alias); err == nil || hasTotalCount {
		pager, err := newTomePager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &TomeConnection{Edges: []*TomeEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryTomes().Paginate(ctx, after, first, before, last, opts...)
}

func (_m *User) ActiveShells(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy []*ShellOrder, where *ShellWhereInput,
) (*ShellConnection, error) {
	opts := []ShellPaginateOption{
		WithShellOrder(orderBy),
		WithShellFilter(where.Filter),
	}
	alias := graphql.GetFieldContext(ctx).Field.Alias
	totalCount, hasTotalCount := _m.Edges.totalCount[1][alias]
	if nodes, err := _m.NamedActiveShells(alias); err == nil || hasTotalCount {
		pager, err := newShellPager(opts, last != nil)
		if err != nil {
			return nil, err
		}
		conn := &ShellConnection{Edges: []*ShellEdge{}, TotalCount: totalCount}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	return _m.QueryActiveShells().Paginate(ctx, after, first, before, last, opts...)
}
