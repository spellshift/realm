// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"realm.pub/tavern/internal/ent/beacon"
	"realm.pub/tavern/internal/ent/file"
	"realm.pub/tavern/internal/ent/host"
	"realm.pub/tavern/internal/ent/predicate"
	"realm.pub/tavern/internal/ent/process"
	"realm.pub/tavern/internal/ent/quest"
	"realm.pub/tavern/internal/ent/tag"
	"realm.pub/tavern/internal/ent/task"
	"realm.pub/tavern/internal/ent/tome"
	"realm.pub/tavern/internal/ent/user"
)

// BeaconWhereInput represents a where input for filtering Beacon queries.
type BeaconWhereInput struct {
	Predicates []predicate.Beacon  `json:"-"`
	Not        *BeaconWhereInput   `json:"not,omitempty"`
	Or         []*BeaconWhereInput `json:"or,omitempty"`
	And        []*BeaconWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "principal" field predicates.
	Principal             *string  `json:"principal,omitempty"`
	PrincipalNEQ          *string  `json:"principalNEQ,omitempty"`
	PrincipalIn           []string `json:"principalIn,omitempty"`
	PrincipalNotIn        []string `json:"principalNotIn,omitempty"`
	PrincipalGT           *string  `json:"principalGT,omitempty"`
	PrincipalGTE          *string  `json:"principalGTE,omitempty"`
	PrincipalLT           *string  `json:"principalLT,omitempty"`
	PrincipalLTE          *string  `json:"principalLTE,omitempty"`
	PrincipalContains     *string  `json:"principalContains,omitempty"`
	PrincipalHasPrefix    *string  `json:"principalHasPrefix,omitempty"`
	PrincipalHasSuffix    *string  `json:"principalHasSuffix,omitempty"`
	PrincipalIsNil        bool     `json:"principalIsNil,omitempty"`
	PrincipalNotNil       bool     `json:"principalNotNil,omitempty"`
	PrincipalEqualFold    *string  `json:"principalEqualFold,omitempty"`
	PrincipalContainsFold *string  `json:"principalContainsFold,omitempty"`

	// "identifier" field predicates.
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNEQ          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGT           *string  `json:"identifierGT,omitempty"`
	IdentifierGTE          *string  `json:"identifierGTE,omitempty"`
	IdentifierLT           *string  `json:"identifierLT,omitempty"`
	IdentifierLTE          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`

	// "agent_identifier" field predicates.
	AgentIdentifier             *string  `json:"agentIdentifier,omitempty"`
	AgentIdentifierNEQ          *string  `json:"agentIdentifierNEQ,omitempty"`
	AgentIdentifierIn           []string `json:"agentIdentifierIn,omitempty"`
	AgentIdentifierNotIn        []string `json:"agentIdentifierNotIn,omitempty"`
	AgentIdentifierGT           *string  `json:"agentIdentifierGT,omitempty"`
	AgentIdentifierGTE          *string  `json:"agentIdentifierGTE,omitempty"`
	AgentIdentifierLT           *string  `json:"agentIdentifierLT,omitempty"`
	AgentIdentifierLTE          *string  `json:"agentIdentifierLTE,omitempty"`
	AgentIdentifierContains     *string  `json:"agentIdentifierContains,omitempty"`
	AgentIdentifierHasPrefix    *string  `json:"agentIdentifierHasPrefix,omitempty"`
	AgentIdentifierHasSuffix    *string  `json:"agentIdentifierHasSuffix,omitempty"`
	AgentIdentifierIsNil        bool     `json:"agentIdentifierIsNil,omitempty"`
	AgentIdentifierNotNil       bool     `json:"agentIdentifierNotNil,omitempty"`
	AgentIdentifierEqualFold    *string  `json:"agentIdentifierEqualFold,omitempty"`
	AgentIdentifierContainsFold *string  `json:"agentIdentifierContainsFold,omitempty"`

	// "last_seen_at" field predicates.
	LastSeenAt       *time.Time  `json:"lastSeenAt,omitempty"`
	LastSeenAtNEQ    *time.Time  `json:"lastSeenAtNEQ,omitempty"`
	LastSeenAtIn     []time.Time `json:"lastSeenAtIn,omitempty"`
	LastSeenAtNotIn  []time.Time `json:"lastSeenAtNotIn,omitempty"`
	LastSeenAtGT     *time.Time  `json:"lastSeenAtGT,omitempty"`
	LastSeenAtGTE    *time.Time  `json:"lastSeenAtGTE,omitempty"`
	LastSeenAtLT     *time.Time  `json:"lastSeenAtLT,omitempty"`
	LastSeenAtLTE    *time.Time  `json:"lastSeenAtLTE,omitempty"`
	LastSeenAtIsNil  bool        `json:"lastSeenAtIsNil,omitempty"`
	LastSeenAtNotNil bool        `json:"lastSeenAtNotNil,omitempty"`

	// "interval" field predicates.
	Interval       *uint64  `json:"interval,omitempty"`
	IntervalNEQ    *uint64  `json:"intervalNEQ,omitempty"`
	IntervalIn     []uint64 `json:"intervalIn,omitempty"`
	IntervalNotIn  []uint64 `json:"intervalNotIn,omitempty"`
	IntervalGT     *uint64  `json:"intervalGT,omitempty"`
	IntervalGTE    *uint64  `json:"intervalGTE,omitempty"`
	IntervalLT     *uint64  `json:"intervalLT,omitempty"`
	IntervalLTE    *uint64  `json:"intervalLTE,omitempty"`
	IntervalIsNil  bool     `json:"intervalIsNil,omitempty"`
	IntervalNotNil bool     `json:"intervalNotNil,omitempty"`

	// "host" edge predicates.
	HasHost     *bool             `json:"hasHost,omitempty"`
	HasHostWith []*HostWhereInput `json:"hasHostWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BeaconWhereInput) AddPredicates(predicates ...predicate.Beacon) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BeaconWhereInput filter on the BeaconQuery builder.
func (i *BeaconWhereInput) Filter(q *BeaconQuery) (*BeaconQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBeaconWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBeaconWhereInput is returned in case the BeaconWhereInput is empty.
var ErrEmptyBeaconWhereInput = errors.New("ent: empty predicate BeaconWhereInput")

// P returns a predicate for filtering beacons.
// An error is returned if the input is empty or invalid.
func (i *BeaconWhereInput) P() (predicate.Beacon, error) {
	var predicates []predicate.Beacon
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, beacon.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Beacon, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, beacon.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Beacon, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, beacon.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, beacon.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, beacon.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, beacon.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, beacon.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, beacon.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, beacon.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, beacon.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, beacon.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, beacon.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, beacon.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, beacon.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, beacon.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, beacon.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, beacon.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, beacon.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, beacon.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, beacon.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, beacon.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, beacon.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, beacon.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, beacon.NameContainsFold(*i.NameContainsFold))
	}
	if i.Principal != nil {
		predicates = append(predicates, beacon.PrincipalEQ(*i.Principal))
	}
	if i.PrincipalNEQ != nil {
		predicates = append(predicates, beacon.PrincipalNEQ(*i.PrincipalNEQ))
	}
	if len(i.PrincipalIn) > 0 {
		predicates = append(predicates, beacon.PrincipalIn(i.PrincipalIn...))
	}
	if len(i.PrincipalNotIn) > 0 {
		predicates = append(predicates, beacon.PrincipalNotIn(i.PrincipalNotIn...))
	}
	if i.PrincipalGT != nil {
		predicates = append(predicates, beacon.PrincipalGT(*i.PrincipalGT))
	}
	if i.PrincipalGTE != nil {
		predicates = append(predicates, beacon.PrincipalGTE(*i.PrincipalGTE))
	}
	if i.PrincipalLT != nil {
		predicates = append(predicates, beacon.PrincipalLT(*i.PrincipalLT))
	}
	if i.PrincipalLTE != nil {
		predicates = append(predicates, beacon.PrincipalLTE(*i.PrincipalLTE))
	}
	if i.PrincipalContains != nil {
		predicates = append(predicates, beacon.PrincipalContains(*i.PrincipalContains))
	}
	if i.PrincipalHasPrefix != nil {
		predicates = append(predicates, beacon.PrincipalHasPrefix(*i.PrincipalHasPrefix))
	}
	if i.PrincipalHasSuffix != nil {
		predicates = append(predicates, beacon.PrincipalHasSuffix(*i.PrincipalHasSuffix))
	}
	if i.PrincipalIsNil {
		predicates = append(predicates, beacon.PrincipalIsNil())
	}
	if i.PrincipalNotNil {
		predicates = append(predicates, beacon.PrincipalNotNil())
	}
	if i.PrincipalEqualFold != nil {
		predicates = append(predicates, beacon.PrincipalEqualFold(*i.PrincipalEqualFold))
	}
	if i.PrincipalContainsFold != nil {
		predicates = append(predicates, beacon.PrincipalContainsFold(*i.PrincipalContainsFold))
	}
	if i.Identifier != nil {
		predicates = append(predicates, beacon.IdentifierEQ(*i.Identifier))
	}
	if i.IdentifierNEQ != nil {
		predicates = append(predicates, beacon.IdentifierNEQ(*i.IdentifierNEQ))
	}
	if len(i.IdentifierIn) > 0 {
		predicates = append(predicates, beacon.IdentifierIn(i.IdentifierIn...))
	}
	if len(i.IdentifierNotIn) > 0 {
		predicates = append(predicates, beacon.IdentifierNotIn(i.IdentifierNotIn...))
	}
	if i.IdentifierGT != nil {
		predicates = append(predicates, beacon.IdentifierGT(*i.IdentifierGT))
	}
	if i.IdentifierGTE != nil {
		predicates = append(predicates, beacon.IdentifierGTE(*i.IdentifierGTE))
	}
	if i.IdentifierLT != nil {
		predicates = append(predicates, beacon.IdentifierLT(*i.IdentifierLT))
	}
	if i.IdentifierLTE != nil {
		predicates = append(predicates, beacon.IdentifierLTE(*i.IdentifierLTE))
	}
	if i.IdentifierContains != nil {
		predicates = append(predicates, beacon.IdentifierContains(*i.IdentifierContains))
	}
	if i.IdentifierHasPrefix != nil {
		predicates = append(predicates, beacon.IdentifierHasPrefix(*i.IdentifierHasPrefix))
	}
	if i.IdentifierHasSuffix != nil {
		predicates = append(predicates, beacon.IdentifierHasSuffix(*i.IdentifierHasSuffix))
	}
	if i.IdentifierEqualFold != nil {
		predicates = append(predicates, beacon.IdentifierEqualFold(*i.IdentifierEqualFold))
	}
	if i.IdentifierContainsFold != nil {
		predicates = append(predicates, beacon.IdentifierContainsFold(*i.IdentifierContainsFold))
	}
	if i.AgentIdentifier != nil {
		predicates = append(predicates, beacon.AgentIdentifierEQ(*i.AgentIdentifier))
	}
	if i.AgentIdentifierNEQ != nil {
		predicates = append(predicates, beacon.AgentIdentifierNEQ(*i.AgentIdentifierNEQ))
	}
	if len(i.AgentIdentifierIn) > 0 {
		predicates = append(predicates, beacon.AgentIdentifierIn(i.AgentIdentifierIn...))
	}
	if len(i.AgentIdentifierNotIn) > 0 {
		predicates = append(predicates, beacon.AgentIdentifierNotIn(i.AgentIdentifierNotIn...))
	}
	if i.AgentIdentifierGT != nil {
		predicates = append(predicates, beacon.AgentIdentifierGT(*i.AgentIdentifierGT))
	}
	if i.AgentIdentifierGTE != nil {
		predicates = append(predicates, beacon.AgentIdentifierGTE(*i.AgentIdentifierGTE))
	}
	if i.AgentIdentifierLT != nil {
		predicates = append(predicates, beacon.AgentIdentifierLT(*i.AgentIdentifierLT))
	}
	if i.AgentIdentifierLTE != nil {
		predicates = append(predicates, beacon.AgentIdentifierLTE(*i.AgentIdentifierLTE))
	}
	if i.AgentIdentifierContains != nil {
		predicates = append(predicates, beacon.AgentIdentifierContains(*i.AgentIdentifierContains))
	}
	if i.AgentIdentifierHasPrefix != nil {
		predicates = append(predicates, beacon.AgentIdentifierHasPrefix(*i.AgentIdentifierHasPrefix))
	}
	if i.AgentIdentifierHasSuffix != nil {
		predicates = append(predicates, beacon.AgentIdentifierHasSuffix(*i.AgentIdentifierHasSuffix))
	}
	if i.AgentIdentifierIsNil {
		predicates = append(predicates, beacon.AgentIdentifierIsNil())
	}
	if i.AgentIdentifierNotNil {
		predicates = append(predicates, beacon.AgentIdentifierNotNil())
	}
	if i.AgentIdentifierEqualFold != nil {
		predicates = append(predicates, beacon.AgentIdentifierEqualFold(*i.AgentIdentifierEqualFold))
	}
	if i.AgentIdentifierContainsFold != nil {
		predicates = append(predicates, beacon.AgentIdentifierContainsFold(*i.AgentIdentifierContainsFold))
	}
	if i.LastSeenAt != nil {
		predicates = append(predicates, beacon.LastSeenAtEQ(*i.LastSeenAt))
	}
	if i.LastSeenAtNEQ != nil {
		predicates = append(predicates, beacon.LastSeenAtNEQ(*i.LastSeenAtNEQ))
	}
	if len(i.LastSeenAtIn) > 0 {
		predicates = append(predicates, beacon.LastSeenAtIn(i.LastSeenAtIn...))
	}
	if len(i.LastSeenAtNotIn) > 0 {
		predicates = append(predicates, beacon.LastSeenAtNotIn(i.LastSeenAtNotIn...))
	}
	if i.LastSeenAtGT != nil {
		predicates = append(predicates, beacon.LastSeenAtGT(*i.LastSeenAtGT))
	}
	if i.LastSeenAtGTE != nil {
		predicates = append(predicates, beacon.LastSeenAtGTE(*i.LastSeenAtGTE))
	}
	if i.LastSeenAtLT != nil {
		predicates = append(predicates, beacon.LastSeenAtLT(*i.LastSeenAtLT))
	}
	if i.LastSeenAtLTE != nil {
		predicates = append(predicates, beacon.LastSeenAtLTE(*i.LastSeenAtLTE))
	}
	if i.LastSeenAtIsNil {
		predicates = append(predicates, beacon.LastSeenAtIsNil())
	}
	if i.LastSeenAtNotNil {
		predicates = append(predicates, beacon.LastSeenAtNotNil())
	}
	if i.Interval != nil {
		predicates = append(predicates, beacon.IntervalEQ(*i.Interval))
	}
	if i.IntervalNEQ != nil {
		predicates = append(predicates, beacon.IntervalNEQ(*i.IntervalNEQ))
	}
	if len(i.IntervalIn) > 0 {
		predicates = append(predicates, beacon.IntervalIn(i.IntervalIn...))
	}
	if len(i.IntervalNotIn) > 0 {
		predicates = append(predicates, beacon.IntervalNotIn(i.IntervalNotIn...))
	}
	if i.IntervalGT != nil {
		predicates = append(predicates, beacon.IntervalGT(*i.IntervalGT))
	}
	if i.IntervalGTE != nil {
		predicates = append(predicates, beacon.IntervalGTE(*i.IntervalGTE))
	}
	if i.IntervalLT != nil {
		predicates = append(predicates, beacon.IntervalLT(*i.IntervalLT))
	}
	if i.IntervalLTE != nil {
		predicates = append(predicates, beacon.IntervalLTE(*i.IntervalLTE))
	}
	if i.IntervalIsNil {
		predicates = append(predicates, beacon.IntervalIsNil())
	}
	if i.IntervalNotNil {
		predicates = append(predicates, beacon.IntervalNotNil())
	}

	if i.HasHost != nil {
		p := beacon.HasHost()
		if !*i.HasHost {
			p = beacon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHostWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasHostWith))
		for _, w := range i.HasHostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, beacon.HasHostWith(with...))
	}
	if i.HasTasks != nil {
		p := beacon.HasTasks()
		if !*i.HasTasks {
			p = beacon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, beacon.HasTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBeaconWhereInput
	case 1:
		return predicates[0], nil
	default:
		return beacon.And(predicates...), nil
	}
}

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Predicates []predicate.File  `json:"-"`
	Not        *FileWhereInput   `json:"not,omitempty"`
	Or         []*FileWhereInput `json:"or,omitempty"`
	And        []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "size" field predicates.
	Size      *int  `json:"size,omitempty"`
	SizeNEQ   *int  `json:"sizeNEQ,omitempty"`
	SizeIn    []int `json:"sizeIn,omitempty"`
	SizeNotIn []int `json:"sizeNotIn,omitempty"`
	SizeGT    *int  `json:"sizeGT,omitempty"`
	SizeGTE   *int  `json:"sizeGTE,omitempty"`
	SizeLT    *int  `json:"sizeLT,omitempty"`
	SizeLTE   *int  `json:"sizeLTE,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "tomes" edge predicates.
	HasTomes     *bool             `json:"hasTomes,omitempty"`
	HasTomesWith []*TomeWhereInput `json:"hasTomesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileWhereInput) AddPredicates(predicates ...predicate.File) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileWhereInput is returned in case the FileWhereInput is empty.
var ErrEmptyFileWhereInput = errors.New("ent: empty predicate FileWhereInput")

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, file.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, file.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, file.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, file.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, file.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, file.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, file.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, file.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, file.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, file.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, file.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, file.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, file.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, file.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, file.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, file.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, file.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, file.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, file.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, file.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, file.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, file.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, file.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, file.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, file.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, file.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, file.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, file.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, file.NameContainsFold(*i.NameContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, file.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, file.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, file.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, file.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, file.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, file.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, file.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, file.SizeLTE(*i.SizeLTE))
	}
	if i.Hash != nil {
		predicates = append(predicates, file.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, file.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, file.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, file.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, file.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, file.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, file.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, file.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, file.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, file.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, file.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, file.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, file.HashContainsFold(*i.HashContainsFold))
	}

	if i.HasTomes != nil {
		p := file.HasTomes()
		if !*i.HasTomes {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTomesWith) > 0 {
		with := make([]predicate.Tome, 0, len(i.HasTomesWith))
		for _, w := range i.HasTomesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTomesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasTomesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// HostWhereInput represents a where input for filtering Host queries.
type HostWhereInput struct {
	Predicates []predicate.Host  `json:"-"`
	Not        *HostWhereInput   `json:"not,omitempty"`
	Or         []*HostWhereInput `json:"or,omitempty"`
	And        []*HostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "identifier" field predicates.
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNEQ          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGT           *string  `json:"identifierGT,omitempty"`
	IdentifierGTE          *string  `json:"identifierGTE,omitempty"`
	IdentifierLT           *string  `json:"identifierLT,omitempty"`
	IdentifierLTE          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "primary_ip" field predicates.
	PrimaryIP             *string  `json:"primaryIP,omitempty"`
	PrimaryIPNEQ          *string  `json:"primaryIPNEQ,omitempty"`
	PrimaryIPIn           []string `json:"primaryIPIn,omitempty"`
	PrimaryIPNotIn        []string `json:"primaryIPNotIn,omitempty"`
	PrimaryIPGT           *string  `json:"primaryIPGT,omitempty"`
	PrimaryIPGTE          *string  `json:"primaryIPGTE,omitempty"`
	PrimaryIPLT           *string  `json:"primaryIPLT,omitempty"`
	PrimaryIPLTE          *string  `json:"primaryIPLTE,omitempty"`
	PrimaryIPContains     *string  `json:"primaryIPContains,omitempty"`
	PrimaryIPHasPrefix    *string  `json:"primaryIPHasPrefix,omitempty"`
	PrimaryIPHasSuffix    *string  `json:"primaryIPHasSuffix,omitempty"`
	PrimaryIPIsNil        bool     `json:"primaryIPIsNil,omitempty"`
	PrimaryIPNotNil       bool     `json:"primaryIPNotNil,omitempty"`
	PrimaryIPEqualFold    *string  `json:"primaryIPEqualFold,omitempty"`
	PrimaryIPContainsFold *string  `json:"primaryIPContainsFold,omitempty"`

	// "platform" field predicates.
	Platform      *host.Platform  `json:"platform,omitempty"`
	PlatformNEQ   *host.Platform  `json:"platformNEQ,omitempty"`
	PlatformIn    []host.Platform `json:"platformIn,omitempty"`
	PlatformNotIn []host.Platform `json:"platformNotIn,omitempty"`

	// "last_seen_at" field predicates.
	LastSeenAt       *time.Time  `json:"lastSeenAt,omitempty"`
	LastSeenAtNEQ    *time.Time  `json:"lastSeenAtNEQ,omitempty"`
	LastSeenAtIn     []time.Time `json:"lastSeenAtIn,omitempty"`
	LastSeenAtNotIn  []time.Time `json:"lastSeenAtNotIn,omitempty"`
	LastSeenAtGT     *time.Time  `json:"lastSeenAtGT,omitempty"`
	LastSeenAtGTE    *time.Time  `json:"lastSeenAtGTE,omitempty"`
	LastSeenAtLT     *time.Time  `json:"lastSeenAtLT,omitempty"`
	LastSeenAtLTE    *time.Time  `json:"lastSeenAtLTE,omitempty"`
	LastSeenAtIsNil  bool        `json:"lastSeenAtIsNil,omitempty"`
	LastSeenAtNotNil bool        `json:"lastSeenAtNotNil,omitempty"`

	// "tags" edge predicates.
	HasTags     *bool            `json:"hasTags,omitempty"`
	HasTagsWith []*TagWhereInput `json:"hasTagsWith,omitempty"`

	// "beacons" edge predicates.
	HasBeacons     *bool               `json:"hasBeacons,omitempty"`
	HasBeaconsWith []*BeaconWhereInput `json:"hasBeaconsWith,omitempty"`

	// "processes" edge predicates.
	HasProcesses     *bool                `json:"hasProcesses,omitempty"`
	HasProcessesWith []*ProcessWhereInput `json:"hasProcessesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HostWhereInput) AddPredicates(predicates ...predicate.Host) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HostWhereInput filter on the HostQuery builder.
func (i *HostWhereInput) Filter(q *HostQuery) (*HostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHostWhereInput is returned in case the HostWhereInput is empty.
var ErrEmptyHostWhereInput = errors.New("ent: empty predicate HostWhereInput")

// P returns a predicate for filtering hosts.
// An error is returned if the input is empty or invalid.
func (i *HostWhereInput) P() (predicate.Host, error) {
	var predicates []predicate.Host
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, host.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Host, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, host.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Host, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, host.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, host.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, host.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, host.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, host.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, host.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, host.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, host.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, host.IDLTE(*i.IDLTE))
	}
	if i.Identifier != nil {
		predicates = append(predicates, host.IdentifierEQ(*i.Identifier))
	}
	if i.IdentifierNEQ != nil {
		predicates = append(predicates, host.IdentifierNEQ(*i.IdentifierNEQ))
	}
	if len(i.IdentifierIn) > 0 {
		predicates = append(predicates, host.IdentifierIn(i.IdentifierIn...))
	}
	if len(i.IdentifierNotIn) > 0 {
		predicates = append(predicates, host.IdentifierNotIn(i.IdentifierNotIn...))
	}
	if i.IdentifierGT != nil {
		predicates = append(predicates, host.IdentifierGT(*i.IdentifierGT))
	}
	if i.IdentifierGTE != nil {
		predicates = append(predicates, host.IdentifierGTE(*i.IdentifierGTE))
	}
	if i.IdentifierLT != nil {
		predicates = append(predicates, host.IdentifierLT(*i.IdentifierLT))
	}
	if i.IdentifierLTE != nil {
		predicates = append(predicates, host.IdentifierLTE(*i.IdentifierLTE))
	}
	if i.IdentifierContains != nil {
		predicates = append(predicates, host.IdentifierContains(*i.IdentifierContains))
	}
	if i.IdentifierHasPrefix != nil {
		predicates = append(predicates, host.IdentifierHasPrefix(*i.IdentifierHasPrefix))
	}
	if i.IdentifierHasSuffix != nil {
		predicates = append(predicates, host.IdentifierHasSuffix(*i.IdentifierHasSuffix))
	}
	if i.IdentifierEqualFold != nil {
		predicates = append(predicates, host.IdentifierEqualFold(*i.IdentifierEqualFold))
	}
	if i.IdentifierContainsFold != nil {
		predicates = append(predicates, host.IdentifierContainsFold(*i.IdentifierContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, host.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, host.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, host.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, host.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, host.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, host.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, host.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, host.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, host.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, host.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, host.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, host.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, host.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, host.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, host.NameContainsFold(*i.NameContainsFold))
	}
	if i.PrimaryIP != nil {
		predicates = append(predicates, host.PrimaryIPEQ(*i.PrimaryIP))
	}
	if i.PrimaryIPNEQ != nil {
		predicates = append(predicates, host.PrimaryIPNEQ(*i.PrimaryIPNEQ))
	}
	if len(i.PrimaryIPIn) > 0 {
		predicates = append(predicates, host.PrimaryIPIn(i.PrimaryIPIn...))
	}
	if len(i.PrimaryIPNotIn) > 0 {
		predicates = append(predicates, host.PrimaryIPNotIn(i.PrimaryIPNotIn...))
	}
	if i.PrimaryIPGT != nil {
		predicates = append(predicates, host.PrimaryIPGT(*i.PrimaryIPGT))
	}
	if i.PrimaryIPGTE != nil {
		predicates = append(predicates, host.PrimaryIPGTE(*i.PrimaryIPGTE))
	}
	if i.PrimaryIPLT != nil {
		predicates = append(predicates, host.PrimaryIPLT(*i.PrimaryIPLT))
	}
	if i.PrimaryIPLTE != nil {
		predicates = append(predicates, host.PrimaryIPLTE(*i.PrimaryIPLTE))
	}
	if i.PrimaryIPContains != nil {
		predicates = append(predicates, host.PrimaryIPContains(*i.PrimaryIPContains))
	}
	if i.PrimaryIPHasPrefix != nil {
		predicates = append(predicates, host.PrimaryIPHasPrefix(*i.PrimaryIPHasPrefix))
	}
	if i.PrimaryIPHasSuffix != nil {
		predicates = append(predicates, host.PrimaryIPHasSuffix(*i.PrimaryIPHasSuffix))
	}
	if i.PrimaryIPIsNil {
		predicates = append(predicates, host.PrimaryIPIsNil())
	}
	if i.PrimaryIPNotNil {
		predicates = append(predicates, host.PrimaryIPNotNil())
	}
	if i.PrimaryIPEqualFold != nil {
		predicates = append(predicates, host.PrimaryIPEqualFold(*i.PrimaryIPEqualFold))
	}
	if i.PrimaryIPContainsFold != nil {
		predicates = append(predicates, host.PrimaryIPContainsFold(*i.PrimaryIPContainsFold))
	}
	if i.Platform != nil {
		predicates = append(predicates, host.PlatformEQ(*i.Platform))
	}
	if i.PlatformNEQ != nil {
		predicates = append(predicates, host.PlatformNEQ(*i.PlatformNEQ))
	}
	if len(i.PlatformIn) > 0 {
		predicates = append(predicates, host.PlatformIn(i.PlatformIn...))
	}
	if len(i.PlatformNotIn) > 0 {
		predicates = append(predicates, host.PlatformNotIn(i.PlatformNotIn...))
	}
	if i.LastSeenAt != nil {
		predicates = append(predicates, host.LastSeenAtEQ(*i.LastSeenAt))
	}
	if i.LastSeenAtNEQ != nil {
		predicates = append(predicates, host.LastSeenAtNEQ(*i.LastSeenAtNEQ))
	}
	if len(i.LastSeenAtIn) > 0 {
		predicates = append(predicates, host.LastSeenAtIn(i.LastSeenAtIn...))
	}
	if len(i.LastSeenAtNotIn) > 0 {
		predicates = append(predicates, host.LastSeenAtNotIn(i.LastSeenAtNotIn...))
	}
	if i.LastSeenAtGT != nil {
		predicates = append(predicates, host.LastSeenAtGT(*i.LastSeenAtGT))
	}
	if i.LastSeenAtGTE != nil {
		predicates = append(predicates, host.LastSeenAtGTE(*i.LastSeenAtGTE))
	}
	if i.LastSeenAtLT != nil {
		predicates = append(predicates, host.LastSeenAtLT(*i.LastSeenAtLT))
	}
	if i.LastSeenAtLTE != nil {
		predicates = append(predicates, host.LastSeenAtLTE(*i.LastSeenAtLTE))
	}
	if i.LastSeenAtIsNil {
		predicates = append(predicates, host.LastSeenAtIsNil())
	}
	if i.LastSeenAtNotNil {
		predicates = append(predicates, host.LastSeenAtNotNil())
	}

	if i.HasTags != nil {
		p := host.HasTags()
		if !*i.HasTags {
			p = host.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTagsWith) > 0 {
		with := make([]predicate.Tag, 0, len(i.HasTagsWith))
		for _, w := range i.HasTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, host.HasTagsWith(with...))
	}
	if i.HasBeacons != nil {
		p := host.HasBeacons()
		if !*i.HasBeacons {
			p = host.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeaconsWith) > 0 {
		with := make([]predicate.Beacon, 0, len(i.HasBeaconsWith))
		for _, w := range i.HasBeaconsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBeaconsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, host.HasBeaconsWith(with...))
	}
	if i.HasProcesses != nil {
		p := host.HasProcesses()
		if !*i.HasProcesses {
			p = host.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcessesWith) > 0 {
		with := make([]predicate.Process, 0, len(i.HasProcessesWith))
		for _, w := range i.HasProcessesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcessesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, host.HasProcessesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return host.And(predicates...), nil
	}
}

// ProcessWhereInput represents a where input for filtering Process queries.
type ProcessWhereInput struct {
	Predicates []predicate.Process  `json:"-"`
	Not        *ProcessWhereInput   `json:"not,omitempty"`
	Or         []*ProcessWhereInput `json:"or,omitempty"`
	And        []*ProcessWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "pid" field predicates.
	Pid      *uint64  `json:"pid,omitempty"`
	PidNEQ   *uint64  `json:"pidNEQ,omitempty"`
	PidIn    []uint64 `json:"pidIn,omitempty"`
	PidNotIn []uint64 `json:"pidNotIn,omitempty"`
	PidGT    *uint64  `json:"pidGT,omitempty"`
	PidGTE   *uint64  `json:"pidGTE,omitempty"`
	PidLT    *uint64  `json:"pidLT,omitempty"`
	PidLTE   *uint64  `json:"pidLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "principal" field predicates.
	Principal             *string  `json:"principal,omitempty"`
	PrincipalNEQ          *string  `json:"principalNEQ,omitempty"`
	PrincipalIn           []string `json:"principalIn,omitempty"`
	PrincipalNotIn        []string `json:"principalNotIn,omitempty"`
	PrincipalGT           *string  `json:"principalGT,omitempty"`
	PrincipalGTE          *string  `json:"principalGTE,omitempty"`
	PrincipalLT           *string  `json:"principalLT,omitempty"`
	PrincipalLTE          *string  `json:"principalLTE,omitempty"`
	PrincipalContains     *string  `json:"principalContains,omitempty"`
	PrincipalHasPrefix    *string  `json:"principalHasPrefix,omitempty"`
	PrincipalHasSuffix    *string  `json:"principalHasSuffix,omitempty"`
	PrincipalEqualFold    *string  `json:"principalEqualFold,omitempty"`
	PrincipalContainsFold *string  `json:"principalContainsFold,omitempty"`

	// "host" edge predicates.
	HasHost     *bool             `json:"hasHost,omitempty"`
	HasHostWith []*HostWhereInput `json:"hasHostWith,omitempty"`

	// "task" edge predicates.
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProcessWhereInput) AddPredicates(predicates ...predicate.Process) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProcessWhereInput filter on the ProcessQuery builder.
func (i *ProcessWhereInput) Filter(q *ProcessQuery) (*ProcessQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProcessWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProcessWhereInput is returned in case the ProcessWhereInput is empty.
var ErrEmptyProcessWhereInput = errors.New("ent: empty predicate ProcessWhereInput")

// P returns a predicate for filtering processes.
// An error is returned if the input is empty or invalid.
func (i *ProcessWhereInput) P() (predicate.Process, error) {
	var predicates []predicate.Process
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, process.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Process, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, process.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Process, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, process.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, process.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, process.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, process.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, process.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, process.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, process.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, process.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, process.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, process.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, process.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, process.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, process.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, process.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, process.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, process.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, process.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, process.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, process.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, process.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, process.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, process.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, process.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, process.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, process.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Pid != nil {
		predicates = append(predicates, process.PidEQ(*i.Pid))
	}
	if i.PidNEQ != nil {
		predicates = append(predicates, process.PidNEQ(*i.PidNEQ))
	}
	if len(i.PidIn) > 0 {
		predicates = append(predicates, process.PidIn(i.PidIn...))
	}
	if len(i.PidNotIn) > 0 {
		predicates = append(predicates, process.PidNotIn(i.PidNotIn...))
	}
	if i.PidGT != nil {
		predicates = append(predicates, process.PidGT(*i.PidGT))
	}
	if i.PidGTE != nil {
		predicates = append(predicates, process.PidGTE(*i.PidGTE))
	}
	if i.PidLT != nil {
		predicates = append(predicates, process.PidLT(*i.PidLT))
	}
	if i.PidLTE != nil {
		predicates = append(predicates, process.PidLTE(*i.PidLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, process.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, process.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, process.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, process.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, process.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, process.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, process.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, process.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, process.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, process.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, process.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, process.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, process.NameContainsFold(*i.NameContainsFold))
	}
	if i.Principal != nil {
		predicates = append(predicates, process.PrincipalEQ(*i.Principal))
	}
	if i.PrincipalNEQ != nil {
		predicates = append(predicates, process.PrincipalNEQ(*i.PrincipalNEQ))
	}
	if len(i.PrincipalIn) > 0 {
		predicates = append(predicates, process.PrincipalIn(i.PrincipalIn...))
	}
	if len(i.PrincipalNotIn) > 0 {
		predicates = append(predicates, process.PrincipalNotIn(i.PrincipalNotIn...))
	}
	if i.PrincipalGT != nil {
		predicates = append(predicates, process.PrincipalGT(*i.PrincipalGT))
	}
	if i.PrincipalGTE != nil {
		predicates = append(predicates, process.PrincipalGTE(*i.PrincipalGTE))
	}
	if i.PrincipalLT != nil {
		predicates = append(predicates, process.PrincipalLT(*i.PrincipalLT))
	}
	if i.PrincipalLTE != nil {
		predicates = append(predicates, process.PrincipalLTE(*i.PrincipalLTE))
	}
	if i.PrincipalContains != nil {
		predicates = append(predicates, process.PrincipalContains(*i.PrincipalContains))
	}
	if i.PrincipalHasPrefix != nil {
		predicates = append(predicates, process.PrincipalHasPrefix(*i.PrincipalHasPrefix))
	}
	if i.PrincipalHasSuffix != nil {
		predicates = append(predicates, process.PrincipalHasSuffix(*i.PrincipalHasSuffix))
	}
	if i.PrincipalEqualFold != nil {
		predicates = append(predicates, process.PrincipalEqualFold(*i.PrincipalEqualFold))
	}
	if i.PrincipalContainsFold != nil {
		predicates = append(predicates, process.PrincipalContainsFold(*i.PrincipalContainsFold))
	}

	if i.HasHost != nil {
		p := process.HasHost()
		if !*i.HasHost {
			p = process.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHostWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasHostWith))
		for _, w := range i.HasHostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, process.HasHostWith(with...))
	}
	if i.HasTask != nil {
		p := process.HasTask()
		if !*i.HasTask {
			p = process.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, process.HasTaskWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProcessWhereInput
	case 1:
		return predicates[0], nil
	default:
		return process.And(predicates...), nil
	}
}

// QuestWhereInput represents a where input for filtering Quest queries.
type QuestWhereInput struct {
	Predicates []predicate.Quest  `json:"-"`
	Not        *QuestWhereInput   `json:"not,omitempty"`
	Or         []*QuestWhereInput `json:"or,omitempty"`
	And        []*QuestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "parameters" field predicates.
	Parameters             *string  `json:"parameters,omitempty"`
	ParametersNEQ          *string  `json:"parametersNEQ,omitempty"`
	ParametersIn           []string `json:"parametersIn,omitempty"`
	ParametersNotIn        []string `json:"parametersNotIn,omitempty"`
	ParametersGT           *string  `json:"parametersGT,omitempty"`
	ParametersGTE          *string  `json:"parametersGTE,omitempty"`
	ParametersLT           *string  `json:"parametersLT,omitempty"`
	ParametersLTE          *string  `json:"parametersLTE,omitempty"`
	ParametersContains     *string  `json:"parametersContains,omitempty"`
	ParametersHasPrefix    *string  `json:"parametersHasPrefix,omitempty"`
	ParametersHasSuffix    *string  `json:"parametersHasSuffix,omitempty"`
	ParametersIsNil        bool     `json:"parametersIsNil,omitempty"`
	ParametersNotNil       bool     `json:"parametersNotNil,omitempty"`
	ParametersEqualFold    *string  `json:"parametersEqualFold,omitempty"`
	ParametersContainsFold *string  `json:"parametersContainsFold,omitempty"`

	// "tome" edge predicates.
	HasTome     *bool             `json:"hasTome,omitempty"`
	HasTomeWith []*TomeWhereInput `json:"hasTomeWith,omitempty"`

	// "bundle" edge predicates.
	HasBundle     *bool             `json:"hasBundle,omitempty"`
	HasBundleWith []*FileWhereInput `json:"hasBundleWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *QuestWhereInput) AddPredicates(predicates ...predicate.Quest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the QuestWhereInput filter on the QuestQuery builder.
func (i *QuestWhereInput) Filter(q *QuestQuery) (*QuestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyQuestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyQuestWhereInput is returned in case the QuestWhereInput is empty.
var ErrEmptyQuestWhereInput = errors.New("ent: empty predicate QuestWhereInput")

// P returns a predicate for filtering quests.
// An error is returned if the input is empty or invalid.
func (i *QuestWhereInput) P() (predicate.Quest, error) {
	var predicates []predicate.Quest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, quest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Quest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, quest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Quest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, quest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, quest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, quest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, quest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, quest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, quest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, quest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, quest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, quest.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, quest.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, quest.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, quest.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, quest.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, quest.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, quest.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, quest.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, quest.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, quest.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, quest.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, quest.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, quest.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, quest.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, quest.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, quest.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, quest.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, quest.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, quest.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, quest.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, quest.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, quest.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, quest.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, quest.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, quest.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, quest.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, quest.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, quest.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, quest.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, quest.NameContainsFold(*i.NameContainsFold))
	}
	if i.Parameters != nil {
		predicates = append(predicates, quest.ParametersEQ(*i.Parameters))
	}
	if i.ParametersNEQ != nil {
		predicates = append(predicates, quest.ParametersNEQ(*i.ParametersNEQ))
	}
	if len(i.ParametersIn) > 0 {
		predicates = append(predicates, quest.ParametersIn(i.ParametersIn...))
	}
	if len(i.ParametersNotIn) > 0 {
		predicates = append(predicates, quest.ParametersNotIn(i.ParametersNotIn...))
	}
	if i.ParametersGT != nil {
		predicates = append(predicates, quest.ParametersGT(*i.ParametersGT))
	}
	if i.ParametersGTE != nil {
		predicates = append(predicates, quest.ParametersGTE(*i.ParametersGTE))
	}
	if i.ParametersLT != nil {
		predicates = append(predicates, quest.ParametersLT(*i.ParametersLT))
	}
	if i.ParametersLTE != nil {
		predicates = append(predicates, quest.ParametersLTE(*i.ParametersLTE))
	}
	if i.ParametersContains != nil {
		predicates = append(predicates, quest.ParametersContains(*i.ParametersContains))
	}
	if i.ParametersHasPrefix != nil {
		predicates = append(predicates, quest.ParametersHasPrefix(*i.ParametersHasPrefix))
	}
	if i.ParametersHasSuffix != nil {
		predicates = append(predicates, quest.ParametersHasSuffix(*i.ParametersHasSuffix))
	}
	if i.ParametersIsNil {
		predicates = append(predicates, quest.ParametersIsNil())
	}
	if i.ParametersNotNil {
		predicates = append(predicates, quest.ParametersNotNil())
	}
	if i.ParametersEqualFold != nil {
		predicates = append(predicates, quest.ParametersEqualFold(*i.ParametersEqualFold))
	}
	if i.ParametersContainsFold != nil {
		predicates = append(predicates, quest.ParametersContainsFold(*i.ParametersContainsFold))
	}

	if i.HasTome != nil {
		p := quest.HasTome()
		if !*i.HasTome {
			p = quest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTomeWith) > 0 {
		with := make([]predicate.Tome, 0, len(i.HasTomeWith))
		for _, w := range i.HasTomeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTomeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, quest.HasTomeWith(with...))
	}
	if i.HasBundle != nil {
		p := quest.HasBundle()
		if !*i.HasBundle {
			p = quest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBundleWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasBundleWith))
		for _, w := range i.HasBundleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBundleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, quest.HasBundleWith(with...))
	}
	if i.HasTasks != nil {
		p := quest.HasTasks()
		if !*i.HasTasks {
			p = quest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, quest.HasTasksWith(with...))
	}
	if i.HasCreator != nil {
		p := quest.HasCreator()
		if !*i.HasCreator {
			p = quest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, quest.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyQuestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return quest.And(predicates...), nil
	}
}

// TagWhereInput represents a where input for filtering Tag queries.
type TagWhereInput struct {
	Predicates []predicate.Tag  `json:"-"`
	Not        *TagWhereInput   `json:"not,omitempty"`
	Or         []*TagWhereInput `json:"or,omitempty"`
	And        []*TagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *tag.Kind  `json:"kind,omitempty"`
	KindNEQ   *tag.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []tag.Kind `json:"kindIn,omitempty"`
	KindNotIn []tag.Kind `json:"kindNotIn,omitempty"`

	// "hosts" edge predicates.
	HasHosts     *bool             `json:"hasHosts,omitempty"`
	HasHostsWith []*HostWhereInput `json:"hasHostsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TagWhereInput) AddPredicates(predicates ...predicate.Tag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TagWhereInput filter on the TagQuery builder.
func (i *TagWhereInput) Filter(q *TagQuery) (*TagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTagWhereInput is returned in case the TagWhereInput is empty.
var ErrEmptyTagWhereInput = errors.New("ent: empty predicate TagWhereInput")

// P returns a predicate for filtering tags.
// An error is returned if the input is empty or invalid.
func (i *TagWhereInput) P() (predicate.Tag, error) {
	var predicates []predicate.Tag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tag.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tag.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, tag.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, tag.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, tag.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, tag.KindNotIn(i.KindNotIn...))
	}

	if i.HasHosts != nil {
		p := tag.HasHosts()
		if !*i.HasHosts {
			p = tag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHostsWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasHostsWith))
		for _, w := range i.HasHostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tag.HasHostsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tag.And(predicates...), nil
	}
}

// TaskWhereInput represents a where input for filtering Task queries.
type TaskWhereInput struct {
	Predicates []predicate.Task  `json:"-"`
	Not        *TaskWhereInput   `json:"not,omitempty"`
	Or         []*TaskWhereInput `json:"or,omitempty"`
	And        []*TaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "claimed_at" field predicates.
	ClaimedAt       *time.Time  `json:"claimedAt,omitempty"`
	ClaimedAtNEQ    *time.Time  `json:"claimedAtNEQ,omitempty"`
	ClaimedAtIn     []time.Time `json:"claimedAtIn,omitempty"`
	ClaimedAtNotIn  []time.Time `json:"claimedAtNotIn,omitempty"`
	ClaimedAtGT     *time.Time  `json:"claimedAtGT,omitempty"`
	ClaimedAtGTE    *time.Time  `json:"claimedAtGTE,omitempty"`
	ClaimedAtLT     *time.Time  `json:"claimedAtLT,omitempty"`
	ClaimedAtLTE    *time.Time  `json:"claimedAtLTE,omitempty"`
	ClaimedAtIsNil  bool        `json:"claimedAtIsNil,omitempty"`
	ClaimedAtNotNil bool        `json:"claimedAtNotNil,omitempty"`

	// "exec_started_at" field predicates.
	ExecStartedAt       *time.Time  `json:"execStartedAt,omitempty"`
	ExecStartedAtNEQ    *time.Time  `json:"execStartedAtNEQ,omitempty"`
	ExecStartedAtIn     []time.Time `json:"execStartedAtIn,omitempty"`
	ExecStartedAtNotIn  []time.Time `json:"execStartedAtNotIn,omitempty"`
	ExecStartedAtGT     *time.Time  `json:"execStartedAtGT,omitempty"`
	ExecStartedAtGTE    *time.Time  `json:"execStartedAtGTE,omitempty"`
	ExecStartedAtLT     *time.Time  `json:"execStartedAtLT,omitempty"`
	ExecStartedAtLTE    *time.Time  `json:"execStartedAtLTE,omitempty"`
	ExecStartedAtIsNil  bool        `json:"execStartedAtIsNil,omitempty"`
	ExecStartedAtNotNil bool        `json:"execStartedAtNotNil,omitempty"`

	// "exec_finished_at" field predicates.
	ExecFinishedAt       *time.Time  `json:"execFinishedAt,omitempty"`
	ExecFinishedAtNEQ    *time.Time  `json:"execFinishedAtNEQ,omitempty"`
	ExecFinishedAtIn     []time.Time `json:"execFinishedAtIn,omitempty"`
	ExecFinishedAtNotIn  []time.Time `json:"execFinishedAtNotIn,omitempty"`
	ExecFinishedAtGT     *time.Time  `json:"execFinishedAtGT,omitempty"`
	ExecFinishedAtGTE    *time.Time  `json:"execFinishedAtGTE,omitempty"`
	ExecFinishedAtLT     *time.Time  `json:"execFinishedAtLT,omitempty"`
	ExecFinishedAtLTE    *time.Time  `json:"execFinishedAtLTE,omitempty"`
	ExecFinishedAtIsNil  bool        `json:"execFinishedAtIsNil,omitempty"`
	ExecFinishedAtNotNil bool        `json:"execFinishedAtNotNil,omitempty"`

	// "output" field predicates.
	Output             *string  `json:"output,omitempty"`
	OutputNEQ          *string  `json:"outputNEQ,omitempty"`
	OutputIn           []string `json:"outputIn,omitempty"`
	OutputNotIn        []string `json:"outputNotIn,omitempty"`
	OutputGT           *string  `json:"outputGT,omitempty"`
	OutputGTE          *string  `json:"outputGTE,omitempty"`
	OutputLT           *string  `json:"outputLT,omitempty"`
	OutputLTE          *string  `json:"outputLTE,omitempty"`
	OutputContains     *string  `json:"outputContains,omitempty"`
	OutputHasPrefix    *string  `json:"outputHasPrefix,omitempty"`
	OutputHasSuffix    *string  `json:"outputHasSuffix,omitempty"`
	OutputIsNil        bool     `json:"outputIsNil,omitempty"`
	OutputNotNil       bool     `json:"outputNotNil,omitempty"`
	OutputEqualFold    *string  `json:"outputEqualFold,omitempty"`
	OutputContainsFold *string  `json:"outputContainsFold,omitempty"`

	// "output_size" field predicates.
	OutputSize      *int  `json:"outputSize,omitempty"`
	OutputSizeNEQ   *int  `json:"outputSizeNEQ,omitempty"`
	OutputSizeIn    []int `json:"outputSizeIn,omitempty"`
	OutputSizeNotIn []int `json:"outputSizeNotIn,omitempty"`
	OutputSizeGT    *int  `json:"outputSizeGT,omitempty"`
	OutputSizeGTE   *int  `json:"outputSizeGTE,omitempty"`
	OutputSizeLT    *int  `json:"outputSizeLT,omitempty"`
	OutputSizeLTE   *int  `json:"outputSizeLTE,omitempty"`

	// "error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        bool     `json:"errorIsNil,omitempty"`
	ErrorNotNil       bool     `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`

	// "quest" edge predicates.
	HasQuest     *bool              `json:"hasQuest,omitempty"`
	HasQuestWith []*QuestWhereInput `json:"hasQuestWith,omitempty"`

	// "beacon" edge predicates.
	HasBeacon     *bool               `json:"hasBeacon,omitempty"`
	HasBeaconWith []*BeaconWhereInput `json:"hasBeaconWith,omitempty"`

	// "reported_processes" edge predicates.
	HasReportedProcesses     *bool                `json:"hasReportedProcesses,omitempty"`
	HasReportedProcessesWith []*ProcessWhereInput `json:"hasReportedProcessesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TaskWhereInput) AddPredicates(predicates ...predicate.Task) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TaskWhereInput filter on the TaskQuery builder.
func (i *TaskWhereInput) Filter(q *TaskQuery) (*TaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTaskWhereInput is returned in case the TaskWhereInput is empty.
var ErrEmptyTaskWhereInput = errors.New("ent: empty predicate TaskWhereInput")

// P returns a predicate for filtering tasks.
// An error is returned if the input is empty or invalid.
func (i *TaskWhereInput) P() (predicate.Task, error) {
	var predicates []predicate.Task
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, task.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Task, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, task.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Task, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, task.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, task.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, task.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, task.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, task.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, task.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, task.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, task.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, task.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, task.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, task.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, task.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, task.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, task.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, task.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, task.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, task.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, task.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, task.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, task.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, task.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, task.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, task.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, task.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, task.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.ClaimedAt != nil {
		predicates = append(predicates, task.ClaimedAtEQ(*i.ClaimedAt))
	}
	if i.ClaimedAtNEQ != nil {
		predicates = append(predicates, task.ClaimedAtNEQ(*i.ClaimedAtNEQ))
	}
	if len(i.ClaimedAtIn) > 0 {
		predicates = append(predicates, task.ClaimedAtIn(i.ClaimedAtIn...))
	}
	if len(i.ClaimedAtNotIn) > 0 {
		predicates = append(predicates, task.ClaimedAtNotIn(i.ClaimedAtNotIn...))
	}
	if i.ClaimedAtGT != nil {
		predicates = append(predicates, task.ClaimedAtGT(*i.ClaimedAtGT))
	}
	if i.ClaimedAtGTE != nil {
		predicates = append(predicates, task.ClaimedAtGTE(*i.ClaimedAtGTE))
	}
	if i.ClaimedAtLT != nil {
		predicates = append(predicates, task.ClaimedAtLT(*i.ClaimedAtLT))
	}
	if i.ClaimedAtLTE != nil {
		predicates = append(predicates, task.ClaimedAtLTE(*i.ClaimedAtLTE))
	}
	if i.ClaimedAtIsNil {
		predicates = append(predicates, task.ClaimedAtIsNil())
	}
	if i.ClaimedAtNotNil {
		predicates = append(predicates, task.ClaimedAtNotNil())
	}
	if i.ExecStartedAt != nil {
		predicates = append(predicates, task.ExecStartedAtEQ(*i.ExecStartedAt))
	}
	if i.ExecStartedAtNEQ != nil {
		predicates = append(predicates, task.ExecStartedAtNEQ(*i.ExecStartedAtNEQ))
	}
	if len(i.ExecStartedAtIn) > 0 {
		predicates = append(predicates, task.ExecStartedAtIn(i.ExecStartedAtIn...))
	}
	if len(i.ExecStartedAtNotIn) > 0 {
		predicates = append(predicates, task.ExecStartedAtNotIn(i.ExecStartedAtNotIn...))
	}
	if i.ExecStartedAtGT != nil {
		predicates = append(predicates, task.ExecStartedAtGT(*i.ExecStartedAtGT))
	}
	if i.ExecStartedAtGTE != nil {
		predicates = append(predicates, task.ExecStartedAtGTE(*i.ExecStartedAtGTE))
	}
	if i.ExecStartedAtLT != nil {
		predicates = append(predicates, task.ExecStartedAtLT(*i.ExecStartedAtLT))
	}
	if i.ExecStartedAtLTE != nil {
		predicates = append(predicates, task.ExecStartedAtLTE(*i.ExecStartedAtLTE))
	}
	if i.ExecStartedAtIsNil {
		predicates = append(predicates, task.ExecStartedAtIsNil())
	}
	if i.ExecStartedAtNotNil {
		predicates = append(predicates, task.ExecStartedAtNotNil())
	}
	if i.ExecFinishedAt != nil {
		predicates = append(predicates, task.ExecFinishedAtEQ(*i.ExecFinishedAt))
	}
	if i.ExecFinishedAtNEQ != nil {
		predicates = append(predicates, task.ExecFinishedAtNEQ(*i.ExecFinishedAtNEQ))
	}
	if len(i.ExecFinishedAtIn) > 0 {
		predicates = append(predicates, task.ExecFinishedAtIn(i.ExecFinishedAtIn...))
	}
	if len(i.ExecFinishedAtNotIn) > 0 {
		predicates = append(predicates, task.ExecFinishedAtNotIn(i.ExecFinishedAtNotIn...))
	}
	if i.ExecFinishedAtGT != nil {
		predicates = append(predicates, task.ExecFinishedAtGT(*i.ExecFinishedAtGT))
	}
	if i.ExecFinishedAtGTE != nil {
		predicates = append(predicates, task.ExecFinishedAtGTE(*i.ExecFinishedAtGTE))
	}
	if i.ExecFinishedAtLT != nil {
		predicates = append(predicates, task.ExecFinishedAtLT(*i.ExecFinishedAtLT))
	}
	if i.ExecFinishedAtLTE != nil {
		predicates = append(predicates, task.ExecFinishedAtLTE(*i.ExecFinishedAtLTE))
	}
	if i.ExecFinishedAtIsNil {
		predicates = append(predicates, task.ExecFinishedAtIsNil())
	}
	if i.ExecFinishedAtNotNil {
		predicates = append(predicates, task.ExecFinishedAtNotNil())
	}
	if i.Output != nil {
		predicates = append(predicates, task.OutputEQ(*i.Output))
	}
	if i.OutputNEQ != nil {
		predicates = append(predicates, task.OutputNEQ(*i.OutputNEQ))
	}
	if len(i.OutputIn) > 0 {
		predicates = append(predicates, task.OutputIn(i.OutputIn...))
	}
	if len(i.OutputNotIn) > 0 {
		predicates = append(predicates, task.OutputNotIn(i.OutputNotIn...))
	}
	if i.OutputGT != nil {
		predicates = append(predicates, task.OutputGT(*i.OutputGT))
	}
	if i.OutputGTE != nil {
		predicates = append(predicates, task.OutputGTE(*i.OutputGTE))
	}
	if i.OutputLT != nil {
		predicates = append(predicates, task.OutputLT(*i.OutputLT))
	}
	if i.OutputLTE != nil {
		predicates = append(predicates, task.OutputLTE(*i.OutputLTE))
	}
	if i.OutputContains != nil {
		predicates = append(predicates, task.OutputContains(*i.OutputContains))
	}
	if i.OutputHasPrefix != nil {
		predicates = append(predicates, task.OutputHasPrefix(*i.OutputHasPrefix))
	}
	if i.OutputHasSuffix != nil {
		predicates = append(predicates, task.OutputHasSuffix(*i.OutputHasSuffix))
	}
	if i.OutputIsNil {
		predicates = append(predicates, task.OutputIsNil())
	}
	if i.OutputNotNil {
		predicates = append(predicates, task.OutputNotNil())
	}
	if i.OutputEqualFold != nil {
		predicates = append(predicates, task.OutputEqualFold(*i.OutputEqualFold))
	}
	if i.OutputContainsFold != nil {
		predicates = append(predicates, task.OutputContainsFold(*i.OutputContainsFold))
	}
	if i.OutputSize != nil {
		predicates = append(predicates, task.OutputSizeEQ(*i.OutputSize))
	}
	if i.OutputSizeNEQ != nil {
		predicates = append(predicates, task.OutputSizeNEQ(*i.OutputSizeNEQ))
	}
	if len(i.OutputSizeIn) > 0 {
		predicates = append(predicates, task.OutputSizeIn(i.OutputSizeIn...))
	}
	if len(i.OutputSizeNotIn) > 0 {
		predicates = append(predicates, task.OutputSizeNotIn(i.OutputSizeNotIn...))
	}
	if i.OutputSizeGT != nil {
		predicates = append(predicates, task.OutputSizeGT(*i.OutputSizeGT))
	}
	if i.OutputSizeGTE != nil {
		predicates = append(predicates, task.OutputSizeGTE(*i.OutputSizeGTE))
	}
	if i.OutputSizeLT != nil {
		predicates = append(predicates, task.OutputSizeLT(*i.OutputSizeLT))
	}
	if i.OutputSizeLTE != nil {
		predicates = append(predicates, task.OutputSizeLTE(*i.OutputSizeLTE))
	}
	if i.Error != nil {
		predicates = append(predicates, task.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, task.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, task.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, task.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, task.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, task.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, task.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, task.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, task.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, task.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, task.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorIsNil {
		predicates = append(predicates, task.ErrorIsNil())
	}
	if i.ErrorNotNil {
		predicates = append(predicates, task.ErrorNotNil())
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, task.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, task.ErrorContainsFold(*i.ErrorContainsFold))
	}

	if i.HasQuest != nil {
		p := task.HasQuest()
		if !*i.HasQuest {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasQuestWith) > 0 {
		with := make([]predicate.Quest, 0, len(i.HasQuestWith))
		for _, w := range i.HasQuestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasQuestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasQuestWith(with...))
	}
	if i.HasBeacon != nil {
		p := task.HasBeacon()
		if !*i.HasBeacon {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeaconWith) > 0 {
		with := make([]predicate.Beacon, 0, len(i.HasBeaconWith))
		for _, w := range i.HasBeaconWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBeaconWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasBeaconWith(with...))
	}
	if i.HasReportedProcesses != nil {
		p := task.HasReportedProcesses()
		if !*i.HasReportedProcesses {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReportedProcessesWith) > 0 {
		with := make([]predicate.Process, 0, len(i.HasReportedProcessesWith))
		for _, w := range i.HasReportedProcessesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReportedProcessesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasReportedProcessesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return task.And(predicates...), nil
	}
}

// TomeWhereInput represents a where input for filtering Tome queries.
type TomeWhereInput struct {
	Predicates []predicate.Tome  `json:"-"`
	Not        *TomeWhereInput   `json:"not,omitempty"`
	Or         []*TomeWhereInput `json:"or,omitempty"`
	And        []*TomeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "param_defs" field predicates.
	ParamDefs             *string  `json:"paramDefs,omitempty"`
	ParamDefsNEQ          *string  `json:"paramDefsNEQ,omitempty"`
	ParamDefsIn           []string `json:"paramDefsIn,omitempty"`
	ParamDefsNotIn        []string `json:"paramDefsNotIn,omitempty"`
	ParamDefsGT           *string  `json:"paramDefsGT,omitempty"`
	ParamDefsGTE          *string  `json:"paramDefsGTE,omitempty"`
	ParamDefsLT           *string  `json:"paramDefsLT,omitempty"`
	ParamDefsLTE          *string  `json:"paramDefsLTE,omitempty"`
	ParamDefsContains     *string  `json:"paramDefsContains,omitempty"`
	ParamDefsHasPrefix    *string  `json:"paramDefsHasPrefix,omitempty"`
	ParamDefsHasSuffix    *string  `json:"paramDefsHasSuffix,omitempty"`
	ParamDefsIsNil        bool     `json:"paramDefsIsNil,omitempty"`
	ParamDefsNotNil       bool     `json:"paramDefsNotNil,omitempty"`
	ParamDefsEqualFold    *string  `json:"paramDefsEqualFold,omitempty"`
	ParamDefsContainsFold *string  `json:"paramDefsContainsFold,omitempty"`

	// "eldritch" field predicates.
	Eldritch             *string  `json:"eldritch,omitempty"`
	EldritchNEQ          *string  `json:"eldritchNEQ,omitempty"`
	EldritchIn           []string `json:"eldritchIn,omitempty"`
	EldritchNotIn        []string `json:"eldritchNotIn,omitempty"`
	EldritchGT           *string  `json:"eldritchGT,omitempty"`
	EldritchGTE          *string  `json:"eldritchGTE,omitempty"`
	EldritchLT           *string  `json:"eldritchLT,omitempty"`
	EldritchLTE          *string  `json:"eldritchLTE,omitempty"`
	EldritchContains     *string  `json:"eldritchContains,omitempty"`
	EldritchHasPrefix    *string  `json:"eldritchHasPrefix,omitempty"`
	EldritchHasSuffix    *string  `json:"eldritchHasSuffix,omitempty"`
	EldritchEqualFold    *string  `json:"eldritchEqualFold,omitempty"`
	EldritchContainsFold *string  `json:"eldritchContainsFold,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TomeWhereInput) AddPredicates(predicates ...predicate.Tome) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TomeWhereInput filter on the TomeQuery builder.
func (i *TomeWhereInput) Filter(q *TomeQuery) (*TomeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTomeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTomeWhereInput is returned in case the TomeWhereInput is empty.
var ErrEmptyTomeWhereInput = errors.New("ent: empty predicate TomeWhereInput")

// P returns a predicate for filtering tomes.
// An error is returned if the input is empty or invalid.
func (i *TomeWhereInput) P() (predicate.Tome, error) {
	var predicates []predicate.Tome
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tome.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tome, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tome.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tome, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tome.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tome.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tome.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tome.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tome.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tome.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tome.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tome.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tome.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, tome.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, tome.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, tome.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, tome.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, tome.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, tome.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, tome.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, tome.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, tome.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, tome.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, tome.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, tome.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, tome.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, tome.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, tome.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, tome.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tome.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tome.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tome.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tome.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tome.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tome.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tome.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tome.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tome.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tome.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tome.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tome.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tome.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, tome.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, tome.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, tome.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, tome.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, tome.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, tome.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, tome.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, tome.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, tome.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, tome.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, tome.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, tome.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, tome.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ParamDefs != nil {
		predicates = append(predicates, tome.ParamDefsEQ(*i.ParamDefs))
	}
	if i.ParamDefsNEQ != nil {
		predicates = append(predicates, tome.ParamDefsNEQ(*i.ParamDefsNEQ))
	}
	if len(i.ParamDefsIn) > 0 {
		predicates = append(predicates, tome.ParamDefsIn(i.ParamDefsIn...))
	}
	if len(i.ParamDefsNotIn) > 0 {
		predicates = append(predicates, tome.ParamDefsNotIn(i.ParamDefsNotIn...))
	}
	if i.ParamDefsGT != nil {
		predicates = append(predicates, tome.ParamDefsGT(*i.ParamDefsGT))
	}
	if i.ParamDefsGTE != nil {
		predicates = append(predicates, tome.ParamDefsGTE(*i.ParamDefsGTE))
	}
	if i.ParamDefsLT != nil {
		predicates = append(predicates, tome.ParamDefsLT(*i.ParamDefsLT))
	}
	if i.ParamDefsLTE != nil {
		predicates = append(predicates, tome.ParamDefsLTE(*i.ParamDefsLTE))
	}
	if i.ParamDefsContains != nil {
		predicates = append(predicates, tome.ParamDefsContains(*i.ParamDefsContains))
	}
	if i.ParamDefsHasPrefix != nil {
		predicates = append(predicates, tome.ParamDefsHasPrefix(*i.ParamDefsHasPrefix))
	}
	if i.ParamDefsHasSuffix != nil {
		predicates = append(predicates, tome.ParamDefsHasSuffix(*i.ParamDefsHasSuffix))
	}
	if i.ParamDefsIsNil {
		predicates = append(predicates, tome.ParamDefsIsNil())
	}
	if i.ParamDefsNotNil {
		predicates = append(predicates, tome.ParamDefsNotNil())
	}
	if i.ParamDefsEqualFold != nil {
		predicates = append(predicates, tome.ParamDefsEqualFold(*i.ParamDefsEqualFold))
	}
	if i.ParamDefsContainsFold != nil {
		predicates = append(predicates, tome.ParamDefsContainsFold(*i.ParamDefsContainsFold))
	}
	if i.Eldritch != nil {
		predicates = append(predicates, tome.EldritchEQ(*i.Eldritch))
	}
	if i.EldritchNEQ != nil {
		predicates = append(predicates, tome.EldritchNEQ(*i.EldritchNEQ))
	}
	if len(i.EldritchIn) > 0 {
		predicates = append(predicates, tome.EldritchIn(i.EldritchIn...))
	}
	if len(i.EldritchNotIn) > 0 {
		predicates = append(predicates, tome.EldritchNotIn(i.EldritchNotIn...))
	}
	if i.EldritchGT != nil {
		predicates = append(predicates, tome.EldritchGT(*i.EldritchGT))
	}
	if i.EldritchGTE != nil {
		predicates = append(predicates, tome.EldritchGTE(*i.EldritchGTE))
	}
	if i.EldritchLT != nil {
		predicates = append(predicates, tome.EldritchLT(*i.EldritchLT))
	}
	if i.EldritchLTE != nil {
		predicates = append(predicates, tome.EldritchLTE(*i.EldritchLTE))
	}
	if i.EldritchContains != nil {
		predicates = append(predicates, tome.EldritchContains(*i.EldritchContains))
	}
	if i.EldritchHasPrefix != nil {
		predicates = append(predicates, tome.EldritchHasPrefix(*i.EldritchHasPrefix))
	}
	if i.EldritchHasSuffix != nil {
		predicates = append(predicates, tome.EldritchHasSuffix(*i.EldritchHasSuffix))
	}
	if i.EldritchEqualFold != nil {
		predicates = append(predicates, tome.EldritchEqualFold(*i.EldritchEqualFold))
	}
	if i.EldritchContainsFold != nil {
		predicates = append(predicates, tome.EldritchContainsFold(*i.EldritchContainsFold))
	}

	if i.HasFiles != nil {
		p := tome.HasFiles()
		if !*i.HasFiles {
			p = tome.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tome.HasFilesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTomeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tome.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "oauth_id" field predicates.
	OauthID             *string  `json:"oauthID,omitempty"`
	OauthIDNEQ          *string  `json:"oauthIDNEQ,omitempty"`
	OauthIDIn           []string `json:"oauthIDIn,omitempty"`
	OauthIDNotIn        []string `json:"oauthIDNotIn,omitempty"`
	OauthIDGT           *string  `json:"oauthIDGT,omitempty"`
	OauthIDGTE          *string  `json:"oauthIDGTE,omitempty"`
	OauthIDLT           *string  `json:"oauthIDLT,omitempty"`
	OauthIDLTE          *string  `json:"oauthIDLTE,omitempty"`
	OauthIDContains     *string  `json:"oauthIDContains,omitempty"`
	OauthIDHasPrefix    *string  `json:"oauthIDHasPrefix,omitempty"`
	OauthIDHasSuffix    *string  `json:"oauthIDHasSuffix,omitempty"`
	OauthIDEqualFold    *string  `json:"oauthIDEqualFold,omitempty"`
	OauthIDContainsFold *string  `json:"oauthIDContainsFold,omitempty"`

	// "photo_url" field predicates.
	PhotoURL             *string  `json:"photoURL,omitempty"`
	PhotoURLNEQ          *string  `json:"photoURLNEQ,omitempty"`
	PhotoURLIn           []string `json:"photoURLIn,omitempty"`
	PhotoURLNotIn        []string `json:"photoURLNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photoURLGT,omitempty"`
	PhotoURLGTE          *string  `json:"photoURLGTE,omitempty"`
	PhotoURLLT           *string  `json:"photoURLLT,omitempty"`
	PhotoURLLTE          *string  `json:"photoURLLTE,omitempty"`
	PhotoURLContains     *string  `json:"photoURLContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photoURLHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photoURLHasSuffix,omitempty"`
	PhotoURLEqualFold    *string  `json:"photoURLEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photoURLContainsFold,omitempty"`

	// "is_activated" field predicates.
	IsActivated    *bool `json:"isActivated,omitempty"`
	IsActivatedNEQ *bool `json:"isActivatedNEQ,omitempty"`

	// "is_admin" field predicates.
	IsAdmin    *bool `json:"isAdmin,omitempty"`
	IsAdminNEQ *bool `json:"isAdminNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.OauthID != nil {
		predicates = append(predicates, user.OauthIDEQ(*i.OauthID))
	}
	if i.OauthIDNEQ != nil {
		predicates = append(predicates, user.OauthIDNEQ(*i.OauthIDNEQ))
	}
	if len(i.OauthIDIn) > 0 {
		predicates = append(predicates, user.OauthIDIn(i.OauthIDIn...))
	}
	if len(i.OauthIDNotIn) > 0 {
		predicates = append(predicates, user.OauthIDNotIn(i.OauthIDNotIn...))
	}
	if i.OauthIDGT != nil {
		predicates = append(predicates, user.OauthIDGT(*i.OauthIDGT))
	}
	if i.OauthIDGTE != nil {
		predicates = append(predicates, user.OauthIDGTE(*i.OauthIDGTE))
	}
	if i.OauthIDLT != nil {
		predicates = append(predicates, user.OauthIDLT(*i.OauthIDLT))
	}
	if i.OauthIDLTE != nil {
		predicates = append(predicates, user.OauthIDLTE(*i.OauthIDLTE))
	}
	if i.OauthIDContains != nil {
		predicates = append(predicates, user.OauthIDContains(*i.OauthIDContains))
	}
	if i.OauthIDHasPrefix != nil {
		predicates = append(predicates, user.OauthIDHasPrefix(*i.OauthIDHasPrefix))
	}
	if i.OauthIDHasSuffix != nil {
		predicates = append(predicates, user.OauthIDHasSuffix(*i.OauthIDHasSuffix))
	}
	if i.OauthIDEqualFold != nil {
		predicates = append(predicates, user.OauthIDEqualFold(*i.OauthIDEqualFold))
	}
	if i.OauthIDContainsFold != nil {
		predicates = append(predicates, user.OauthIDContainsFold(*i.OauthIDContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, user.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, user.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, user.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, user.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, user.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, user.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, user.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, user.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, user.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, user.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, user.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, user.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, user.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.IsActivated != nil {
		predicates = append(predicates, user.IsActivatedEQ(*i.IsActivated))
	}
	if i.IsActivatedNEQ != nil {
		predicates = append(predicates, user.IsActivatedNEQ(*i.IsActivatedNEQ))
	}
	if i.IsAdmin != nil {
		predicates = append(predicates, user.IsAdminEQ(*i.IsAdmin))
	}
	if i.IsAdminNEQ != nil {
		predicates = append(predicates, user.IsAdminNEQ(*i.IsAdminNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
