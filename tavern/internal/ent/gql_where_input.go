// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"realm.pub/tavern/internal/builder/builderpb"
	"realm.pub/tavern/internal/c2/c2pb"
	"realm.pub/tavern/internal/c2/epb"
	"realm.pub/tavern/internal/ent/asset"
	"realm.pub/tavern/internal/ent/beacon"
	"realm.pub/tavern/internal/ent/builder"
	"realm.pub/tavern/internal/ent/buildtask"
	"realm.pub/tavern/internal/ent/host"
	"realm.pub/tavern/internal/ent/hostcredential"
	"realm.pub/tavern/internal/ent/hostfile"
	"realm.pub/tavern/internal/ent/hostprocess"
	"realm.pub/tavern/internal/ent/link"
	"realm.pub/tavern/internal/ent/portal"
	"realm.pub/tavern/internal/ent/predicate"
	"realm.pub/tavern/internal/ent/quest"
	"realm.pub/tavern/internal/ent/repository"
	"realm.pub/tavern/internal/ent/shell"
	"realm.pub/tavern/internal/ent/shelltask"
	"realm.pub/tavern/internal/ent/tag"
	"realm.pub/tavern/internal/ent/task"
	"realm.pub/tavern/internal/ent/tome"
	"realm.pub/tavern/internal/ent/user"
)

// AssetWhereInput represents a where input for filtering Asset queries.
type AssetWhereInput struct {
	Predicates []predicate.Asset  `json:"-"`
	Not        *AssetWhereInput   `json:"not,omitempty"`
	Or         []*AssetWhereInput `json:"or,omitempty"`
	And        []*AssetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "size" field predicates.
	Size      *int  `json:"size,omitempty"`
	SizeNEQ   *int  `json:"sizeNEQ,omitempty"`
	SizeIn    []int `json:"sizeIn,omitempty"`
	SizeNotIn []int `json:"sizeNotIn,omitempty"`
	SizeGT    *int  `json:"sizeGT,omitempty"`
	SizeGTE   *int  `json:"sizeGTE,omitempty"`
	SizeLT    *int  `json:"sizeLT,omitempty"`
	SizeLTE   *int  `json:"sizeLTE,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "tomes" edge predicates.
	HasTomes     *bool             `json:"hasTomes,omitempty"`
	HasTomesWith []*TomeWhereInput `json:"hasTomesWith,omitempty"`

	// "links" edge predicates.
	HasLinks     *bool             `json:"hasLinks,omitempty"`
	HasLinksWith []*LinkWhereInput `json:"hasLinksWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AssetWhereInput) AddPredicates(predicates ...predicate.Asset) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AssetWhereInput filter on the AssetQuery builder.
func (i *AssetWhereInput) Filter(q *AssetQuery) (*AssetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAssetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAssetWhereInput is returned in case the AssetWhereInput is empty.
var ErrEmptyAssetWhereInput = errors.New("ent: empty predicate AssetWhereInput")

// P returns a predicate for filtering assets.
// An error is returned if the input is empty or invalid.
func (i *AssetWhereInput) P() (predicate.Asset, error) {
	var predicates []predicate.Asset
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, asset.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Asset, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, asset.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Asset, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, asset.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, asset.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, asset.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, asset.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, asset.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, asset.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, asset.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, asset.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, asset.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, asset.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, asset.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, asset.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, asset.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, asset.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, asset.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, asset.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, asset.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, asset.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, asset.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, asset.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, asset.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, asset.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, asset.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, asset.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, asset.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, asset.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, asset.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, asset.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, asset.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, asset.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, asset.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, asset.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, asset.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, asset.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, asset.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, asset.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, asset.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, asset.NameContainsFold(*i.NameContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, asset.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, asset.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, asset.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, asset.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, asset.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, asset.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, asset.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, asset.SizeLTE(*i.SizeLTE))
	}
	if i.Hash != nil {
		predicates = append(predicates, asset.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, asset.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, asset.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, asset.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, asset.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, asset.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, asset.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, asset.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, asset.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, asset.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, asset.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, asset.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, asset.HashContainsFold(*i.HashContainsFold))
	}

	if i.HasTomes != nil {
		p := asset.HasTomes()
		if !*i.HasTomes {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTomesWith) > 0 {
		with := make([]predicate.Tome, 0, len(i.HasTomesWith))
		for _, w := range i.HasTomesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTomesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasTomesWith(with...))
	}
	if i.HasLinks != nil {
		p := asset.HasLinks()
		if !*i.HasLinks {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLinksWith) > 0 {
		with := make([]predicate.Link, 0, len(i.HasLinksWith))
		for _, w := range i.HasLinksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLinksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasLinksWith(with...))
	}
	if i.HasCreator != nil {
		p := asset.HasCreator()
		if !*i.HasCreator {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAssetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return asset.And(predicates...), nil
	}
}

// BeaconWhereInput represents a where input for filtering Beacon queries.
type BeaconWhereInput struct {
	Predicates []predicate.Beacon  `json:"-"`
	Not        *BeaconWhereInput   `json:"not,omitempty"`
	Or         []*BeaconWhereInput `json:"or,omitempty"`
	And        []*BeaconWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "principal" field predicates.
	Principal             *string  `json:"principal,omitempty"`
	PrincipalNEQ          *string  `json:"principalNEQ,omitempty"`
	PrincipalIn           []string `json:"principalIn,omitempty"`
	PrincipalNotIn        []string `json:"principalNotIn,omitempty"`
	PrincipalGT           *string  `json:"principalGT,omitempty"`
	PrincipalGTE          *string  `json:"principalGTE,omitempty"`
	PrincipalLT           *string  `json:"principalLT,omitempty"`
	PrincipalLTE          *string  `json:"principalLTE,omitempty"`
	PrincipalContains     *string  `json:"principalContains,omitempty"`
	PrincipalHasPrefix    *string  `json:"principalHasPrefix,omitempty"`
	PrincipalHasSuffix    *string  `json:"principalHasSuffix,omitempty"`
	PrincipalIsNil        bool     `json:"principalIsNil,omitempty"`
	PrincipalNotNil       bool     `json:"principalNotNil,omitempty"`
	PrincipalEqualFold    *string  `json:"principalEqualFold,omitempty"`
	PrincipalContainsFold *string  `json:"principalContainsFold,omitempty"`

	// "identifier" field predicates.
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNEQ          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGT           *string  `json:"identifierGT,omitempty"`
	IdentifierGTE          *string  `json:"identifierGTE,omitempty"`
	IdentifierLT           *string  `json:"identifierLT,omitempty"`
	IdentifierLTE          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`

	// "agent_identifier" field predicates.
	AgentIdentifier             *string  `json:"agentIdentifier,omitempty"`
	AgentIdentifierNEQ          *string  `json:"agentIdentifierNEQ,omitempty"`
	AgentIdentifierIn           []string `json:"agentIdentifierIn,omitempty"`
	AgentIdentifierNotIn        []string `json:"agentIdentifierNotIn,omitempty"`
	AgentIdentifierGT           *string  `json:"agentIdentifierGT,omitempty"`
	AgentIdentifierGTE          *string  `json:"agentIdentifierGTE,omitempty"`
	AgentIdentifierLT           *string  `json:"agentIdentifierLT,omitempty"`
	AgentIdentifierLTE          *string  `json:"agentIdentifierLTE,omitempty"`
	AgentIdentifierContains     *string  `json:"agentIdentifierContains,omitempty"`
	AgentIdentifierHasPrefix    *string  `json:"agentIdentifierHasPrefix,omitempty"`
	AgentIdentifierHasSuffix    *string  `json:"agentIdentifierHasSuffix,omitempty"`
	AgentIdentifierIsNil        bool     `json:"agentIdentifierIsNil,omitempty"`
	AgentIdentifierNotNil       bool     `json:"agentIdentifierNotNil,omitempty"`
	AgentIdentifierEqualFold    *string  `json:"agentIdentifierEqualFold,omitempty"`
	AgentIdentifierContainsFold *string  `json:"agentIdentifierContainsFold,omitempty"`

	// "last_seen_at" field predicates.
	LastSeenAt       *time.Time  `json:"lastSeenAt,omitempty"`
	LastSeenAtNEQ    *time.Time  `json:"lastSeenAtNEQ,omitempty"`
	LastSeenAtIn     []time.Time `json:"lastSeenAtIn,omitempty"`
	LastSeenAtNotIn  []time.Time `json:"lastSeenAtNotIn,omitempty"`
	LastSeenAtGT     *time.Time  `json:"lastSeenAtGT,omitempty"`
	LastSeenAtGTE    *time.Time  `json:"lastSeenAtGTE,omitempty"`
	LastSeenAtLT     *time.Time  `json:"lastSeenAtLT,omitempty"`
	LastSeenAtLTE    *time.Time  `json:"lastSeenAtLTE,omitempty"`
	LastSeenAtIsNil  bool        `json:"lastSeenAtIsNil,omitempty"`
	LastSeenAtNotNil bool        `json:"lastSeenAtNotNil,omitempty"`

	// "next_seen_at" field predicates.
	NextSeenAt       *time.Time  `json:"nextSeenAt,omitempty"`
	NextSeenAtNEQ    *time.Time  `json:"nextSeenAtNEQ,omitempty"`
	NextSeenAtIn     []time.Time `json:"nextSeenAtIn,omitempty"`
	NextSeenAtNotIn  []time.Time `json:"nextSeenAtNotIn,omitempty"`
	NextSeenAtGT     *time.Time  `json:"nextSeenAtGT,omitempty"`
	NextSeenAtGTE    *time.Time  `json:"nextSeenAtGTE,omitempty"`
	NextSeenAtLT     *time.Time  `json:"nextSeenAtLT,omitempty"`
	NextSeenAtLTE    *time.Time  `json:"nextSeenAtLTE,omitempty"`
	NextSeenAtIsNil  bool        `json:"nextSeenAtIsNil,omitempty"`
	NextSeenAtNotNil bool        `json:"nextSeenAtNotNil,omitempty"`

	// "interval" field predicates.
	Interval       *uint64  `json:"interval,omitempty"`
	IntervalNEQ    *uint64  `json:"intervalNEQ,omitempty"`
	IntervalIn     []uint64 `json:"intervalIn,omitempty"`
	IntervalNotIn  []uint64 `json:"intervalNotIn,omitempty"`
	IntervalGT     *uint64  `json:"intervalGT,omitempty"`
	IntervalGTE    *uint64  `json:"intervalGTE,omitempty"`
	IntervalLT     *uint64  `json:"intervalLT,omitempty"`
	IntervalLTE    *uint64  `json:"intervalLTE,omitempty"`
	IntervalIsNil  bool     `json:"intervalIsNil,omitempty"`
	IntervalNotNil bool     `json:"intervalNotNil,omitempty"`

	// "transport" field predicates.
	Transport      *c2pb.Transport_Type  `json:"transport,omitempty"`
	TransportNEQ   *c2pb.Transport_Type  `json:"transportNEQ,omitempty"`
	TransportIn    []c2pb.Transport_Type `json:"transportIn,omitempty"`
	TransportNotIn []c2pb.Transport_Type `json:"transportNotIn,omitempty"`

	// "host" edge predicates.
	HasHost     *bool             `json:"hasHost,omitempty"`
	HasHostWith []*HostWhereInput `json:"hasHostWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "process" edge predicates.
	HasProcess     *bool                    `json:"hasProcess,omitempty"`
	HasProcessWith []*HostProcessWhereInput `json:"hasProcessWith,omitempty"`

	// "shells" edge predicates.
	HasShells     *bool              `json:"hasShells,omitempty"`
	HasShellsWith []*ShellWhereInput `json:"hasShellsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BeaconWhereInput) AddPredicates(predicates ...predicate.Beacon) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BeaconWhereInput filter on the BeaconQuery builder.
func (i *BeaconWhereInput) Filter(q *BeaconQuery) (*BeaconQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBeaconWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBeaconWhereInput is returned in case the BeaconWhereInput is empty.
var ErrEmptyBeaconWhereInput = errors.New("ent: empty predicate BeaconWhereInput")

// P returns a predicate for filtering beacons.
// An error is returned if the input is empty or invalid.
func (i *BeaconWhereInput) P() (predicate.Beacon, error) {
	var predicates []predicate.Beacon
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, beacon.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Beacon, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, beacon.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Beacon, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, beacon.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, beacon.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, beacon.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, beacon.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, beacon.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, beacon.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, beacon.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, beacon.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, beacon.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, beacon.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, beacon.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, beacon.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, beacon.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, beacon.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, beacon.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, beacon.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, beacon.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, beacon.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, beacon.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, beacon.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, beacon.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, beacon.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, beacon.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, beacon.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, beacon.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, beacon.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, beacon.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, beacon.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, beacon.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, beacon.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, beacon.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, beacon.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, beacon.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, beacon.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, beacon.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, beacon.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, beacon.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, beacon.NameContainsFold(*i.NameContainsFold))
	}
	if i.Principal != nil {
		predicates = append(predicates, beacon.PrincipalEQ(*i.Principal))
	}
	if i.PrincipalNEQ != nil {
		predicates = append(predicates, beacon.PrincipalNEQ(*i.PrincipalNEQ))
	}
	if len(i.PrincipalIn) > 0 {
		predicates = append(predicates, beacon.PrincipalIn(i.PrincipalIn...))
	}
	if len(i.PrincipalNotIn) > 0 {
		predicates = append(predicates, beacon.PrincipalNotIn(i.PrincipalNotIn...))
	}
	if i.PrincipalGT != nil {
		predicates = append(predicates, beacon.PrincipalGT(*i.PrincipalGT))
	}
	if i.PrincipalGTE != nil {
		predicates = append(predicates, beacon.PrincipalGTE(*i.PrincipalGTE))
	}
	if i.PrincipalLT != nil {
		predicates = append(predicates, beacon.PrincipalLT(*i.PrincipalLT))
	}
	if i.PrincipalLTE != nil {
		predicates = append(predicates, beacon.PrincipalLTE(*i.PrincipalLTE))
	}
	if i.PrincipalContains != nil {
		predicates = append(predicates, beacon.PrincipalContains(*i.PrincipalContains))
	}
	if i.PrincipalHasPrefix != nil {
		predicates = append(predicates, beacon.PrincipalHasPrefix(*i.PrincipalHasPrefix))
	}
	if i.PrincipalHasSuffix != nil {
		predicates = append(predicates, beacon.PrincipalHasSuffix(*i.PrincipalHasSuffix))
	}
	if i.PrincipalIsNil {
		predicates = append(predicates, beacon.PrincipalIsNil())
	}
	if i.PrincipalNotNil {
		predicates = append(predicates, beacon.PrincipalNotNil())
	}
	if i.PrincipalEqualFold != nil {
		predicates = append(predicates, beacon.PrincipalEqualFold(*i.PrincipalEqualFold))
	}
	if i.PrincipalContainsFold != nil {
		predicates = append(predicates, beacon.PrincipalContainsFold(*i.PrincipalContainsFold))
	}
	if i.Identifier != nil {
		predicates = append(predicates, beacon.IdentifierEQ(*i.Identifier))
	}
	if i.IdentifierNEQ != nil {
		predicates = append(predicates, beacon.IdentifierNEQ(*i.IdentifierNEQ))
	}
	if len(i.IdentifierIn) > 0 {
		predicates = append(predicates, beacon.IdentifierIn(i.IdentifierIn...))
	}
	if len(i.IdentifierNotIn) > 0 {
		predicates = append(predicates, beacon.IdentifierNotIn(i.IdentifierNotIn...))
	}
	if i.IdentifierGT != nil {
		predicates = append(predicates, beacon.IdentifierGT(*i.IdentifierGT))
	}
	if i.IdentifierGTE != nil {
		predicates = append(predicates, beacon.IdentifierGTE(*i.IdentifierGTE))
	}
	if i.IdentifierLT != nil {
		predicates = append(predicates, beacon.IdentifierLT(*i.IdentifierLT))
	}
	if i.IdentifierLTE != nil {
		predicates = append(predicates, beacon.IdentifierLTE(*i.IdentifierLTE))
	}
	if i.IdentifierContains != nil {
		predicates = append(predicates, beacon.IdentifierContains(*i.IdentifierContains))
	}
	if i.IdentifierHasPrefix != nil {
		predicates = append(predicates, beacon.IdentifierHasPrefix(*i.IdentifierHasPrefix))
	}
	if i.IdentifierHasSuffix != nil {
		predicates = append(predicates, beacon.IdentifierHasSuffix(*i.IdentifierHasSuffix))
	}
	if i.IdentifierEqualFold != nil {
		predicates = append(predicates, beacon.IdentifierEqualFold(*i.IdentifierEqualFold))
	}
	if i.IdentifierContainsFold != nil {
		predicates = append(predicates, beacon.IdentifierContainsFold(*i.IdentifierContainsFold))
	}
	if i.AgentIdentifier != nil {
		predicates = append(predicates, beacon.AgentIdentifierEQ(*i.AgentIdentifier))
	}
	if i.AgentIdentifierNEQ != nil {
		predicates = append(predicates, beacon.AgentIdentifierNEQ(*i.AgentIdentifierNEQ))
	}
	if len(i.AgentIdentifierIn) > 0 {
		predicates = append(predicates, beacon.AgentIdentifierIn(i.AgentIdentifierIn...))
	}
	if len(i.AgentIdentifierNotIn) > 0 {
		predicates = append(predicates, beacon.AgentIdentifierNotIn(i.AgentIdentifierNotIn...))
	}
	if i.AgentIdentifierGT != nil {
		predicates = append(predicates, beacon.AgentIdentifierGT(*i.AgentIdentifierGT))
	}
	if i.AgentIdentifierGTE != nil {
		predicates = append(predicates, beacon.AgentIdentifierGTE(*i.AgentIdentifierGTE))
	}
	if i.AgentIdentifierLT != nil {
		predicates = append(predicates, beacon.AgentIdentifierLT(*i.AgentIdentifierLT))
	}
	if i.AgentIdentifierLTE != nil {
		predicates = append(predicates, beacon.AgentIdentifierLTE(*i.AgentIdentifierLTE))
	}
	if i.AgentIdentifierContains != nil {
		predicates = append(predicates, beacon.AgentIdentifierContains(*i.AgentIdentifierContains))
	}
	if i.AgentIdentifierHasPrefix != nil {
		predicates = append(predicates, beacon.AgentIdentifierHasPrefix(*i.AgentIdentifierHasPrefix))
	}
	if i.AgentIdentifierHasSuffix != nil {
		predicates = append(predicates, beacon.AgentIdentifierHasSuffix(*i.AgentIdentifierHasSuffix))
	}
	if i.AgentIdentifierIsNil {
		predicates = append(predicates, beacon.AgentIdentifierIsNil())
	}
	if i.AgentIdentifierNotNil {
		predicates = append(predicates, beacon.AgentIdentifierNotNil())
	}
	if i.AgentIdentifierEqualFold != nil {
		predicates = append(predicates, beacon.AgentIdentifierEqualFold(*i.AgentIdentifierEqualFold))
	}
	if i.AgentIdentifierContainsFold != nil {
		predicates = append(predicates, beacon.AgentIdentifierContainsFold(*i.AgentIdentifierContainsFold))
	}
	if i.LastSeenAt != nil {
		predicates = append(predicates, beacon.LastSeenAtEQ(*i.LastSeenAt))
	}
	if i.LastSeenAtNEQ != nil {
		predicates = append(predicates, beacon.LastSeenAtNEQ(*i.LastSeenAtNEQ))
	}
	if len(i.LastSeenAtIn) > 0 {
		predicates = append(predicates, beacon.LastSeenAtIn(i.LastSeenAtIn...))
	}
	if len(i.LastSeenAtNotIn) > 0 {
		predicates = append(predicates, beacon.LastSeenAtNotIn(i.LastSeenAtNotIn...))
	}
	if i.LastSeenAtGT != nil {
		predicates = append(predicates, beacon.LastSeenAtGT(*i.LastSeenAtGT))
	}
	if i.LastSeenAtGTE != nil {
		predicates = append(predicates, beacon.LastSeenAtGTE(*i.LastSeenAtGTE))
	}
	if i.LastSeenAtLT != nil {
		predicates = append(predicates, beacon.LastSeenAtLT(*i.LastSeenAtLT))
	}
	if i.LastSeenAtLTE != nil {
		predicates = append(predicates, beacon.LastSeenAtLTE(*i.LastSeenAtLTE))
	}
	if i.LastSeenAtIsNil {
		predicates = append(predicates, beacon.LastSeenAtIsNil())
	}
	if i.LastSeenAtNotNil {
		predicates = append(predicates, beacon.LastSeenAtNotNil())
	}
	if i.NextSeenAt != nil {
		predicates = append(predicates, beacon.NextSeenAtEQ(*i.NextSeenAt))
	}
	if i.NextSeenAtNEQ != nil {
		predicates = append(predicates, beacon.NextSeenAtNEQ(*i.NextSeenAtNEQ))
	}
	if len(i.NextSeenAtIn) > 0 {
		predicates = append(predicates, beacon.NextSeenAtIn(i.NextSeenAtIn...))
	}
	if len(i.NextSeenAtNotIn) > 0 {
		predicates = append(predicates, beacon.NextSeenAtNotIn(i.NextSeenAtNotIn...))
	}
	if i.NextSeenAtGT != nil {
		predicates = append(predicates, beacon.NextSeenAtGT(*i.NextSeenAtGT))
	}
	if i.NextSeenAtGTE != nil {
		predicates = append(predicates, beacon.NextSeenAtGTE(*i.NextSeenAtGTE))
	}
	if i.NextSeenAtLT != nil {
		predicates = append(predicates, beacon.NextSeenAtLT(*i.NextSeenAtLT))
	}
	if i.NextSeenAtLTE != nil {
		predicates = append(predicates, beacon.NextSeenAtLTE(*i.NextSeenAtLTE))
	}
	if i.NextSeenAtIsNil {
		predicates = append(predicates, beacon.NextSeenAtIsNil())
	}
	if i.NextSeenAtNotNil {
		predicates = append(predicates, beacon.NextSeenAtNotNil())
	}
	if i.Interval != nil {
		predicates = append(predicates, beacon.IntervalEQ(*i.Interval))
	}
	if i.IntervalNEQ != nil {
		predicates = append(predicates, beacon.IntervalNEQ(*i.IntervalNEQ))
	}
	if len(i.IntervalIn) > 0 {
		predicates = append(predicates, beacon.IntervalIn(i.IntervalIn...))
	}
	if len(i.IntervalNotIn) > 0 {
		predicates = append(predicates, beacon.IntervalNotIn(i.IntervalNotIn...))
	}
	if i.IntervalGT != nil {
		predicates = append(predicates, beacon.IntervalGT(*i.IntervalGT))
	}
	if i.IntervalGTE != nil {
		predicates = append(predicates, beacon.IntervalGTE(*i.IntervalGTE))
	}
	if i.IntervalLT != nil {
		predicates = append(predicates, beacon.IntervalLT(*i.IntervalLT))
	}
	if i.IntervalLTE != nil {
		predicates = append(predicates, beacon.IntervalLTE(*i.IntervalLTE))
	}
	if i.IntervalIsNil {
		predicates = append(predicates, beacon.IntervalIsNil())
	}
	if i.IntervalNotNil {
		predicates = append(predicates, beacon.IntervalNotNil())
	}
	if i.Transport != nil {
		predicates = append(predicates, beacon.TransportEQ(*i.Transport))
	}
	if i.TransportNEQ != nil {
		predicates = append(predicates, beacon.TransportNEQ(*i.TransportNEQ))
	}
	if len(i.TransportIn) > 0 {
		predicates = append(predicates, beacon.TransportIn(i.TransportIn...))
	}
	if len(i.TransportNotIn) > 0 {
		predicates = append(predicates, beacon.TransportNotIn(i.TransportNotIn...))
	}

	if i.HasHost != nil {
		p := beacon.HasHost()
		if !*i.HasHost {
			p = beacon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHostWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasHostWith))
		for _, w := range i.HasHostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, beacon.HasHostWith(with...))
	}
	if i.HasTasks != nil {
		p := beacon.HasTasks()
		if !*i.HasTasks {
			p = beacon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, beacon.HasTasksWith(with...))
	}
	if i.HasProcess != nil {
		p := beacon.HasProcess()
		if !*i.HasProcess {
			p = beacon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcessWith) > 0 {
		with := make([]predicate.HostProcess, 0, len(i.HasProcessWith))
		for _, w := range i.HasProcessWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcessWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, beacon.HasProcessWith(with...))
	}
	if i.HasShells != nil {
		p := beacon.HasShells()
		if !*i.HasShells {
			p = beacon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShellsWith) > 0 {
		with := make([]predicate.Shell, 0, len(i.HasShellsWith))
		for _, w := range i.HasShellsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShellsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, beacon.HasShellsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBeaconWhereInput
	case 1:
		return predicates[0], nil
	default:
		return beacon.And(predicates...), nil
	}
}

// BuildTaskWhereInput represents a where input for filtering BuildTask queries.
type BuildTaskWhereInput struct {
	Predicates []predicate.BuildTask  `json:"-"`
	Not        *BuildTaskWhereInput   `json:"not,omitempty"`
	Or         []*BuildTaskWhereInput `json:"or,omitempty"`
	And        []*BuildTaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "target_os" field predicates.
	TargetOs      *c2pb.Host_Platform  `json:"targetOs,omitempty"`
	TargetOsNEQ   *c2pb.Host_Platform  `json:"targetOsNEQ,omitempty"`
	TargetOsIn    []c2pb.Host_Platform `json:"targetOsIn,omitempty"`
	TargetOsNotIn []c2pb.Host_Platform `json:"targetOsNotIn,omitempty"`

	// "target_format" field predicates.
	TargetFormat      *builderpb.TargetFormat  `json:"targetFormat,omitempty"`
	TargetFormatNEQ   *builderpb.TargetFormat  `json:"targetFormatNEQ,omitempty"`
	TargetFormatIn    []builderpb.TargetFormat `json:"targetFormatIn,omitempty"`
	TargetFormatNotIn []builderpb.TargetFormat `json:"targetFormatNotIn,omitempty"`

	// "build_image" field predicates.
	BuildImage             *string  `json:"buildImage,omitempty"`
	BuildImageNEQ          *string  `json:"buildImageNEQ,omitempty"`
	BuildImageIn           []string `json:"buildImageIn,omitempty"`
	BuildImageNotIn        []string `json:"buildImageNotIn,omitempty"`
	BuildImageGT           *string  `json:"buildImageGT,omitempty"`
	BuildImageGTE          *string  `json:"buildImageGTE,omitempty"`
	BuildImageLT           *string  `json:"buildImageLT,omitempty"`
	BuildImageLTE          *string  `json:"buildImageLTE,omitempty"`
	BuildImageContains     *string  `json:"buildImageContains,omitempty"`
	BuildImageHasPrefix    *string  `json:"buildImageHasPrefix,omitempty"`
	BuildImageHasSuffix    *string  `json:"buildImageHasSuffix,omitempty"`
	BuildImageEqualFold    *string  `json:"buildImageEqualFold,omitempty"`
	BuildImageContainsFold *string  `json:"buildImageContainsFold,omitempty"`

	// "build_script" field predicates.
	BuildScript             *string  `json:"buildScript,omitempty"`
	BuildScriptNEQ          *string  `json:"buildScriptNEQ,omitempty"`
	BuildScriptIn           []string `json:"buildScriptIn,omitempty"`
	BuildScriptNotIn        []string `json:"buildScriptNotIn,omitempty"`
	BuildScriptGT           *string  `json:"buildScriptGT,omitempty"`
	BuildScriptGTE          *string  `json:"buildScriptGTE,omitempty"`
	BuildScriptLT           *string  `json:"buildScriptLT,omitempty"`
	BuildScriptLTE          *string  `json:"buildScriptLTE,omitempty"`
	BuildScriptContains     *string  `json:"buildScriptContains,omitempty"`
	BuildScriptHasPrefix    *string  `json:"buildScriptHasPrefix,omitempty"`
	BuildScriptHasSuffix    *string  `json:"buildScriptHasSuffix,omitempty"`
	BuildScriptEqualFold    *string  `json:"buildScriptEqualFold,omitempty"`
	BuildScriptContainsFold *string  `json:"buildScriptContainsFold,omitempty"`

	// "claimed_at" field predicates.
	ClaimedAt       *time.Time  `json:"claimedAt,omitempty"`
	ClaimedAtNEQ    *time.Time  `json:"claimedAtNEQ,omitempty"`
	ClaimedAtIn     []time.Time `json:"claimedAtIn,omitempty"`
	ClaimedAtNotIn  []time.Time `json:"claimedAtNotIn,omitempty"`
	ClaimedAtGT     *time.Time  `json:"claimedAtGT,omitempty"`
	ClaimedAtGTE    *time.Time  `json:"claimedAtGTE,omitempty"`
	ClaimedAtLT     *time.Time  `json:"claimedAtLT,omitempty"`
	ClaimedAtLTE    *time.Time  `json:"claimedAtLTE,omitempty"`
	ClaimedAtIsNil  bool        `json:"claimedAtIsNil,omitempty"`
	ClaimedAtNotNil bool        `json:"claimedAtNotNil,omitempty"`

	// "started_at" field predicates.
	StartedAt       *time.Time  `json:"startedAt,omitempty"`
	StartedAtNEQ    *time.Time  `json:"startedAtNEQ,omitempty"`
	StartedAtIn     []time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn  []time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGT     *time.Time  `json:"startedAtGT,omitempty"`
	StartedAtGTE    *time.Time  `json:"startedAtGTE,omitempty"`
	StartedAtLT     *time.Time  `json:"startedAtLT,omitempty"`
	StartedAtLTE    *time.Time  `json:"startedAtLTE,omitempty"`
	StartedAtIsNil  bool        `json:"startedAtIsNil,omitempty"`
	StartedAtNotNil bool        `json:"startedAtNotNil,omitempty"`

	// "finished_at" field predicates.
	FinishedAt       *time.Time  `json:"finishedAt,omitempty"`
	FinishedAtNEQ    *time.Time  `json:"finishedAtNEQ,omitempty"`
	FinishedAtIn     []time.Time `json:"finishedAtIn,omitempty"`
	FinishedAtNotIn  []time.Time `json:"finishedAtNotIn,omitempty"`
	FinishedAtGT     *time.Time  `json:"finishedAtGT,omitempty"`
	FinishedAtGTE    *time.Time  `json:"finishedAtGTE,omitempty"`
	FinishedAtLT     *time.Time  `json:"finishedAtLT,omitempty"`
	FinishedAtLTE    *time.Time  `json:"finishedAtLTE,omitempty"`
	FinishedAtIsNil  bool        `json:"finishedAtIsNil,omitempty"`
	FinishedAtNotNil bool        `json:"finishedAtNotNil,omitempty"`

	// "output" field predicates.
	Output             *string  `json:"output,omitempty"`
	OutputNEQ          *string  `json:"outputNEQ,omitempty"`
	OutputIn           []string `json:"outputIn,omitempty"`
	OutputNotIn        []string `json:"outputNotIn,omitempty"`
	OutputGT           *string  `json:"outputGT,omitempty"`
	OutputGTE          *string  `json:"outputGTE,omitempty"`
	OutputLT           *string  `json:"outputLT,omitempty"`
	OutputLTE          *string  `json:"outputLTE,omitempty"`
	OutputContains     *string  `json:"outputContains,omitempty"`
	OutputHasPrefix    *string  `json:"outputHasPrefix,omitempty"`
	OutputHasSuffix    *string  `json:"outputHasSuffix,omitempty"`
	OutputIsNil        bool     `json:"outputIsNil,omitempty"`
	OutputNotNil       bool     `json:"outputNotNil,omitempty"`
	OutputEqualFold    *string  `json:"outputEqualFold,omitempty"`
	OutputContainsFold *string  `json:"outputContainsFold,omitempty"`

	// "output_size" field predicates.
	OutputSize      *int  `json:"outputSize,omitempty"`
	OutputSizeNEQ   *int  `json:"outputSizeNEQ,omitempty"`
	OutputSizeIn    []int `json:"outputSizeIn,omitempty"`
	OutputSizeNotIn []int `json:"outputSizeNotIn,omitempty"`
	OutputSizeGT    *int  `json:"outputSizeGT,omitempty"`
	OutputSizeGTE   *int  `json:"outputSizeGTE,omitempty"`
	OutputSizeLT    *int  `json:"outputSizeLT,omitempty"`
	OutputSizeLTE   *int  `json:"outputSizeLTE,omitempty"`

	// "error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        bool     `json:"errorIsNil,omitempty"`
	ErrorNotNil       bool     `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`

	// "error_size" field predicates.
	ErrorSize      *int  `json:"errorSize,omitempty"`
	ErrorSizeNEQ   *int  `json:"errorSizeNEQ,omitempty"`
	ErrorSizeIn    []int `json:"errorSizeIn,omitempty"`
	ErrorSizeNotIn []int `json:"errorSizeNotIn,omitempty"`
	ErrorSizeGT    *int  `json:"errorSizeGT,omitempty"`
	ErrorSizeGTE   *int  `json:"errorSizeGTE,omitempty"`
	ErrorSizeLT    *int  `json:"errorSizeLT,omitempty"`
	ErrorSizeLTE   *int  `json:"errorSizeLTE,omitempty"`

	// "exit_code" field predicates.
	ExitCode       *int  `json:"exitCode,omitempty"`
	ExitCodeNEQ    *int  `json:"exitCodeNEQ,omitempty"`
	ExitCodeIn     []int `json:"exitCodeIn,omitempty"`
	ExitCodeNotIn  []int `json:"exitCodeNotIn,omitempty"`
	ExitCodeGT     *int  `json:"exitCodeGT,omitempty"`
	ExitCodeGTE    *int  `json:"exitCodeGTE,omitempty"`
	ExitCodeLT     *int  `json:"exitCodeLT,omitempty"`
	ExitCodeLTE    *int  `json:"exitCodeLTE,omitempty"`
	ExitCodeIsNil  bool  `json:"exitCodeIsNil,omitempty"`
	ExitCodeNotNil bool  `json:"exitCodeNotNil,omitempty"`

	// "artifact_path" field predicates.
	ArtifactPath             *string  `json:"artifactPath,omitempty"`
	ArtifactPathNEQ          *string  `json:"artifactPathNEQ,omitempty"`
	ArtifactPathIn           []string `json:"artifactPathIn,omitempty"`
	ArtifactPathNotIn        []string `json:"artifactPathNotIn,omitempty"`
	ArtifactPathGT           *string  `json:"artifactPathGT,omitempty"`
	ArtifactPathGTE          *string  `json:"artifactPathGTE,omitempty"`
	ArtifactPathLT           *string  `json:"artifactPathLT,omitempty"`
	ArtifactPathLTE          *string  `json:"artifactPathLTE,omitempty"`
	ArtifactPathContains     *string  `json:"artifactPathContains,omitempty"`
	ArtifactPathHasPrefix    *string  `json:"artifactPathHasPrefix,omitempty"`
	ArtifactPathHasSuffix    *string  `json:"artifactPathHasSuffix,omitempty"`
	ArtifactPathIsNil        bool     `json:"artifactPathIsNil,omitempty"`
	ArtifactPathNotNil       bool     `json:"artifactPathNotNil,omitempty"`
	ArtifactPathEqualFold    *string  `json:"artifactPathEqualFold,omitempty"`
	ArtifactPathContainsFold *string  `json:"artifactPathContainsFold,omitempty"`

	// "builder" edge predicates.
	HasBuilder     *bool                `json:"hasBuilder,omitempty"`
	HasBuilderWith []*BuilderWhereInput `json:"hasBuilderWith,omitempty"`

	// "artifact" edge predicates.
	HasArtifact     *bool              `json:"hasArtifact,omitempty"`
	HasArtifactWith []*AssetWhereInput `json:"hasArtifactWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BuildTaskWhereInput) AddPredicates(predicates ...predicate.BuildTask) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BuildTaskWhereInput filter on the BuildTaskQuery builder.
func (i *BuildTaskWhereInput) Filter(q *BuildTaskQuery) (*BuildTaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBuildTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBuildTaskWhereInput is returned in case the BuildTaskWhereInput is empty.
var ErrEmptyBuildTaskWhereInput = errors.New("ent: empty predicate BuildTaskWhereInput")

// P returns a predicate for filtering buildtasks.
// An error is returned if the input is empty or invalid.
func (i *BuildTaskWhereInput) P() (predicate.BuildTask, error) {
	var predicates []predicate.BuildTask
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, buildtask.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BuildTask, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, buildtask.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BuildTask, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, buildtask.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, buildtask.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, buildtask.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, buildtask.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, buildtask.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, buildtask.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, buildtask.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, buildtask.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, buildtask.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, buildtask.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, buildtask.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, buildtask.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, buildtask.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, buildtask.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, buildtask.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, buildtask.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, buildtask.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, buildtask.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, buildtask.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, buildtask.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, buildtask.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, buildtask.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, buildtask.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, buildtask.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, buildtask.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.TargetOs != nil {
		predicates = append(predicates, buildtask.TargetOsEQ(*i.TargetOs))
	}
	if i.TargetOsNEQ != nil {
		predicates = append(predicates, buildtask.TargetOsNEQ(*i.TargetOsNEQ))
	}
	if len(i.TargetOsIn) > 0 {
		predicates = append(predicates, buildtask.TargetOsIn(i.TargetOsIn...))
	}
	if len(i.TargetOsNotIn) > 0 {
		predicates = append(predicates, buildtask.TargetOsNotIn(i.TargetOsNotIn...))
	}
	if i.TargetFormat != nil {
		predicates = append(predicates, buildtask.TargetFormatEQ(*i.TargetFormat))
	}
	if i.TargetFormatNEQ != nil {
		predicates = append(predicates, buildtask.TargetFormatNEQ(*i.TargetFormatNEQ))
	}
	if len(i.TargetFormatIn) > 0 {
		predicates = append(predicates, buildtask.TargetFormatIn(i.TargetFormatIn...))
	}
	if len(i.TargetFormatNotIn) > 0 {
		predicates = append(predicates, buildtask.TargetFormatNotIn(i.TargetFormatNotIn...))
	}
	if i.BuildImage != nil {
		predicates = append(predicates, buildtask.BuildImageEQ(*i.BuildImage))
	}
	if i.BuildImageNEQ != nil {
		predicates = append(predicates, buildtask.BuildImageNEQ(*i.BuildImageNEQ))
	}
	if len(i.BuildImageIn) > 0 {
		predicates = append(predicates, buildtask.BuildImageIn(i.BuildImageIn...))
	}
	if len(i.BuildImageNotIn) > 0 {
		predicates = append(predicates, buildtask.BuildImageNotIn(i.BuildImageNotIn...))
	}
	if i.BuildImageGT != nil {
		predicates = append(predicates, buildtask.BuildImageGT(*i.BuildImageGT))
	}
	if i.BuildImageGTE != nil {
		predicates = append(predicates, buildtask.BuildImageGTE(*i.BuildImageGTE))
	}
	if i.BuildImageLT != nil {
		predicates = append(predicates, buildtask.BuildImageLT(*i.BuildImageLT))
	}
	if i.BuildImageLTE != nil {
		predicates = append(predicates, buildtask.BuildImageLTE(*i.BuildImageLTE))
	}
	if i.BuildImageContains != nil {
		predicates = append(predicates, buildtask.BuildImageContains(*i.BuildImageContains))
	}
	if i.BuildImageHasPrefix != nil {
		predicates = append(predicates, buildtask.BuildImageHasPrefix(*i.BuildImageHasPrefix))
	}
	if i.BuildImageHasSuffix != nil {
		predicates = append(predicates, buildtask.BuildImageHasSuffix(*i.BuildImageHasSuffix))
	}
	if i.BuildImageEqualFold != nil {
		predicates = append(predicates, buildtask.BuildImageEqualFold(*i.BuildImageEqualFold))
	}
	if i.BuildImageContainsFold != nil {
		predicates = append(predicates, buildtask.BuildImageContainsFold(*i.BuildImageContainsFold))
	}
	if i.BuildScript != nil {
		predicates = append(predicates, buildtask.BuildScriptEQ(*i.BuildScript))
	}
	if i.BuildScriptNEQ != nil {
		predicates = append(predicates, buildtask.BuildScriptNEQ(*i.BuildScriptNEQ))
	}
	if len(i.BuildScriptIn) > 0 {
		predicates = append(predicates, buildtask.BuildScriptIn(i.BuildScriptIn...))
	}
	if len(i.BuildScriptNotIn) > 0 {
		predicates = append(predicates, buildtask.BuildScriptNotIn(i.BuildScriptNotIn...))
	}
	if i.BuildScriptGT != nil {
		predicates = append(predicates, buildtask.BuildScriptGT(*i.BuildScriptGT))
	}
	if i.BuildScriptGTE != nil {
		predicates = append(predicates, buildtask.BuildScriptGTE(*i.BuildScriptGTE))
	}
	if i.BuildScriptLT != nil {
		predicates = append(predicates, buildtask.BuildScriptLT(*i.BuildScriptLT))
	}
	if i.BuildScriptLTE != nil {
		predicates = append(predicates, buildtask.BuildScriptLTE(*i.BuildScriptLTE))
	}
	if i.BuildScriptContains != nil {
		predicates = append(predicates, buildtask.BuildScriptContains(*i.BuildScriptContains))
	}
	if i.BuildScriptHasPrefix != nil {
		predicates = append(predicates, buildtask.BuildScriptHasPrefix(*i.BuildScriptHasPrefix))
	}
	if i.BuildScriptHasSuffix != nil {
		predicates = append(predicates, buildtask.BuildScriptHasSuffix(*i.BuildScriptHasSuffix))
	}
	if i.BuildScriptEqualFold != nil {
		predicates = append(predicates, buildtask.BuildScriptEqualFold(*i.BuildScriptEqualFold))
	}
	if i.BuildScriptContainsFold != nil {
		predicates = append(predicates, buildtask.BuildScriptContainsFold(*i.BuildScriptContainsFold))
	}
	if i.ClaimedAt != nil {
		predicates = append(predicates, buildtask.ClaimedAtEQ(*i.ClaimedAt))
	}
	if i.ClaimedAtNEQ != nil {
		predicates = append(predicates, buildtask.ClaimedAtNEQ(*i.ClaimedAtNEQ))
	}
	if len(i.ClaimedAtIn) > 0 {
		predicates = append(predicates, buildtask.ClaimedAtIn(i.ClaimedAtIn...))
	}
	if len(i.ClaimedAtNotIn) > 0 {
		predicates = append(predicates, buildtask.ClaimedAtNotIn(i.ClaimedAtNotIn...))
	}
	if i.ClaimedAtGT != nil {
		predicates = append(predicates, buildtask.ClaimedAtGT(*i.ClaimedAtGT))
	}
	if i.ClaimedAtGTE != nil {
		predicates = append(predicates, buildtask.ClaimedAtGTE(*i.ClaimedAtGTE))
	}
	if i.ClaimedAtLT != nil {
		predicates = append(predicates, buildtask.ClaimedAtLT(*i.ClaimedAtLT))
	}
	if i.ClaimedAtLTE != nil {
		predicates = append(predicates, buildtask.ClaimedAtLTE(*i.ClaimedAtLTE))
	}
	if i.ClaimedAtIsNil {
		predicates = append(predicates, buildtask.ClaimedAtIsNil())
	}
	if i.ClaimedAtNotNil {
		predicates = append(predicates, buildtask.ClaimedAtNotNil())
	}
	if i.StartedAt != nil {
		predicates = append(predicates, buildtask.StartedAtEQ(*i.StartedAt))
	}
	if i.StartedAtNEQ != nil {
		predicates = append(predicates, buildtask.StartedAtNEQ(*i.StartedAtNEQ))
	}
	if len(i.StartedAtIn) > 0 {
		predicates = append(predicates, buildtask.StartedAtIn(i.StartedAtIn...))
	}
	if len(i.StartedAtNotIn) > 0 {
		predicates = append(predicates, buildtask.StartedAtNotIn(i.StartedAtNotIn...))
	}
	if i.StartedAtGT != nil {
		predicates = append(predicates, buildtask.StartedAtGT(*i.StartedAtGT))
	}
	if i.StartedAtGTE != nil {
		predicates = append(predicates, buildtask.StartedAtGTE(*i.StartedAtGTE))
	}
	if i.StartedAtLT != nil {
		predicates = append(predicates, buildtask.StartedAtLT(*i.StartedAtLT))
	}
	if i.StartedAtLTE != nil {
		predicates = append(predicates, buildtask.StartedAtLTE(*i.StartedAtLTE))
	}
	if i.StartedAtIsNil {
		predicates = append(predicates, buildtask.StartedAtIsNil())
	}
	if i.StartedAtNotNil {
		predicates = append(predicates, buildtask.StartedAtNotNil())
	}
	if i.FinishedAt != nil {
		predicates = append(predicates, buildtask.FinishedAtEQ(*i.FinishedAt))
	}
	if i.FinishedAtNEQ != nil {
		predicates = append(predicates, buildtask.FinishedAtNEQ(*i.FinishedAtNEQ))
	}
	if len(i.FinishedAtIn) > 0 {
		predicates = append(predicates, buildtask.FinishedAtIn(i.FinishedAtIn...))
	}
	if len(i.FinishedAtNotIn) > 0 {
		predicates = append(predicates, buildtask.FinishedAtNotIn(i.FinishedAtNotIn...))
	}
	if i.FinishedAtGT != nil {
		predicates = append(predicates, buildtask.FinishedAtGT(*i.FinishedAtGT))
	}
	if i.FinishedAtGTE != nil {
		predicates = append(predicates, buildtask.FinishedAtGTE(*i.FinishedAtGTE))
	}
	if i.FinishedAtLT != nil {
		predicates = append(predicates, buildtask.FinishedAtLT(*i.FinishedAtLT))
	}
	if i.FinishedAtLTE != nil {
		predicates = append(predicates, buildtask.FinishedAtLTE(*i.FinishedAtLTE))
	}
	if i.FinishedAtIsNil {
		predicates = append(predicates, buildtask.FinishedAtIsNil())
	}
	if i.FinishedAtNotNil {
		predicates = append(predicates, buildtask.FinishedAtNotNil())
	}
	if i.Output != nil {
		predicates = append(predicates, buildtask.OutputEQ(*i.Output))
	}
	if i.OutputNEQ != nil {
		predicates = append(predicates, buildtask.OutputNEQ(*i.OutputNEQ))
	}
	if len(i.OutputIn) > 0 {
		predicates = append(predicates, buildtask.OutputIn(i.OutputIn...))
	}
	if len(i.OutputNotIn) > 0 {
		predicates = append(predicates, buildtask.OutputNotIn(i.OutputNotIn...))
	}
	if i.OutputGT != nil {
		predicates = append(predicates, buildtask.OutputGT(*i.OutputGT))
	}
	if i.OutputGTE != nil {
		predicates = append(predicates, buildtask.OutputGTE(*i.OutputGTE))
	}
	if i.OutputLT != nil {
		predicates = append(predicates, buildtask.OutputLT(*i.OutputLT))
	}
	if i.OutputLTE != nil {
		predicates = append(predicates, buildtask.OutputLTE(*i.OutputLTE))
	}
	if i.OutputContains != nil {
		predicates = append(predicates, buildtask.OutputContains(*i.OutputContains))
	}
	if i.OutputHasPrefix != nil {
		predicates = append(predicates, buildtask.OutputHasPrefix(*i.OutputHasPrefix))
	}
	if i.OutputHasSuffix != nil {
		predicates = append(predicates, buildtask.OutputHasSuffix(*i.OutputHasSuffix))
	}
	if i.OutputIsNil {
		predicates = append(predicates, buildtask.OutputIsNil())
	}
	if i.OutputNotNil {
		predicates = append(predicates, buildtask.OutputNotNil())
	}
	if i.OutputEqualFold != nil {
		predicates = append(predicates, buildtask.OutputEqualFold(*i.OutputEqualFold))
	}
	if i.OutputContainsFold != nil {
		predicates = append(predicates, buildtask.OutputContainsFold(*i.OutputContainsFold))
	}
	if i.OutputSize != nil {
		predicates = append(predicates, buildtask.OutputSizeEQ(*i.OutputSize))
	}
	if i.OutputSizeNEQ != nil {
		predicates = append(predicates, buildtask.OutputSizeNEQ(*i.OutputSizeNEQ))
	}
	if len(i.OutputSizeIn) > 0 {
		predicates = append(predicates, buildtask.OutputSizeIn(i.OutputSizeIn...))
	}
	if len(i.OutputSizeNotIn) > 0 {
		predicates = append(predicates, buildtask.OutputSizeNotIn(i.OutputSizeNotIn...))
	}
	if i.OutputSizeGT != nil {
		predicates = append(predicates, buildtask.OutputSizeGT(*i.OutputSizeGT))
	}
	if i.OutputSizeGTE != nil {
		predicates = append(predicates, buildtask.OutputSizeGTE(*i.OutputSizeGTE))
	}
	if i.OutputSizeLT != nil {
		predicates = append(predicates, buildtask.OutputSizeLT(*i.OutputSizeLT))
	}
	if i.OutputSizeLTE != nil {
		predicates = append(predicates, buildtask.OutputSizeLTE(*i.OutputSizeLTE))
	}
	if i.Error != nil {
		predicates = append(predicates, buildtask.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, buildtask.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, buildtask.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, buildtask.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, buildtask.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, buildtask.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, buildtask.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, buildtask.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, buildtask.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, buildtask.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, buildtask.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorIsNil {
		predicates = append(predicates, buildtask.ErrorIsNil())
	}
	if i.ErrorNotNil {
		predicates = append(predicates, buildtask.ErrorNotNil())
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, buildtask.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, buildtask.ErrorContainsFold(*i.ErrorContainsFold))
	}
	if i.ErrorSize != nil {
		predicates = append(predicates, buildtask.ErrorSizeEQ(*i.ErrorSize))
	}
	if i.ErrorSizeNEQ != nil {
		predicates = append(predicates, buildtask.ErrorSizeNEQ(*i.ErrorSizeNEQ))
	}
	if len(i.ErrorSizeIn) > 0 {
		predicates = append(predicates, buildtask.ErrorSizeIn(i.ErrorSizeIn...))
	}
	if len(i.ErrorSizeNotIn) > 0 {
		predicates = append(predicates, buildtask.ErrorSizeNotIn(i.ErrorSizeNotIn...))
	}
	if i.ErrorSizeGT != nil {
		predicates = append(predicates, buildtask.ErrorSizeGT(*i.ErrorSizeGT))
	}
	if i.ErrorSizeGTE != nil {
		predicates = append(predicates, buildtask.ErrorSizeGTE(*i.ErrorSizeGTE))
	}
	if i.ErrorSizeLT != nil {
		predicates = append(predicates, buildtask.ErrorSizeLT(*i.ErrorSizeLT))
	}
	if i.ErrorSizeLTE != nil {
		predicates = append(predicates, buildtask.ErrorSizeLTE(*i.ErrorSizeLTE))
	}
	if i.ExitCode != nil {
		predicates = append(predicates, buildtask.ExitCodeEQ(*i.ExitCode))
	}
	if i.ExitCodeNEQ != nil {
		predicates = append(predicates, buildtask.ExitCodeNEQ(*i.ExitCodeNEQ))
	}
	if len(i.ExitCodeIn) > 0 {
		predicates = append(predicates, buildtask.ExitCodeIn(i.ExitCodeIn...))
	}
	if len(i.ExitCodeNotIn) > 0 {
		predicates = append(predicates, buildtask.ExitCodeNotIn(i.ExitCodeNotIn...))
	}
	if i.ExitCodeGT != nil {
		predicates = append(predicates, buildtask.ExitCodeGT(*i.ExitCodeGT))
	}
	if i.ExitCodeGTE != nil {
		predicates = append(predicates, buildtask.ExitCodeGTE(*i.ExitCodeGTE))
	}
	if i.ExitCodeLT != nil {
		predicates = append(predicates, buildtask.ExitCodeLT(*i.ExitCodeLT))
	}
	if i.ExitCodeLTE != nil {
		predicates = append(predicates, buildtask.ExitCodeLTE(*i.ExitCodeLTE))
	}
	if i.ExitCodeIsNil {
		predicates = append(predicates, buildtask.ExitCodeIsNil())
	}
	if i.ExitCodeNotNil {
		predicates = append(predicates, buildtask.ExitCodeNotNil())
	}
	if i.ArtifactPath != nil {
		predicates = append(predicates, buildtask.ArtifactPathEQ(*i.ArtifactPath))
	}
	if i.ArtifactPathNEQ != nil {
		predicates = append(predicates, buildtask.ArtifactPathNEQ(*i.ArtifactPathNEQ))
	}
	if len(i.ArtifactPathIn) > 0 {
		predicates = append(predicates, buildtask.ArtifactPathIn(i.ArtifactPathIn...))
	}
	if len(i.ArtifactPathNotIn) > 0 {
		predicates = append(predicates, buildtask.ArtifactPathNotIn(i.ArtifactPathNotIn...))
	}
	if i.ArtifactPathGT != nil {
		predicates = append(predicates, buildtask.ArtifactPathGT(*i.ArtifactPathGT))
	}
	if i.ArtifactPathGTE != nil {
		predicates = append(predicates, buildtask.ArtifactPathGTE(*i.ArtifactPathGTE))
	}
	if i.ArtifactPathLT != nil {
		predicates = append(predicates, buildtask.ArtifactPathLT(*i.ArtifactPathLT))
	}
	if i.ArtifactPathLTE != nil {
		predicates = append(predicates, buildtask.ArtifactPathLTE(*i.ArtifactPathLTE))
	}
	if i.ArtifactPathContains != nil {
		predicates = append(predicates, buildtask.ArtifactPathContains(*i.ArtifactPathContains))
	}
	if i.ArtifactPathHasPrefix != nil {
		predicates = append(predicates, buildtask.ArtifactPathHasPrefix(*i.ArtifactPathHasPrefix))
	}
	if i.ArtifactPathHasSuffix != nil {
		predicates = append(predicates, buildtask.ArtifactPathHasSuffix(*i.ArtifactPathHasSuffix))
	}
	if i.ArtifactPathIsNil {
		predicates = append(predicates, buildtask.ArtifactPathIsNil())
	}
	if i.ArtifactPathNotNil {
		predicates = append(predicates, buildtask.ArtifactPathNotNil())
	}
	if i.ArtifactPathEqualFold != nil {
		predicates = append(predicates, buildtask.ArtifactPathEqualFold(*i.ArtifactPathEqualFold))
	}
	if i.ArtifactPathContainsFold != nil {
		predicates = append(predicates, buildtask.ArtifactPathContainsFold(*i.ArtifactPathContainsFold))
	}

	if i.HasBuilder != nil {
		p := buildtask.HasBuilder()
		if !*i.HasBuilder {
			p = buildtask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuilderWith) > 0 {
		with := make([]predicate.Builder, 0, len(i.HasBuilderWith))
		for _, w := range i.HasBuilderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuilderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildtask.HasBuilderWith(with...))
	}
	if i.HasArtifact != nil {
		p := buildtask.HasArtifact()
		if !*i.HasArtifact {
			p = buildtask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasArtifactWith))
		for _, w := range i.HasArtifactWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildtask.HasArtifactWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBuildTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return buildtask.And(predicates...), nil
	}
}

// BuilderWhereInput represents a where input for filtering Builder queries.
type BuilderWhereInput struct {
	Predicates []predicate.Builder  `json:"-"`
	Not        *BuilderWhereInput   `json:"not,omitempty"`
	Or         []*BuilderWhereInput `json:"or,omitempty"`
	And        []*BuilderWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "identifier" field predicates.
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNEQ          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGT           *string  `json:"identifierGT,omitempty"`
	IdentifierGTE          *string  `json:"identifierGTE,omitempty"`
	IdentifierLT           *string  `json:"identifierLT,omitempty"`
	IdentifierLTE          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`

	// "upstream" field predicates.
	Upstream             *string  `json:"upstream,omitempty"`
	UpstreamNEQ          *string  `json:"upstreamNEQ,omitempty"`
	UpstreamIn           []string `json:"upstreamIn,omitempty"`
	UpstreamNotIn        []string `json:"upstreamNotIn,omitempty"`
	UpstreamGT           *string  `json:"upstreamGT,omitempty"`
	UpstreamGTE          *string  `json:"upstreamGTE,omitempty"`
	UpstreamLT           *string  `json:"upstreamLT,omitempty"`
	UpstreamLTE          *string  `json:"upstreamLTE,omitempty"`
	UpstreamContains     *string  `json:"upstreamContains,omitempty"`
	UpstreamHasPrefix    *string  `json:"upstreamHasPrefix,omitempty"`
	UpstreamHasSuffix    *string  `json:"upstreamHasSuffix,omitempty"`
	UpstreamEqualFold    *string  `json:"upstreamEqualFold,omitempty"`
	UpstreamContainsFold *string  `json:"upstreamContainsFold,omitempty"`

	// "last_seen_at" field predicates.
	LastSeenAt       *time.Time  `json:"lastSeenAt,omitempty"`
	LastSeenAtNEQ    *time.Time  `json:"lastSeenAtNEQ,omitempty"`
	LastSeenAtIn     []time.Time `json:"lastSeenAtIn,omitempty"`
	LastSeenAtNotIn  []time.Time `json:"lastSeenAtNotIn,omitempty"`
	LastSeenAtGT     *time.Time  `json:"lastSeenAtGT,omitempty"`
	LastSeenAtGTE    *time.Time  `json:"lastSeenAtGTE,omitempty"`
	LastSeenAtLT     *time.Time  `json:"lastSeenAtLT,omitempty"`
	LastSeenAtLTE    *time.Time  `json:"lastSeenAtLTE,omitempty"`
	LastSeenAtIsNil  bool        `json:"lastSeenAtIsNil,omitempty"`
	LastSeenAtNotNil bool        `json:"lastSeenAtNotNil,omitempty"`

	// "build_tasks" edge predicates.
	HasBuildTasks     *bool                  `json:"hasBuildTasks,omitempty"`
	HasBuildTasksWith []*BuildTaskWhereInput `json:"hasBuildTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BuilderWhereInput) AddPredicates(predicates ...predicate.Builder) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BuilderWhereInput filter on the BuilderQuery builder.
func (i *BuilderWhereInput) Filter(q *BuilderQuery) (*BuilderQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBuilderWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBuilderWhereInput is returned in case the BuilderWhereInput is empty.
var ErrEmptyBuilderWhereInput = errors.New("ent: empty predicate BuilderWhereInput")

// P returns a predicate for filtering builders.
// An error is returned if the input is empty or invalid.
func (i *BuilderWhereInput) P() (predicate.Builder, error) {
	var predicates []predicate.Builder
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, builder.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Builder, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, builder.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Builder, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, builder.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, builder.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, builder.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, builder.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, builder.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, builder.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, builder.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, builder.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, builder.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, builder.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, builder.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, builder.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, builder.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, builder.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, builder.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, builder.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, builder.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, builder.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, builder.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, builder.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, builder.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, builder.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, builder.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, builder.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, builder.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Identifier != nil {
		predicates = append(predicates, builder.IdentifierEQ(*i.Identifier))
	}
	if i.IdentifierNEQ != nil {
		predicates = append(predicates, builder.IdentifierNEQ(*i.IdentifierNEQ))
	}
	if len(i.IdentifierIn) > 0 {
		predicates = append(predicates, builder.IdentifierIn(i.IdentifierIn...))
	}
	if len(i.IdentifierNotIn) > 0 {
		predicates = append(predicates, builder.IdentifierNotIn(i.IdentifierNotIn...))
	}
	if i.IdentifierGT != nil {
		predicates = append(predicates, builder.IdentifierGT(*i.IdentifierGT))
	}
	if i.IdentifierGTE != nil {
		predicates = append(predicates, builder.IdentifierGTE(*i.IdentifierGTE))
	}
	if i.IdentifierLT != nil {
		predicates = append(predicates, builder.IdentifierLT(*i.IdentifierLT))
	}
	if i.IdentifierLTE != nil {
		predicates = append(predicates, builder.IdentifierLTE(*i.IdentifierLTE))
	}
	if i.IdentifierContains != nil {
		predicates = append(predicates, builder.IdentifierContains(*i.IdentifierContains))
	}
	if i.IdentifierHasPrefix != nil {
		predicates = append(predicates, builder.IdentifierHasPrefix(*i.IdentifierHasPrefix))
	}
	if i.IdentifierHasSuffix != nil {
		predicates = append(predicates, builder.IdentifierHasSuffix(*i.IdentifierHasSuffix))
	}
	if i.IdentifierEqualFold != nil {
		predicates = append(predicates, builder.IdentifierEqualFold(*i.IdentifierEqualFold))
	}
	if i.IdentifierContainsFold != nil {
		predicates = append(predicates, builder.IdentifierContainsFold(*i.IdentifierContainsFold))
	}
	if i.Upstream != nil {
		predicates = append(predicates, builder.UpstreamEQ(*i.Upstream))
	}
	if i.UpstreamNEQ != nil {
		predicates = append(predicates, builder.UpstreamNEQ(*i.UpstreamNEQ))
	}
	if len(i.UpstreamIn) > 0 {
		predicates = append(predicates, builder.UpstreamIn(i.UpstreamIn...))
	}
	if len(i.UpstreamNotIn) > 0 {
		predicates = append(predicates, builder.UpstreamNotIn(i.UpstreamNotIn...))
	}
	if i.UpstreamGT != nil {
		predicates = append(predicates, builder.UpstreamGT(*i.UpstreamGT))
	}
	if i.UpstreamGTE != nil {
		predicates = append(predicates, builder.UpstreamGTE(*i.UpstreamGTE))
	}
	if i.UpstreamLT != nil {
		predicates = append(predicates, builder.UpstreamLT(*i.UpstreamLT))
	}
	if i.UpstreamLTE != nil {
		predicates = append(predicates, builder.UpstreamLTE(*i.UpstreamLTE))
	}
	if i.UpstreamContains != nil {
		predicates = append(predicates, builder.UpstreamContains(*i.UpstreamContains))
	}
	if i.UpstreamHasPrefix != nil {
		predicates = append(predicates, builder.UpstreamHasPrefix(*i.UpstreamHasPrefix))
	}
	if i.UpstreamHasSuffix != nil {
		predicates = append(predicates, builder.UpstreamHasSuffix(*i.UpstreamHasSuffix))
	}
	if i.UpstreamEqualFold != nil {
		predicates = append(predicates, builder.UpstreamEqualFold(*i.UpstreamEqualFold))
	}
	if i.UpstreamContainsFold != nil {
		predicates = append(predicates, builder.UpstreamContainsFold(*i.UpstreamContainsFold))
	}
	if i.LastSeenAt != nil {
		predicates = append(predicates, builder.LastSeenAtEQ(*i.LastSeenAt))
	}
	if i.LastSeenAtNEQ != nil {
		predicates = append(predicates, builder.LastSeenAtNEQ(*i.LastSeenAtNEQ))
	}
	if len(i.LastSeenAtIn) > 0 {
		predicates = append(predicates, builder.LastSeenAtIn(i.LastSeenAtIn...))
	}
	if len(i.LastSeenAtNotIn) > 0 {
		predicates = append(predicates, builder.LastSeenAtNotIn(i.LastSeenAtNotIn...))
	}
	if i.LastSeenAtGT != nil {
		predicates = append(predicates, builder.LastSeenAtGT(*i.LastSeenAtGT))
	}
	if i.LastSeenAtGTE != nil {
		predicates = append(predicates, builder.LastSeenAtGTE(*i.LastSeenAtGTE))
	}
	if i.LastSeenAtLT != nil {
		predicates = append(predicates, builder.LastSeenAtLT(*i.LastSeenAtLT))
	}
	if i.LastSeenAtLTE != nil {
		predicates = append(predicates, builder.LastSeenAtLTE(*i.LastSeenAtLTE))
	}
	if i.LastSeenAtIsNil {
		predicates = append(predicates, builder.LastSeenAtIsNil())
	}
	if i.LastSeenAtNotNil {
		predicates = append(predicates, builder.LastSeenAtNotNil())
	}

	if i.HasBuildTasks != nil {
		p := builder.HasBuildTasks()
		if !*i.HasBuildTasks {
			p = builder.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildTasksWith) > 0 {
		with := make([]predicate.BuildTask, 0, len(i.HasBuildTasksWith))
		for _, w := range i.HasBuildTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, builder.HasBuildTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBuilderWhereInput
	case 1:
		return predicates[0], nil
	default:
		return builder.And(predicates...), nil
	}
}

// HostWhereInput represents a where input for filtering Host queries.
type HostWhereInput struct {
	Predicates []predicate.Host  `json:"-"`
	Not        *HostWhereInput   `json:"not,omitempty"`
	Or         []*HostWhereInput `json:"or,omitempty"`
	And        []*HostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "identifier" field predicates.
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNEQ          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGT           *string  `json:"identifierGT,omitempty"`
	IdentifierGTE          *string  `json:"identifierGTE,omitempty"`
	IdentifierLT           *string  `json:"identifierLT,omitempty"`
	IdentifierLTE          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "primary_ip" field predicates.
	PrimaryIP             *string  `json:"primaryIP,omitempty"`
	PrimaryIPNEQ          *string  `json:"primaryIPNEQ,omitempty"`
	PrimaryIPIn           []string `json:"primaryIPIn,omitempty"`
	PrimaryIPNotIn        []string `json:"primaryIPNotIn,omitempty"`
	PrimaryIPGT           *string  `json:"primaryIPGT,omitempty"`
	PrimaryIPGTE          *string  `json:"primaryIPGTE,omitempty"`
	PrimaryIPLT           *string  `json:"primaryIPLT,omitempty"`
	PrimaryIPLTE          *string  `json:"primaryIPLTE,omitempty"`
	PrimaryIPContains     *string  `json:"primaryIPContains,omitempty"`
	PrimaryIPHasPrefix    *string  `json:"primaryIPHasPrefix,omitempty"`
	PrimaryIPHasSuffix    *string  `json:"primaryIPHasSuffix,omitempty"`
	PrimaryIPIsNil        bool     `json:"primaryIPIsNil,omitempty"`
	PrimaryIPNotNil       bool     `json:"primaryIPNotNil,omitempty"`
	PrimaryIPEqualFold    *string  `json:"primaryIPEqualFold,omitempty"`
	PrimaryIPContainsFold *string  `json:"primaryIPContainsFold,omitempty"`

	// "external_ip" field predicates.
	ExternalIP             *string  `json:"externalIP,omitempty"`
	ExternalIPNEQ          *string  `json:"externalIPNEQ,omitempty"`
	ExternalIPIn           []string `json:"externalIPIn,omitempty"`
	ExternalIPNotIn        []string `json:"externalIPNotIn,omitempty"`
	ExternalIPGT           *string  `json:"externalIPGT,omitempty"`
	ExternalIPGTE          *string  `json:"externalIPGTE,omitempty"`
	ExternalIPLT           *string  `json:"externalIPLT,omitempty"`
	ExternalIPLTE          *string  `json:"externalIPLTE,omitempty"`
	ExternalIPContains     *string  `json:"externalIPContains,omitempty"`
	ExternalIPHasPrefix    *string  `json:"externalIPHasPrefix,omitempty"`
	ExternalIPHasSuffix    *string  `json:"externalIPHasSuffix,omitempty"`
	ExternalIPIsNil        bool     `json:"externalIPIsNil,omitempty"`
	ExternalIPNotNil       bool     `json:"externalIPNotNil,omitempty"`
	ExternalIPEqualFold    *string  `json:"externalIPEqualFold,omitempty"`
	ExternalIPContainsFold *string  `json:"externalIPContainsFold,omitempty"`

	// "platform" field predicates.
	Platform      *c2pb.Host_Platform  `json:"platform,omitempty"`
	PlatformNEQ   *c2pb.Host_Platform  `json:"platformNEQ,omitempty"`
	PlatformIn    []c2pb.Host_Platform `json:"platformIn,omitempty"`
	PlatformNotIn []c2pb.Host_Platform `json:"platformNotIn,omitempty"`

	// "last_seen_at" field predicates.
	LastSeenAt       *time.Time  `json:"lastSeenAt,omitempty"`
	LastSeenAtNEQ    *time.Time  `json:"lastSeenAtNEQ,omitempty"`
	LastSeenAtIn     []time.Time `json:"lastSeenAtIn,omitempty"`
	LastSeenAtNotIn  []time.Time `json:"lastSeenAtNotIn,omitempty"`
	LastSeenAtGT     *time.Time  `json:"lastSeenAtGT,omitempty"`
	LastSeenAtGTE    *time.Time  `json:"lastSeenAtGTE,omitempty"`
	LastSeenAtLT     *time.Time  `json:"lastSeenAtLT,omitempty"`
	LastSeenAtLTE    *time.Time  `json:"lastSeenAtLTE,omitempty"`
	LastSeenAtIsNil  bool        `json:"lastSeenAtIsNil,omitempty"`
	LastSeenAtNotNil bool        `json:"lastSeenAtNotNil,omitempty"`

	// "next_seen_at" field predicates.
	NextSeenAt       *time.Time  `json:"nextSeenAt,omitempty"`
	NextSeenAtNEQ    *time.Time  `json:"nextSeenAtNEQ,omitempty"`
	NextSeenAtIn     []time.Time `json:"nextSeenAtIn,omitempty"`
	NextSeenAtNotIn  []time.Time `json:"nextSeenAtNotIn,omitempty"`
	NextSeenAtGT     *time.Time  `json:"nextSeenAtGT,omitempty"`
	NextSeenAtGTE    *time.Time  `json:"nextSeenAtGTE,omitempty"`
	NextSeenAtLT     *time.Time  `json:"nextSeenAtLT,omitempty"`
	NextSeenAtLTE    *time.Time  `json:"nextSeenAtLTE,omitempty"`
	NextSeenAtIsNil  bool        `json:"nextSeenAtIsNil,omitempty"`
	NextSeenAtNotNil bool        `json:"nextSeenAtNotNil,omitempty"`

	// "tags" edge predicates.
	HasTags     *bool            `json:"hasTags,omitempty"`
	HasTagsWith []*TagWhereInput `json:"hasTagsWith,omitempty"`

	// "beacons" edge predicates.
	HasBeacons     *bool               `json:"hasBeacons,omitempty"`
	HasBeaconsWith []*BeaconWhereInput `json:"hasBeaconsWith,omitempty"`

	// "files" edge predicates.
	HasFiles     *bool                 `json:"hasFiles,omitempty"`
	HasFilesWith []*HostFileWhereInput `json:"hasFilesWith,omitempty"`

	// "processes" edge predicates.
	HasProcesses     *bool                    `json:"hasProcesses,omitempty"`
	HasProcessesWith []*HostProcessWhereInput `json:"hasProcessesWith,omitempty"`

	// "credentials" edge predicates.
	HasCredentials     *bool                       `json:"hasCredentials,omitempty"`
	HasCredentialsWith []*HostCredentialWhereInput `json:"hasCredentialsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HostWhereInput) AddPredicates(predicates ...predicate.Host) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HostWhereInput filter on the HostQuery builder.
func (i *HostWhereInput) Filter(q *HostQuery) (*HostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHostWhereInput is returned in case the HostWhereInput is empty.
var ErrEmptyHostWhereInput = errors.New("ent: empty predicate HostWhereInput")

// P returns a predicate for filtering hosts.
// An error is returned if the input is empty or invalid.
func (i *HostWhereInput) P() (predicate.Host, error) {
	var predicates []predicate.Host
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, host.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Host, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, host.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Host, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, host.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, host.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, host.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, host.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, host.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, host.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, host.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, host.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, host.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, host.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, host.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, host.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, host.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, host.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, host.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, host.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, host.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, host.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, host.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, host.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, host.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, host.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, host.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, host.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, host.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Identifier != nil {
		predicates = append(predicates, host.IdentifierEQ(*i.Identifier))
	}
	if i.IdentifierNEQ != nil {
		predicates = append(predicates, host.IdentifierNEQ(*i.IdentifierNEQ))
	}
	if len(i.IdentifierIn) > 0 {
		predicates = append(predicates, host.IdentifierIn(i.IdentifierIn...))
	}
	if len(i.IdentifierNotIn) > 0 {
		predicates = append(predicates, host.IdentifierNotIn(i.IdentifierNotIn...))
	}
	if i.IdentifierGT != nil {
		predicates = append(predicates, host.IdentifierGT(*i.IdentifierGT))
	}
	if i.IdentifierGTE != nil {
		predicates = append(predicates, host.IdentifierGTE(*i.IdentifierGTE))
	}
	if i.IdentifierLT != nil {
		predicates = append(predicates, host.IdentifierLT(*i.IdentifierLT))
	}
	if i.IdentifierLTE != nil {
		predicates = append(predicates, host.IdentifierLTE(*i.IdentifierLTE))
	}
	if i.IdentifierContains != nil {
		predicates = append(predicates, host.IdentifierContains(*i.IdentifierContains))
	}
	if i.IdentifierHasPrefix != nil {
		predicates = append(predicates, host.IdentifierHasPrefix(*i.IdentifierHasPrefix))
	}
	if i.IdentifierHasSuffix != nil {
		predicates = append(predicates, host.IdentifierHasSuffix(*i.IdentifierHasSuffix))
	}
	if i.IdentifierEqualFold != nil {
		predicates = append(predicates, host.IdentifierEqualFold(*i.IdentifierEqualFold))
	}
	if i.IdentifierContainsFold != nil {
		predicates = append(predicates, host.IdentifierContainsFold(*i.IdentifierContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, host.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, host.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, host.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, host.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, host.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, host.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, host.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, host.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, host.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, host.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, host.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, host.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, host.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, host.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, host.NameContainsFold(*i.NameContainsFold))
	}
	if i.PrimaryIP != nil {
		predicates = append(predicates, host.PrimaryIPEQ(*i.PrimaryIP))
	}
	if i.PrimaryIPNEQ != nil {
		predicates = append(predicates, host.PrimaryIPNEQ(*i.PrimaryIPNEQ))
	}
	if len(i.PrimaryIPIn) > 0 {
		predicates = append(predicates, host.PrimaryIPIn(i.PrimaryIPIn...))
	}
	if len(i.PrimaryIPNotIn) > 0 {
		predicates = append(predicates, host.PrimaryIPNotIn(i.PrimaryIPNotIn...))
	}
	if i.PrimaryIPGT != nil {
		predicates = append(predicates, host.PrimaryIPGT(*i.PrimaryIPGT))
	}
	if i.PrimaryIPGTE != nil {
		predicates = append(predicates, host.PrimaryIPGTE(*i.PrimaryIPGTE))
	}
	if i.PrimaryIPLT != nil {
		predicates = append(predicates, host.PrimaryIPLT(*i.PrimaryIPLT))
	}
	if i.PrimaryIPLTE != nil {
		predicates = append(predicates, host.PrimaryIPLTE(*i.PrimaryIPLTE))
	}
	if i.PrimaryIPContains != nil {
		predicates = append(predicates, host.PrimaryIPContains(*i.PrimaryIPContains))
	}
	if i.PrimaryIPHasPrefix != nil {
		predicates = append(predicates, host.PrimaryIPHasPrefix(*i.PrimaryIPHasPrefix))
	}
	if i.PrimaryIPHasSuffix != nil {
		predicates = append(predicates, host.PrimaryIPHasSuffix(*i.PrimaryIPHasSuffix))
	}
	if i.PrimaryIPIsNil {
		predicates = append(predicates, host.PrimaryIPIsNil())
	}
	if i.PrimaryIPNotNil {
		predicates = append(predicates, host.PrimaryIPNotNil())
	}
	if i.PrimaryIPEqualFold != nil {
		predicates = append(predicates, host.PrimaryIPEqualFold(*i.PrimaryIPEqualFold))
	}
	if i.PrimaryIPContainsFold != nil {
		predicates = append(predicates, host.PrimaryIPContainsFold(*i.PrimaryIPContainsFold))
	}
	if i.ExternalIP != nil {
		predicates = append(predicates, host.ExternalIPEQ(*i.ExternalIP))
	}
	if i.ExternalIPNEQ != nil {
		predicates = append(predicates, host.ExternalIPNEQ(*i.ExternalIPNEQ))
	}
	if len(i.ExternalIPIn) > 0 {
		predicates = append(predicates, host.ExternalIPIn(i.ExternalIPIn...))
	}
	if len(i.ExternalIPNotIn) > 0 {
		predicates = append(predicates, host.ExternalIPNotIn(i.ExternalIPNotIn...))
	}
	if i.ExternalIPGT != nil {
		predicates = append(predicates, host.ExternalIPGT(*i.ExternalIPGT))
	}
	if i.ExternalIPGTE != nil {
		predicates = append(predicates, host.ExternalIPGTE(*i.ExternalIPGTE))
	}
	if i.ExternalIPLT != nil {
		predicates = append(predicates, host.ExternalIPLT(*i.ExternalIPLT))
	}
	if i.ExternalIPLTE != nil {
		predicates = append(predicates, host.ExternalIPLTE(*i.ExternalIPLTE))
	}
	if i.ExternalIPContains != nil {
		predicates = append(predicates, host.ExternalIPContains(*i.ExternalIPContains))
	}
	if i.ExternalIPHasPrefix != nil {
		predicates = append(predicates, host.ExternalIPHasPrefix(*i.ExternalIPHasPrefix))
	}
	if i.ExternalIPHasSuffix != nil {
		predicates = append(predicates, host.ExternalIPHasSuffix(*i.ExternalIPHasSuffix))
	}
	if i.ExternalIPIsNil {
		predicates = append(predicates, host.ExternalIPIsNil())
	}
	if i.ExternalIPNotNil {
		predicates = append(predicates, host.ExternalIPNotNil())
	}
	if i.ExternalIPEqualFold != nil {
		predicates = append(predicates, host.ExternalIPEqualFold(*i.ExternalIPEqualFold))
	}
	if i.ExternalIPContainsFold != nil {
		predicates = append(predicates, host.ExternalIPContainsFold(*i.ExternalIPContainsFold))
	}
	if i.Platform != nil {
		predicates = append(predicates, host.PlatformEQ(*i.Platform))
	}
	if i.PlatformNEQ != nil {
		predicates = append(predicates, host.PlatformNEQ(*i.PlatformNEQ))
	}
	if len(i.PlatformIn) > 0 {
		predicates = append(predicates, host.PlatformIn(i.PlatformIn...))
	}
	if len(i.PlatformNotIn) > 0 {
		predicates = append(predicates, host.PlatformNotIn(i.PlatformNotIn...))
	}
	if i.LastSeenAt != nil {
		predicates = append(predicates, host.LastSeenAtEQ(*i.LastSeenAt))
	}
	if i.LastSeenAtNEQ != nil {
		predicates = append(predicates, host.LastSeenAtNEQ(*i.LastSeenAtNEQ))
	}
	if len(i.LastSeenAtIn) > 0 {
		predicates = append(predicates, host.LastSeenAtIn(i.LastSeenAtIn...))
	}
	if len(i.LastSeenAtNotIn) > 0 {
		predicates = append(predicates, host.LastSeenAtNotIn(i.LastSeenAtNotIn...))
	}
	if i.LastSeenAtGT != nil {
		predicates = append(predicates, host.LastSeenAtGT(*i.LastSeenAtGT))
	}
	if i.LastSeenAtGTE != nil {
		predicates = append(predicates, host.LastSeenAtGTE(*i.LastSeenAtGTE))
	}
	if i.LastSeenAtLT != nil {
		predicates = append(predicates, host.LastSeenAtLT(*i.LastSeenAtLT))
	}
	if i.LastSeenAtLTE != nil {
		predicates = append(predicates, host.LastSeenAtLTE(*i.LastSeenAtLTE))
	}
	if i.LastSeenAtIsNil {
		predicates = append(predicates, host.LastSeenAtIsNil())
	}
	if i.LastSeenAtNotNil {
		predicates = append(predicates, host.LastSeenAtNotNil())
	}
	if i.NextSeenAt != nil {
		predicates = append(predicates, host.NextSeenAtEQ(*i.NextSeenAt))
	}
	if i.NextSeenAtNEQ != nil {
		predicates = append(predicates, host.NextSeenAtNEQ(*i.NextSeenAtNEQ))
	}
	if len(i.NextSeenAtIn) > 0 {
		predicates = append(predicates, host.NextSeenAtIn(i.NextSeenAtIn...))
	}
	if len(i.NextSeenAtNotIn) > 0 {
		predicates = append(predicates, host.NextSeenAtNotIn(i.NextSeenAtNotIn...))
	}
	if i.NextSeenAtGT != nil {
		predicates = append(predicates, host.NextSeenAtGT(*i.NextSeenAtGT))
	}
	if i.NextSeenAtGTE != nil {
		predicates = append(predicates, host.NextSeenAtGTE(*i.NextSeenAtGTE))
	}
	if i.NextSeenAtLT != nil {
		predicates = append(predicates, host.NextSeenAtLT(*i.NextSeenAtLT))
	}
	if i.NextSeenAtLTE != nil {
		predicates = append(predicates, host.NextSeenAtLTE(*i.NextSeenAtLTE))
	}
	if i.NextSeenAtIsNil {
		predicates = append(predicates, host.NextSeenAtIsNil())
	}
	if i.NextSeenAtNotNil {
		predicates = append(predicates, host.NextSeenAtNotNil())
	}

	if i.HasTags != nil {
		p := host.HasTags()
		if !*i.HasTags {
			p = host.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTagsWith) > 0 {
		with := make([]predicate.Tag, 0, len(i.HasTagsWith))
		for _, w := range i.HasTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, host.HasTagsWith(with...))
	}
	if i.HasBeacons != nil {
		p := host.HasBeacons()
		if !*i.HasBeacons {
			p = host.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeaconsWith) > 0 {
		with := make([]predicate.Beacon, 0, len(i.HasBeaconsWith))
		for _, w := range i.HasBeaconsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBeaconsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, host.HasBeaconsWith(with...))
	}
	if i.HasFiles != nil {
		p := host.HasFiles()
		if !*i.HasFiles {
			p = host.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilesWith) > 0 {
		with := make([]predicate.HostFile, 0, len(i.HasFilesWith))
		for _, w := range i.HasFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, host.HasFilesWith(with...))
	}
	if i.HasProcesses != nil {
		p := host.HasProcesses()
		if !*i.HasProcesses {
			p = host.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcessesWith) > 0 {
		with := make([]predicate.HostProcess, 0, len(i.HasProcessesWith))
		for _, w := range i.HasProcessesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcessesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, host.HasProcessesWith(with...))
	}
	if i.HasCredentials != nil {
		p := host.HasCredentials()
		if !*i.HasCredentials {
			p = host.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCredentialsWith) > 0 {
		with := make([]predicate.HostCredential, 0, len(i.HasCredentialsWith))
		for _, w := range i.HasCredentialsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCredentialsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, host.HasCredentialsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return host.And(predicates...), nil
	}
}

// HostCredentialWhereInput represents a where input for filtering HostCredential queries.
type HostCredentialWhereInput struct {
	Predicates []predicate.HostCredential  `json:"-"`
	Not        *HostCredentialWhereInput   `json:"not,omitempty"`
	Or         []*HostCredentialWhereInput `json:"or,omitempty"`
	And        []*HostCredentialWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "principal" field predicates.
	Principal             *string  `json:"principal,omitempty"`
	PrincipalNEQ          *string  `json:"principalNEQ,omitempty"`
	PrincipalIn           []string `json:"principalIn,omitempty"`
	PrincipalNotIn        []string `json:"principalNotIn,omitempty"`
	PrincipalGT           *string  `json:"principalGT,omitempty"`
	PrincipalGTE          *string  `json:"principalGTE,omitempty"`
	PrincipalLT           *string  `json:"principalLT,omitempty"`
	PrincipalLTE          *string  `json:"principalLTE,omitempty"`
	PrincipalContains     *string  `json:"principalContains,omitempty"`
	PrincipalHasPrefix    *string  `json:"principalHasPrefix,omitempty"`
	PrincipalHasSuffix    *string  `json:"principalHasSuffix,omitempty"`
	PrincipalEqualFold    *string  `json:"principalEqualFold,omitempty"`
	PrincipalContainsFold *string  `json:"principalContainsFold,omitempty"`

	// "secret" field predicates.
	Secret             *string  `json:"secret,omitempty"`
	SecretNEQ          *string  `json:"secretNEQ,omitempty"`
	SecretIn           []string `json:"secretIn,omitempty"`
	SecretNotIn        []string `json:"secretNotIn,omitempty"`
	SecretGT           *string  `json:"secretGT,omitempty"`
	SecretGTE          *string  `json:"secretGTE,omitempty"`
	SecretLT           *string  `json:"secretLT,omitempty"`
	SecretLTE          *string  `json:"secretLTE,omitempty"`
	SecretContains     *string  `json:"secretContains,omitempty"`
	SecretHasPrefix    *string  `json:"secretHasPrefix,omitempty"`
	SecretHasSuffix    *string  `json:"secretHasSuffix,omitempty"`
	SecretEqualFold    *string  `json:"secretEqualFold,omitempty"`
	SecretContainsFold *string  `json:"secretContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *epb.Credential_Kind  `json:"kind,omitempty"`
	KindNEQ   *epb.Credential_Kind  `json:"kindNEQ,omitempty"`
	KindIn    []epb.Credential_Kind `json:"kindIn,omitempty"`
	KindNotIn []epb.Credential_Kind `json:"kindNotIn,omitempty"`

	// "host" edge predicates.
	HasHost     *bool             `json:"hasHost,omitempty"`
	HasHostWith []*HostWhereInput `json:"hasHostWith,omitempty"`

	// "task" edge predicates.
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`

	// "shell_task" edge predicates.
	HasShellTask     *bool                  `json:"hasShellTask,omitempty"`
	HasShellTaskWith []*ShellTaskWhereInput `json:"hasShellTaskWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HostCredentialWhereInput) AddPredicates(predicates ...predicate.HostCredential) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HostCredentialWhereInput filter on the HostCredentialQuery builder.
func (i *HostCredentialWhereInput) Filter(q *HostCredentialQuery) (*HostCredentialQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHostCredentialWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHostCredentialWhereInput is returned in case the HostCredentialWhereInput is empty.
var ErrEmptyHostCredentialWhereInput = errors.New("ent: empty predicate HostCredentialWhereInput")

// P returns a predicate for filtering hostcredentials.
// An error is returned if the input is empty or invalid.
func (i *HostCredentialWhereInput) P() (predicate.HostCredential, error) {
	var predicates []predicate.HostCredential
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hostcredential.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HostCredential, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hostcredential.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HostCredential, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hostcredential.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hostcredential.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hostcredential.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hostcredential.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hostcredential.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hostcredential.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hostcredential.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hostcredential.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hostcredential.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hostcredential.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hostcredential.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hostcredential.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hostcredential.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hostcredential.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hostcredential.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hostcredential.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hostcredential.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, hostcredential.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, hostcredential.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, hostcredential.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, hostcredential.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, hostcredential.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, hostcredential.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, hostcredential.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, hostcredential.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Principal != nil {
		predicates = append(predicates, hostcredential.PrincipalEQ(*i.Principal))
	}
	if i.PrincipalNEQ != nil {
		predicates = append(predicates, hostcredential.PrincipalNEQ(*i.PrincipalNEQ))
	}
	if len(i.PrincipalIn) > 0 {
		predicates = append(predicates, hostcredential.PrincipalIn(i.PrincipalIn...))
	}
	if len(i.PrincipalNotIn) > 0 {
		predicates = append(predicates, hostcredential.PrincipalNotIn(i.PrincipalNotIn...))
	}
	if i.PrincipalGT != nil {
		predicates = append(predicates, hostcredential.PrincipalGT(*i.PrincipalGT))
	}
	if i.PrincipalGTE != nil {
		predicates = append(predicates, hostcredential.PrincipalGTE(*i.PrincipalGTE))
	}
	if i.PrincipalLT != nil {
		predicates = append(predicates, hostcredential.PrincipalLT(*i.PrincipalLT))
	}
	if i.PrincipalLTE != nil {
		predicates = append(predicates, hostcredential.PrincipalLTE(*i.PrincipalLTE))
	}
	if i.PrincipalContains != nil {
		predicates = append(predicates, hostcredential.PrincipalContains(*i.PrincipalContains))
	}
	if i.PrincipalHasPrefix != nil {
		predicates = append(predicates, hostcredential.PrincipalHasPrefix(*i.PrincipalHasPrefix))
	}
	if i.PrincipalHasSuffix != nil {
		predicates = append(predicates, hostcredential.PrincipalHasSuffix(*i.PrincipalHasSuffix))
	}
	if i.PrincipalEqualFold != nil {
		predicates = append(predicates, hostcredential.PrincipalEqualFold(*i.PrincipalEqualFold))
	}
	if i.PrincipalContainsFold != nil {
		predicates = append(predicates, hostcredential.PrincipalContainsFold(*i.PrincipalContainsFold))
	}
	if i.Secret != nil {
		predicates = append(predicates, hostcredential.SecretEQ(*i.Secret))
	}
	if i.SecretNEQ != nil {
		predicates = append(predicates, hostcredential.SecretNEQ(*i.SecretNEQ))
	}
	if len(i.SecretIn) > 0 {
		predicates = append(predicates, hostcredential.SecretIn(i.SecretIn...))
	}
	if len(i.SecretNotIn) > 0 {
		predicates = append(predicates, hostcredential.SecretNotIn(i.SecretNotIn...))
	}
	if i.SecretGT != nil {
		predicates = append(predicates, hostcredential.SecretGT(*i.SecretGT))
	}
	if i.SecretGTE != nil {
		predicates = append(predicates, hostcredential.SecretGTE(*i.SecretGTE))
	}
	if i.SecretLT != nil {
		predicates = append(predicates, hostcredential.SecretLT(*i.SecretLT))
	}
	if i.SecretLTE != nil {
		predicates = append(predicates, hostcredential.SecretLTE(*i.SecretLTE))
	}
	if i.SecretContains != nil {
		predicates = append(predicates, hostcredential.SecretContains(*i.SecretContains))
	}
	if i.SecretHasPrefix != nil {
		predicates = append(predicates, hostcredential.SecretHasPrefix(*i.SecretHasPrefix))
	}
	if i.SecretHasSuffix != nil {
		predicates = append(predicates, hostcredential.SecretHasSuffix(*i.SecretHasSuffix))
	}
	if i.SecretEqualFold != nil {
		predicates = append(predicates, hostcredential.SecretEqualFold(*i.SecretEqualFold))
	}
	if i.SecretContainsFold != nil {
		predicates = append(predicates, hostcredential.SecretContainsFold(*i.SecretContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, hostcredential.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, hostcredential.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, hostcredential.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, hostcredential.KindNotIn(i.KindNotIn...))
	}

	if i.HasHost != nil {
		p := hostcredential.HasHost()
		if !*i.HasHost {
			p = hostcredential.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHostWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasHostWith))
		for _, w := range i.HasHostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostcredential.HasHostWith(with...))
	}
	if i.HasTask != nil {
		p := hostcredential.HasTask()
		if !*i.HasTask {
			p = hostcredential.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostcredential.HasTaskWith(with...))
	}
	if i.HasShellTask != nil {
		p := hostcredential.HasShellTask()
		if !*i.HasShellTask {
			p = hostcredential.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShellTaskWith) > 0 {
		with := make([]predicate.ShellTask, 0, len(i.HasShellTaskWith))
		for _, w := range i.HasShellTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShellTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostcredential.HasShellTaskWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHostCredentialWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hostcredential.And(predicates...), nil
	}
}

// HostFileWhereInput represents a where input for filtering HostFile queries.
type HostFileWhereInput struct {
	Predicates []predicate.HostFile  `json:"-"`
	Not        *HostFileWhereInput   `json:"not,omitempty"`
	Or         []*HostFileWhereInput `json:"or,omitempty"`
	And        []*HostFileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "owner" field predicates.
	Owner             *string  `json:"owner,omitempty"`
	OwnerNEQ          *string  `json:"ownerNEQ,omitempty"`
	OwnerIn           []string `json:"ownerIn,omitempty"`
	OwnerNotIn        []string `json:"ownerNotIn,omitempty"`
	OwnerGT           *string  `json:"ownerGT,omitempty"`
	OwnerGTE          *string  `json:"ownerGTE,omitempty"`
	OwnerLT           *string  `json:"ownerLT,omitempty"`
	OwnerLTE          *string  `json:"ownerLTE,omitempty"`
	OwnerContains     *string  `json:"ownerContains,omitempty"`
	OwnerHasPrefix    *string  `json:"ownerHasPrefix,omitempty"`
	OwnerHasSuffix    *string  `json:"ownerHasSuffix,omitempty"`
	OwnerIsNil        bool     `json:"ownerIsNil,omitempty"`
	OwnerNotNil       bool     `json:"ownerNotNil,omitempty"`
	OwnerEqualFold    *string  `json:"ownerEqualFold,omitempty"`
	OwnerContainsFold *string  `json:"ownerContainsFold,omitempty"`

	// "group" field predicates.
	Group             *string  `json:"group,omitempty"`
	GroupNEQ          *string  `json:"groupNEQ,omitempty"`
	GroupIn           []string `json:"groupIn,omitempty"`
	GroupNotIn        []string `json:"groupNotIn,omitempty"`
	GroupGT           *string  `json:"groupGT,omitempty"`
	GroupGTE          *string  `json:"groupGTE,omitempty"`
	GroupLT           *string  `json:"groupLT,omitempty"`
	GroupLTE          *string  `json:"groupLTE,omitempty"`
	GroupContains     *string  `json:"groupContains,omitempty"`
	GroupHasPrefix    *string  `json:"groupHasPrefix,omitempty"`
	GroupHasSuffix    *string  `json:"groupHasSuffix,omitempty"`
	GroupIsNil        bool     `json:"groupIsNil,omitempty"`
	GroupNotNil       bool     `json:"groupNotNil,omitempty"`
	GroupEqualFold    *string  `json:"groupEqualFold,omitempty"`
	GroupContainsFold *string  `json:"groupContainsFold,omitempty"`

	// "permissions" field predicates.
	Permissions             *string  `json:"permissions,omitempty"`
	PermissionsNEQ          *string  `json:"permissionsNEQ,omitempty"`
	PermissionsIn           []string `json:"permissionsIn,omitempty"`
	PermissionsNotIn        []string `json:"permissionsNotIn,omitempty"`
	PermissionsGT           *string  `json:"permissionsGT,omitempty"`
	PermissionsGTE          *string  `json:"permissionsGTE,omitempty"`
	PermissionsLT           *string  `json:"permissionsLT,omitempty"`
	PermissionsLTE          *string  `json:"permissionsLTE,omitempty"`
	PermissionsContains     *string  `json:"permissionsContains,omitempty"`
	PermissionsHasPrefix    *string  `json:"permissionsHasPrefix,omitempty"`
	PermissionsHasSuffix    *string  `json:"permissionsHasSuffix,omitempty"`
	PermissionsIsNil        bool     `json:"permissionsIsNil,omitempty"`
	PermissionsNotNil       bool     `json:"permissionsNotNil,omitempty"`
	PermissionsEqualFold    *string  `json:"permissionsEqualFold,omitempty"`
	PermissionsContainsFold *string  `json:"permissionsContainsFold,omitempty"`

	// "size" field predicates.
	Size      *uint64  `json:"size,omitempty"`
	SizeNEQ   *uint64  `json:"sizeNEQ,omitempty"`
	SizeIn    []uint64 `json:"sizeIn,omitempty"`
	SizeNotIn []uint64 `json:"sizeNotIn,omitempty"`
	SizeGT    *uint64  `json:"sizeGT,omitempty"`
	SizeGTE   *uint64  `json:"sizeGTE,omitempty"`
	SizeLT    *uint64  `json:"sizeLT,omitempty"`
	SizeLTE   *uint64  `json:"sizeLTE,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashIsNil        bool     `json:"hashIsNil,omitempty"`
	HashNotNil       bool     `json:"hashNotNil,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "host" edge predicates.
	HasHost     *bool             `json:"hasHost,omitempty"`
	HasHostWith []*HostWhereInput `json:"hasHostWith,omitempty"`

	// "task" edge predicates.
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`

	// "shell_task" edge predicates.
	HasShellTask     *bool                  `json:"hasShellTask,omitempty"`
	HasShellTaskWith []*ShellTaskWhereInput `json:"hasShellTaskWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HostFileWhereInput) AddPredicates(predicates ...predicate.HostFile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HostFileWhereInput filter on the HostFileQuery builder.
func (i *HostFileWhereInput) Filter(q *HostFileQuery) (*HostFileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHostFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHostFileWhereInput is returned in case the HostFileWhereInput is empty.
var ErrEmptyHostFileWhereInput = errors.New("ent: empty predicate HostFileWhereInput")

// P returns a predicate for filtering hostfiles.
// An error is returned if the input is empty or invalid.
func (i *HostFileWhereInput) P() (predicate.HostFile, error) {
	var predicates []predicate.HostFile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hostfile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HostFile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hostfile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HostFile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hostfile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hostfile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hostfile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hostfile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hostfile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hostfile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hostfile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hostfile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hostfile.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hostfile.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hostfile.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hostfile.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hostfile.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hostfile.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hostfile.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hostfile.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hostfile.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, hostfile.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, hostfile.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, hostfile.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, hostfile.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, hostfile.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, hostfile.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, hostfile.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, hostfile.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Path != nil {
		predicates = append(predicates, hostfile.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, hostfile.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, hostfile.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, hostfile.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, hostfile.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, hostfile.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, hostfile.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, hostfile.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, hostfile.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, hostfile.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, hostfile.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, hostfile.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, hostfile.PathContainsFold(*i.PathContainsFold))
	}
	if i.Owner != nil {
		predicates = append(predicates, hostfile.OwnerEQ(*i.Owner))
	}
	if i.OwnerNEQ != nil {
		predicates = append(predicates, hostfile.OwnerNEQ(*i.OwnerNEQ))
	}
	if len(i.OwnerIn) > 0 {
		predicates = append(predicates, hostfile.OwnerIn(i.OwnerIn...))
	}
	if len(i.OwnerNotIn) > 0 {
		predicates = append(predicates, hostfile.OwnerNotIn(i.OwnerNotIn...))
	}
	if i.OwnerGT != nil {
		predicates = append(predicates, hostfile.OwnerGT(*i.OwnerGT))
	}
	if i.OwnerGTE != nil {
		predicates = append(predicates, hostfile.OwnerGTE(*i.OwnerGTE))
	}
	if i.OwnerLT != nil {
		predicates = append(predicates, hostfile.OwnerLT(*i.OwnerLT))
	}
	if i.OwnerLTE != nil {
		predicates = append(predicates, hostfile.OwnerLTE(*i.OwnerLTE))
	}
	if i.OwnerContains != nil {
		predicates = append(predicates, hostfile.OwnerContains(*i.OwnerContains))
	}
	if i.OwnerHasPrefix != nil {
		predicates = append(predicates, hostfile.OwnerHasPrefix(*i.OwnerHasPrefix))
	}
	if i.OwnerHasSuffix != nil {
		predicates = append(predicates, hostfile.OwnerHasSuffix(*i.OwnerHasSuffix))
	}
	if i.OwnerIsNil {
		predicates = append(predicates, hostfile.OwnerIsNil())
	}
	if i.OwnerNotNil {
		predicates = append(predicates, hostfile.OwnerNotNil())
	}
	if i.OwnerEqualFold != nil {
		predicates = append(predicates, hostfile.OwnerEqualFold(*i.OwnerEqualFold))
	}
	if i.OwnerContainsFold != nil {
		predicates = append(predicates, hostfile.OwnerContainsFold(*i.OwnerContainsFold))
	}
	if i.Group != nil {
		predicates = append(predicates, hostfile.GroupEQ(*i.Group))
	}
	if i.GroupNEQ != nil {
		predicates = append(predicates, hostfile.GroupNEQ(*i.GroupNEQ))
	}
	if len(i.GroupIn) > 0 {
		predicates = append(predicates, hostfile.GroupIn(i.GroupIn...))
	}
	if len(i.GroupNotIn) > 0 {
		predicates = append(predicates, hostfile.GroupNotIn(i.GroupNotIn...))
	}
	if i.GroupGT != nil {
		predicates = append(predicates, hostfile.GroupGT(*i.GroupGT))
	}
	if i.GroupGTE != nil {
		predicates = append(predicates, hostfile.GroupGTE(*i.GroupGTE))
	}
	if i.GroupLT != nil {
		predicates = append(predicates, hostfile.GroupLT(*i.GroupLT))
	}
	if i.GroupLTE != nil {
		predicates = append(predicates, hostfile.GroupLTE(*i.GroupLTE))
	}
	if i.GroupContains != nil {
		predicates = append(predicates, hostfile.GroupContains(*i.GroupContains))
	}
	if i.GroupHasPrefix != nil {
		predicates = append(predicates, hostfile.GroupHasPrefix(*i.GroupHasPrefix))
	}
	if i.GroupHasSuffix != nil {
		predicates = append(predicates, hostfile.GroupHasSuffix(*i.GroupHasSuffix))
	}
	if i.GroupIsNil {
		predicates = append(predicates, hostfile.GroupIsNil())
	}
	if i.GroupNotNil {
		predicates = append(predicates, hostfile.GroupNotNil())
	}
	if i.GroupEqualFold != nil {
		predicates = append(predicates, hostfile.GroupEqualFold(*i.GroupEqualFold))
	}
	if i.GroupContainsFold != nil {
		predicates = append(predicates, hostfile.GroupContainsFold(*i.GroupContainsFold))
	}
	if i.Permissions != nil {
		predicates = append(predicates, hostfile.PermissionsEQ(*i.Permissions))
	}
	if i.PermissionsNEQ != nil {
		predicates = append(predicates, hostfile.PermissionsNEQ(*i.PermissionsNEQ))
	}
	if len(i.PermissionsIn) > 0 {
		predicates = append(predicates, hostfile.PermissionsIn(i.PermissionsIn...))
	}
	if len(i.PermissionsNotIn) > 0 {
		predicates = append(predicates, hostfile.PermissionsNotIn(i.PermissionsNotIn...))
	}
	if i.PermissionsGT != nil {
		predicates = append(predicates, hostfile.PermissionsGT(*i.PermissionsGT))
	}
	if i.PermissionsGTE != nil {
		predicates = append(predicates, hostfile.PermissionsGTE(*i.PermissionsGTE))
	}
	if i.PermissionsLT != nil {
		predicates = append(predicates, hostfile.PermissionsLT(*i.PermissionsLT))
	}
	if i.PermissionsLTE != nil {
		predicates = append(predicates, hostfile.PermissionsLTE(*i.PermissionsLTE))
	}
	if i.PermissionsContains != nil {
		predicates = append(predicates, hostfile.PermissionsContains(*i.PermissionsContains))
	}
	if i.PermissionsHasPrefix != nil {
		predicates = append(predicates, hostfile.PermissionsHasPrefix(*i.PermissionsHasPrefix))
	}
	if i.PermissionsHasSuffix != nil {
		predicates = append(predicates, hostfile.PermissionsHasSuffix(*i.PermissionsHasSuffix))
	}
	if i.PermissionsIsNil {
		predicates = append(predicates, hostfile.PermissionsIsNil())
	}
	if i.PermissionsNotNil {
		predicates = append(predicates, hostfile.PermissionsNotNil())
	}
	if i.PermissionsEqualFold != nil {
		predicates = append(predicates, hostfile.PermissionsEqualFold(*i.PermissionsEqualFold))
	}
	if i.PermissionsContainsFold != nil {
		predicates = append(predicates, hostfile.PermissionsContainsFold(*i.PermissionsContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, hostfile.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, hostfile.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, hostfile.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, hostfile.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, hostfile.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, hostfile.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, hostfile.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, hostfile.SizeLTE(*i.SizeLTE))
	}
	if i.Hash != nil {
		predicates = append(predicates, hostfile.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, hostfile.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, hostfile.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, hostfile.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, hostfile.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, hostfile.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, hostfile.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, hostfile.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, hostfile.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, hostfile.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, hostfile.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashIsNil {
		predicates = append(predicates, hostfile.HashIsNil())
	}
	if i.HashNotNil {
		predicates = append(predicates, hostfile.HashNotNil())
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, hostfile.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, hostfile.HashContainsFold(*i.HashContainsFold))
	}

	if i.HasHost != nil {
		p := hostfile.HasHost()
		if !*i.HasHost {
			p = hostfile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHostWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasHostWith))
		for _, w := range i.HasHostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostfile.HasHostWith(with...))
	}
	if i.HasTask != nil {
		p := hostfile.HasTask()
		if !*i.HasTask {
			p = hostfile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostfile.HasTaskWith(with...))
	}
	if i.HasShellTask != nil {
		p := hostfile.HasShellTask()
		if !*i.HasShellTask {
			p = hostfile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShellTaskWith) > 0 {
		with := make([]predicate.ShellTask, 0, len(i.HasShellTaskWith))
		for _, w := range i.HasShellTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShellTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostfile.HasShellTaskWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHostFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hostfile.And(predicates...), nil
	}
}

// HostProcessWhereInput represents a where input for filtering HostProcess queries.
type HostProcessWhereInput struct {
	Predicates []predicate.HostProcess  `json:"-"`
	Not        *HostProcessWhereInput   `json:"not,omitempty"`
	Or         []*HostProcessWhereInput `json:"or,omitempty"`
	And        []*HostProcessWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "pid" field predicates.
	Pid      *uint64  `json:"pid,omitempty"`
	PidNEQ   *uint64  `json:"pidNEQ,omitempty"`
	PidIn    []uint64 `json:"pidIn,omitempty"`
	PidNotIn []uint64 `json:"pidNotIn,omitempty"`
	PidGT    *uint64  `json:"pidGT,omitempty"`
	PidGTE   *uint64  `json:"pidGTE,omitempty"`
	PidLT    *uint64  `json:"pidLT,omitempty"`
	PidLTE   *uint64  `json:"pidLTE,omitempty"`

	// "ppid" field predicates.
	Ppid      *uint64  `json:"ppid,omitempty"`
	PpidNEQ   *uint64  `json:"ppidNEQ,omitempty"`
	PpidIn    []uint64 `json:"ppidIn,omitempty"`
	PpidNotIn []uint64 `json:"ppidNotIn,omitempty"`
	PpidGT    *uint64  `json:"ppidGT,omitempty"`
	PpidGTE   *uint64  `json:"ppidGTE,omitempty"`
	PpidLT    *uint64  `json:"ppidLT,omitempty"`
	PpidLTE   *uint64  `json:"ppidLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "principal" field predicates.
	Principal             *string  `json:"principal,omitempty"`
	PrincipalNEQ          *string  `json:"principalNEQ,omitempty"`
	PrincipalIn           []string `json:"principalIn,omitempty"`
	PrincipalNotIn        []string `json:"principalNotIn,omitempty"`
	PrincipalGT           *string  `json:"principalGT,omitempty"`
	PrincipalGTE          *string  `json:"principalGTE,omitempty"`
	PrincipalLT           *string  `json:"principalLT,omitempty"`
	PrincipalLTE          *string  `json:"principalLTE,omitempty"`
	PrincipalContains     *string  `json:"principalContains,omitempty"`
	PrincipalHasPrefix    *string  `json:"principalHasPrefix,omitempty"`
	PrincipalHasSuffix    *string  `json:"principalHasSuffix,omitempty"`
	PrincipalEqualFold    *string  `json:"principalEqualFold,omitempty"`
	PrincipalContainsFold *string  `json:"principalContainsFold,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathIsNil        bool     `json:"pathIsNil,omitempty"`
	PathNotNil       bool     `json:"pathNotNil,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "cmd" field predicates.
	Cmd             *string  `json:"cmd,omitempty"`
	CmdNEQ          *string  `json:"cmdNEQ,omitempty"`
	CmdIn           []string `json:"cmdIn,omitempty"`
	CmdNotIn        []string `json:"cmdNotIn,omitempty"`
	CmdGT           *string  `json:"cmdGT,omitempty"`
	CmdGTE          *string  `json:"cmdGTE,omitempty"`
	CmdLT           *string  `json:"cmdLT,omitempty"`
	CmdLTE          *string  `json:"cmdLTE,omitempty"`
	CmdContains     *string  `json:"cmdContains,omitempty"`
	CmdHasPrefix    *string  `json:"cmdHasPrefix,omitempty"`
	CmdHasSuffix    *string  `json:"cmdHasSuffix,omitempty"`
	CmdIsNil        bool     `json:"cmdIsNil,omitempty"`
	CmdNotNil       bool     `json:"cmdNotNil,omitempty"`
	CmdEqualFold    *string  `json:"cmdEqualFold,omitempty"`
	CmdContainsFold *string  `json:"cmdContainsFold,omitempty"`

	// "env" field predicates.
	Env             *string  `json:"env,omitempty"`
	EnvNEQ          *string  `json:"envNEQ,omitempty"`
	EnvIn           []string `json:"envIn,omitempty"`
	EnvNotIn        []string `json:"envNotIn,omitempty"`
	EnvGT           *string  `json:"envGT,omitempty"`
	EnvGTE          *string  `json:"envGTE,omitempty"`
	EnvLT           *string  `json:"envLT,omitempty"`
	EnvLTE          *string  `json:"envLTE,omitempty"`
	EnvContains     *string  `json:"envContains,omitempty"`
	EnvHasPrefix    *string  `json:"envHasPrefix,omitempty"`
	EnvHasSuffix    *string  `json:"envHasSuffix,omitempty"`
	EnvIsNil        bool     `json:"envIsNil,omitempty"`
	EnvNotNil       bool     `json:"envNotNil,omitempty"`
	EnvEqualFold    *string  `json:"envEqualFold,omitempty"`
	EnvContainsFold *string  `json:"envContainsFold,omitempty"`

	// "cwd" field predicates.
	Cwd             *string  `json:"cwd,omitempty"`
	CwdNEQ          *string  `json:"cwdNEQ,omitempty"`
	CwdIn           []string `json:"cwdIn,omitempty"`
	CwdNotIn        []string `json:"cwdNotIn,omitempty"`
	CwdGT           *string  `json:"cwdGT,omitempty"`
	CwdGTE          *string  `json:"cwdGTE,omitempty"`
	CwdLT           *string  `json:"cwdLT,omitempty"`
	CwdLTE          *string  `json:"cwdLTE,omitempty"`
	CwdContains     *string  `json:"cwdContains,omitempty"`
	CwdHasPrefix    *string  `json:"cwdHasPrefix,omitempty"`
	CwdHasSuffix    *string  `json:"cwdHasSuffix,omitempty"`
	CwdIsNil        bool     `json:"cwdIsNil,omitempty"`
	CwdNotNil       bool     `json:"cwdNotNil,omitempty"`
	CwdEqualFold    *string  `json:"cwdEqualFold,omitempty"`
	CwdContainsFold *string  `json:"cwdContainsFold,omitempty"`

	// "status" field predicates.
	Status      *epb.Process_Status  `json:"status,omitempty"`
	StatusNEQ   *epb.Process_Status  `json:"statusNEQ,omitempty"`
	StatusIn    []epb.Process_Status `json:"statusIn,omitempty"`
	StatusNotIn []epb.Process_Status `json:"statusNotIn,omitempty"`

	// "host" edge predicates.
	HasHost     *bool             `json:"hasHost,omitempty"`
	HasHostWith []*HostWhereInput `json:"hasHostWith,omitempty"`

	// "task" edge predicates.
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`

	// "shell_task" edge predicates.
	HasShellTask     *bool                  `json:"hasShellTask,omitempty"`
	HasShellTaskWith []*ShellTaskWhereInput `json:"hasShellTaskWith,omitempty"`

	// "beacon" edge predicates.
	HasBeacon     *bool               `json:"hasBeacon,omitempty"`
	HasBeaconWith []*BeaconWhereInput `json:"hasBeaconWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HostProcessWhereInput) AddPredicates(predicates ...predicate.HostProcess) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HostProcessWhereInput filter on the HostProcessQuery builder.
func (i *HostProcessWhereInput) Filter(q *HostProcessQuery) (*HostProcessQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHostProcessWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHostProcessWhereInput is returned in case the HostProcessWhereInput is empty.
var ErrEmptyHostProcessWhereInput = errors.New("ent: empty predicate HostProcessWhereInput")

// P returns a predicate for filtering hostprocesses.
// An error is returned if the input is empty or invalid.
func (i *HostProcessWhereInput) P() (predicate.HostProcess, error) {
	var predicates []predicate.HostProcess
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hostprocess.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HostProcess, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hostprocess.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HostProcess, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hostprocess.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hostprocess.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hostprocess.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hostprocess.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hostprocess.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hostprocess.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hostprocess.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hostprocess.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hostprocess.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hostprocess.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hostprocess.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hostprocess.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hostprocess.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hostprocess.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hostprocess.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hostprocess.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hostprocess.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, hostprocess.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, hostprocess.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, hostprocess.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, hostprocess.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, hostprocess.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, hostprocess.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, hostprocess.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, hostprocess.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Pid != nil {
		predicates = append(predicates, hostprocess.PidEQ(*i.Pid))
	}
	if i.PidNEQ != nil {
		predicates = append(predicates, hostprocess.PidNEQ(*i.PidNEQ))
	}
	if len(i.PidIn) > 0 {
		predicates = append(predicates, hostprocess.PidIn(i.PidIn...))
	}
	if len(i.PidNotIn) > 0 {
		predicates = append(predicates, hostprocess.PidNotIn(i.PidNotIn...))
	}
	if i.PidGT != nil {
		predicates = append(predicates, hostprocess.PidGT(*i.PidGT))
	}
	if i.PidGTE != nil {
		predicates = append(predicates, hostprocess.PidGTE(*i.PidGTE))
	}
	if i.PidLT != nil {
		predicates = append(predicates, hostprocess.PidLT(*i.PidLT))
	}
	if i.PidLTE != nil {
		predicates = append(predicates, hostprocess.PidLTE(*i.PidLTE))
	}
	if i.Ppid != nil {
		predicates = append(predicates, hostprocess.PpidEQ(*i.Ppid))
	}
	if i.PpidNEQ != nil {
		predicates = append(predicates, hostprocess.PpidNEQ(*i.PpidNEQ))
	}
	if len(i.PpidIn) > 0 {
		predicates = append(predicates, hostprocess.PpidIn(i.PpidIn...))
	}
	if len(i.PpidNotIn) > 0 {
		predicates = append(predicates, hostprocess.PpidNotIn(i.PpidNotIn...))
	}
	if i.PpidGT != nil {
		predicates = append(predicates, hostprocess.PpidGT(*i.PpidGT))
	}
	if i.PpidGTE != nil {
		predicates = append(predicates, hostprocess.PpidGTE(*i.PpidGTE))
	}
	if i.PpidLT != nil {
		predicates = append(predicates, hostprocess.PpidLT(*i.PpidLT))
	}
	if i.PpidLTE != nil {
		predicates = append(predicates, hostprocess.PpidLTE(*i.PpidLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, hostprocess.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, hostprocess.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, hostprocess.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, hostprocess.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, hostprocess.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, hostprocess.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, hostprocess.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, hostprocess.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, hostprocess.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, hostprocess.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, hostprocess.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, hostprocess.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, hostprocess.NameContainsFold(*i.NameContainsFold))
	}
	if i.Principal != nil {
		predicates = append(predicates, hostprocess.PrincipalEQ(*i.Principal))
	}
	if i.PrincipalNEQ != nil {
		predicates = append(predicates, hostprocess.PrincipalNEQ(*i.PrincipalNEQ))
	}
	if len(i.PrincipalIn) > 0 {
		predicates = append(predicates, hostprocess.PrincipalIn(i.PrincipalIn...))
	}
	if len(i.PrincipalNotIn) > 0 {
		predicates = append(predicates, hostprocess.PrincipalNotIn(i.PrincipalNotIn...))
	}
	if i.PrincipalGT != nil {
		predicates = append(predicates, hostprocess.PrincipalGT(*i.PrincipalGT))
	}
	if i.PrincipalGTE != nil {
		predicates = append(predicates, hostprocess.PrincipalGTE(*i.PrincipalGTE))
	}
	if i.PrincipalLT != nil {
		predicates = append(predicates, hostprocess.PrincipalLT(*i.PrincipalLT))
	}
	if i.PrincipalLTE != nil {
		predicates = append(predicates, hostprocess.PrincipalLTE(*i.PrincipalLTE))
	}
	if i.PrincipalContains != nil {
		predicates = append(predicates, hostprocess.PrincipalContains(*i.PrincipalContains))
	}
	if i.PrincipalHasPrefix != nil {
		predicates = append(predicates, hostprocess.PrincipalHasPrefix(*i.PrincipalHasPrefix))
	}
	if i.PrincipalHasSuffix != nil {
		predicates = append(predicates, hostprocess.PrincipalHasSuffix(*i.PrincipalHasSuffix))
	}
	if i.PrincipalEqualFold != nil {
		predicates = append(predicates, hostprocess.PrincipalEqualFold(*i.PrincipalEqualFold))
	}
	if i.PrincipalContainsFold != nil {
		predicates = append(predicates, hostprocess.PrincipalContainsFold(*i.PrincipalContainsFold))
	}
	if i.Path != nil {
		predicates = append(predicates, hostprocess.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, hostprocess.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, hostprocess.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, hostprocess.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, hostprocess.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, hostprocess.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, hostprocess.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, hostprocess.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, hostprocess.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, hostprocess.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, hostprocess.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathIsNil {
		predicates = append(predicates, hostprocess.PathIsNil())
	}
	if i.PathNotNil {
		predicates = append(predicates, hostprocess.PathNotNil())
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, hostprocess.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, hostprocess.PathContainsFold(*i.PathContainsFold))
	}
	if i.Cmd != nil {
		predicates = append(predicates, hostprocess.CmdEQ(*i.Cmd))
	}
	if i.CmdNEQ != nil {
		predicates = append(predicates, hostprocess.CmdNEQ(*i.CmdNEQ))
	}
	if len(i.CmdIn) > 0 {
		predicates = append(predicates, hostprocess.CmdIn(i.CmdIn...))
	}
	if len(i.CmdNotIn) > 0 {
		predicates = append(predicates, hostprocess.CmdNotIn(i.CmdNotIn...))
	}
	if i.CmdGT != nil {
		predicates = append(predicates, hostprocess.CmdGT(*i.CmdGT))
	}
	if i.CmdGTE != nil {
		predicates = append(predicates, hostprocess.CmdGTE(*i.CmdGTE))
	}
	if i.CmdLT != nil {
		predicates = append(predicates, hostprocess.CmdLT(*i.CmdLT))
	}
	if i.CmdLTE != nil {
		predicates = append(predicates, hostprocess.CmdLTE(*i.CmdLTE))
	}
	if i.CmdContains != nil {
		predicates = append(predicates, hostprocess.CmdContains(*i.CmdContains))
	}
	if i.CmdHasPrefix != nil {
		predicates = append(predicates, hostprocess.CmdHasPrefix(*i.CmdHasPrefix))
	}
	if i.CmdHasSuffix != nil {
		predicates = append(predicates, hostprocess.CmdHasSuffix(*i.CmdHasSuffix))
	}
	if i.CmdIsNil {
		predicates = append(predicates, hostprocess.CmdIsNil())
	}
	if i.CmdNotNil {
		predicates = append(predicates, hostprocess.CmdNotNil())
	}
	if i.CmdEqualFold != nil {
		predicates = append(predicates, hostprocess.CmdEqualFold(*i.CmdEqualFold))
	}
	if i.CmdContainsFold != nil {
		predicates = append(predicates, hostprocess.CmdContainsFold(*i.CmdContainsFold))
	}
	if i.Env != nil {
		predicates = append(predicates, hostprocess.EnvEQ(*i.Env))
	}
	if i.EnvNEQ != nil {
		predicates = append(predicates, hostprocess.EnvNEQ(*i.EnvNEQ))
	}
	if len(i.EnvIn) > 0 {
		predicates = append(predicates, hostprocess.EnvIn(i.EnvIn...))
	}
	if len(i.EnvNotIn) > 0 {
		predicates = append(predicates, hostprocess.EnvNotIn(i.EnvNotIn...))
	}
	if i.EnvGT != nil {
		predicates = append(predicates, hostprocess.EnvGT(*i.EnvGT))
	}
	if i.EnvGTE != nil {
		predicates = append(predicates, hostprocess.EnvGTE(*i.EnvGTE))
	}
	if i.EnvLT != nil {
		predicates = append(predicates, hostprocess.EnvLT(*i.EnvLT))
	}
	if i.EnvLTE != nil {
		predicates = append(predicates, hostprocess.EnvLTE(*i.EnvLTE))
	}
	if i.EnvContains != nil {
		predicates = append(predicates, hostprocess.EnvContains(*i.EnvContains))
	}
	if i.EnvHasPrefix != nil {
		predicates = append(predicates, hostprocess.EnvHasPrefix(*i.EnvHasPrefix))
	}
	if i.EnvHasSuffix != nil {
		predicates = append(predicates, hostprocess.EnvHasSuffix(*i.EnvHasSuffix))
	}
	if i.EnvIsNil {
		predicates = append(predicates, hostprocess.EnvIsNil())
	}
	if i.EnvNotNil {
		predicates = append(predicates, hostprocess.EnvNotNil())
	}
	if i.EnvEqualFold != nil {
		predicates = append(predicates, hostprocess.EnvEqualFold(*i.EnvEqualFold))
	}
	if i.EnvContainsFold != nil {
		predicates = append(predicates, hostprocess.EnvContainsFold(*i.EnvContainsFold))
	}
	if i.Cwd != nil {
		predicates = append(predicates, hostprocess.CwdEQ(*i.Cwd))
	}
	if i.CwdNEQ != nil {
		predicates = append(predicates, hostprocess.CwdNEQ(*i.CwdNEQ))
	}
	if len(i.CwdIn) > 0 {
		predicates = append(predicates, hostprocess.CwdIn(i.CwdIn...))
	}
	if len(i.CwdNotIn) > 0 {
		predicates = append(predicates, hostprocess.CwdNotIn(i.CwdNotIn...))
	}
	if i.CwdGT != nil {
		predicates = append(predicates, hostprocess.CwdGT(*i.CwdGT))
	}
	if i.CwdGTE != nil {
		predicates = append(predicates, hostprocess.CwdGTE(*i.CwdGTE))
	}
	if i.CwdLT != nil {
		predicates = append(predicates, hostprocess.CwdLT(*i.CwdLT))
	}
	if i.CwdLTE != nil {
		predicates = append(predicates, hostprocess.CwdLTE(*i.CwdLTE))
	}
	if i.CwdContains != nil {
		predicates = append(predicates, hostprocess.CwdContains(*i.CwdContains))
	}
	if i.CwdHasPrefix != nil {
		predicates = append(predicates, hostprocess.CwdHasPrefix(*i.CwdHasPrefix))
	}
	if i.CwdHasSuffix != nil {
		predicates = append(predicates, hostprocess.CwdHasSuffix(*i.CwdHasSuffix))
	}
	if i.CwdIsNil {
		predicates = append(predicates, hostprocess.CwdIsNil())
	}
	if i.CwdNotNil {
		predicates = append(predicates, hostprocess.CwdNotNil())
	}
	if i.CwdEqualFold != nil {
		predicates = append(predicates, hostprocess.CwdEqualFold(*i.CwdEqualFold))
	}
	if i.CwdContainsFold != nil {
		predicates = append(predicates, hostprocess.CwdContainsFold(*i.CwdContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, hostprocess.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, hostprocess.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, hostprocess.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, hostprocess.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasHost != nil {
		p := hostprocess.HasHost()
		if !*i.HasHost {
			p = hostprocess.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHostWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasHostWith))
		for _, w := range i.HasHostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostprocess.HasHostWith(with...))
	}
	if i.HasTask != nil {
		p := hostprocess.HasTask()
		if !*i.HasTask {
			p = hostprocess.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostprocess.HasTaskWith(with...))
	}
	if i.HasShellTask != nil {
		p := hostprocess.HasShellTask()
		if !*i.HasShellTask {
			p = hostprocess.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShellTaskWith) > 0 {
		with := make([]predicate.ShellTask, 0, len(i.HasShellTaskWith))
		for _, w := range i.HasShellTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShellTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostprocess.HasShellTaskWith(with...))
	}
	if i.HasBeacon != nil {
		p := hostprocess.HasBeacon()
		if !*i.HasBeacon {
			p = hostprocess.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeaconWith) > 0 {
		with := make([]predicate.Beacon, 0, len(i.HasBeaconWith))
		for _, w := range i.HasBeaconWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBeaconWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hostprocess.HasBeaconWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHostProcessWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hostprocess.And(predicates...), nil
	}
}

// LinkWhereInput represents a where input for filtering Link queries.
type LinkWhereInput struct {
	Predicates []predicate.Link  `json:"-"`
	Not        *LinkWhereInput   `json:"not,omitempty"`
	Or         []*LinkWhereInput `json:"or,omitempty"`
	And        []*LinkWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt      *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ   *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn    []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT    *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE   *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT    *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE   *time.Time  `json:"expiresAtLTE,omitempty"`

	// "download_limit" field predicates.
	DownloadLimit       *int  `json:"downloadLimit,omitempty"`
	DownloadLimitNEQ    *int  `json:"downloadLimitNEQ,omitempty"`
	DownloadLimitIn     []int `json:"downloadLimitIn,omitempty"`
	DownloadLimitNotIn  []int `json:"downloadLimitNotIn,omitempty"`
	DownloadLimitGT     *int  `json:"downloadLimitGT,omitempty"`
	DownloadLimitGTE    *int  `json:"downloadLimitGTE,omitempty"`
	DownloadLimitLT     *int  `json:"downloadLimitLT,omitempty"`
	DownloadLimitLTE    *int  `json:"downloadLimitLTE,omitempty"`
	DownloadLimitIsNil  bool  `json:"downloadLimitIsNil,omitempty"`
	DownloadLimitNotNil bool  `json:"downloadLimitNotNil,omitempty"`

	// "downloads" field predicates.
	Downloads      *int  `json:"downloads,omitempty"`
	DownloadsNEQ   *int  `json:"downloadsNEQ,omitempty"`
	DownloadsIn    []int `json:"downloadsIn,omitempty"`
	DownloadsNotIn []int `json:"downloadsNotIn,omitempty"`
	DownloadsGT    *int  `json:"downloadsGT,omitempty"`
	DownloadsGTE   *int  `json:"downloadsGTE,omitempty"`
	DownloadsLT    *int  `json:"downloadsLT,omitempty"`
	DownloadsLTE   *int  `json:"downloadsLTE,omitempty"`

	// "asset" edge predicates.
	HasAsset     *bool              `json:"hasAsset,omitempty"`
	HasAssetWith []*AssetWhereInput `json:"hasAssetWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LinkWhereInput) AddPredicates(predicates ...predicate.Link) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LinkWhereInput filter on the LinkQuery builder.
func (i *LinkWhereInput) Filter(q *LinkQuery) (*LinkQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLinkWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLinkWhereInput is returned in case the LinkWhereInput is empty.
var ErrEmptyLinkWhereInput = errors.New("ent: empty predicate LinkWhereInput")

// P returns a predicate for filtering links.
// An error is returned if the input is empty or invalid.
func (i *LinkWhereInput) P() (predicate.Link, error) {
	var predicates []predicate.Link
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, link.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Link, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, link.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Link, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, link.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, link.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, link.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, link.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, link.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, link.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, link.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, link.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, link.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, link.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, link.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, link.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, link.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, link.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, link.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, link.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, link.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, link.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, link.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, link.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, link.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, link.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, link.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, link.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, link.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Path != nil {
		predicates = append(predicates, link.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, link.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, link.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, link.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, link.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, link.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, link.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, link.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, link.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, link.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, link.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, link.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, link.PathContainsFold(*i.PathContainsFold))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, link.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, link.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, link.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, link.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, link.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, link.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, link.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, link.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.DownloadLimit != nil {
		predicates = append(predicates, link.DownloadLimitEQ(*i.DownloadLimit))
	}
	if i.DownloadLimitNEQ != nil {
		predicates = append(predicates, link.DownloadLimitNEQ(*i.DownloadLimitNEQ))
	}
	if len(i.DownloadLimitIn) > 0 {
		predicates = append(predicates, link.DownloadLimitIn(i.DownloadLimitIn...))
	}
	if len(i.DownloadLimitNotIn) > 0 {
		predicates = append(predicates, link.DownloadLimitNotIn(i.DownloadLimitNotIn...))
	}
	if i.DownloadLimitGT != nil {
		predicates = append(predicates, link.DownloadLimitGT(*i.DownloadLimitGT))
	}
	if i.DownloadLimitGTE != nil {
		predicates = append(predicates, link.DownloadLimitGTE(*i.DownloadLimitGTE))
	}
	if i.DownloadLimitLT != nil {
		predicates = append(predicates, link.DownloadLimitLT(*i.DownloadLimitLT))
	}
	if i.DownloadLimitLTE != nil {
		predicates = append(predicates, link.DownloadLimitLTE(*i.DownloadLimitLTE))
	}
	if i.DownloadLimitIsNil {
		predicates = append(predicates, link.DownloadLimitIsNil())
	}
	if i.DownloadLimitNotNil {
		predicates = append(predicates, link.DownloadLimitNotNil())
	}
	if i.Downloads != nil {
		predicates = append(predicates, link.DownloadsEQ(*i.Downloads))
	}
	if i.DownloadsNEQ != nil {
		predicates = append(predicates, link.DownloadsNEQ(*i.DownloadsNEQ))
	}
	if len(i.DownloadsIn) > 0 {
		predicates = append(predicates, link.DownloadsIn(i.DownloadsIn...))
	}
	if len(i.DownloadsNotIn) > 0 {
		predicates = append(predicates, link.DownloadsNotIn(i.DownloadsNotIn...))
	}
	if i.DownloadsGT != nil {
		predicates = append(predicates, link.DownloadsGT(*i.DownloadsGT))
	}
	if i.DownloadsGTE != nil {
		predicates = append(predicates, link.DownloadsGTE(*i.DownloadsGTE))
	}
	if i.DownloadsLT != nil {
		predicates = append(predicates, link.DownloadsLT(*i.DownloadsLT))
	}
	if i.DownloadsLTE != nil {
		predicates = append(predicates, link.DownloadsLTE(*i.DownloadsLTE))
	}

	if i.HasAsset != nil {
		p := link.HasAsset()
		if !*i.HasAsset {
			p = link.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssetWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasAssetWith))
		for _, w := range i.HasAssetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, link.HasAssetWith(with...))
	}
	if i.HasCreator != nil {
		p := link.HasCreator()
		if !*i.HasCreator {
			p = link.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, link.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLinkWhereInput
	case 1:
		return predicates[0], nil
	default:
		return link.And(predicates...), nil
	}
}

// PortalWhereInput represents a where input for filtering Portal queries.
type PortalWhereInput struct {
	Predicates []predicate.Portal  `json:"-"`
	Not        *PortalWhereInput   `json:"not,omitempty"`
	Or         []*PortalWhereInput `json:"or,omitempty"`
	And        []*PortalWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "closed_at" field predicates.
	ClosedAt       *time.Time  `json:"closedAt,omitempty"`
	ClosedAtNEQ    *time.Time  `json:"closedAtNEQ,omitempty"`
	ClosedAtIn     []time.Time `json:"closedAtIn,omitempty"`
	ClosedAtNotIn  []time.Time `json:"closedAtNotIn,omitempty"`
	ClosedAtGT     *time.Time  `json:"closedAtGT,omitempty"`
	ClosedAtGTE    *time.Time  `json:"closedAtGTE,omitempty"`
	ClosedAtLT     *time.Time  `json:"closedAtLT,omitempty"`
	ClosedAtLTE    *time.Time  `json:"closedAtLTE,omitempty"`
	ClosedAtIsNil  bool        `json:"closedAtIsNil,omitempty"`
	ClosedAtNotNil bool        `json:"closedAtNotNil,omitempty"`

	// "task" edge predicates.
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`

	// "shell_task" edge predicates.
	HasShellTask     *bool                  `json:"hasShellTask,omitempty"`
	HasShellTaskWith []*ShellTaskWhereInput `json:"hasShellTaskWith,omitempty"`

	// "beacon" edge predicates.
	HasBeacon     *bool               `json:"hasBeacon,omitempty"`
	HasBeaconWith []*BeaconWhereInput `json:"hasBeaconWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`

	// "active_users" edge predicates.
	HasActiveUsers     *bool             `json:"hasActiveUsers,omitempty"`
	HasActiveUsersWith []*UserWhereInput `json:"hasActiveUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PortalWhereInput) AddPredicates(predicates ...predicate.Portal) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PortalWhereInput filter on the PortalQuery builder.
func (i *PortalWhereInput) Filter(q *PortalQuery) (*PortalQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPortalWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPortalWhereInput is returned in case the PortalWhereInput is empty.
var ErrEmptyPortalWhereInput = errors.New("ent: empty predicate PortalWhereInput")

// P returns a predicate for filtering portals.
// An error is returned if the input is empty or invalid.
func (i *PortalWhereInput) P() (predicate.Portal, error) {
	var predicates []predicate.Portal
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, portal.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Portal, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, portal.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Portal, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, portal.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, portal.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, portal.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, portal.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, portal.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, portal.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, portal.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, portal.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, portal.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, portal.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, portal.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, portal.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, portal.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, portal.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, portal.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, portal.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, portal.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, portal.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, portal.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, portal.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, portal.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, portal.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, portal.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, portal.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, portal.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.ClosedAt != nil {
		predicates = append(predicates, portal.ClosedAtEQ(*i.ClosedAt))
	}
	if i.ClosedAtNEQ != nil {
		predicates = append(predicates, portal.ClosedAtNEQ(*i.ClosedAtNEQ))
	}
	if len(i.ClosedAtIn) > 0 {
		predicates = append(predicates, portal.ClosedAtIn(i.ClosedAtIn...))
	}
	if len(i.ClosedAtNotIn) > 0 {
		predicates = append(predicates, portal.ClosedAtNotIn(i.ClosedAtNotIn...))
	}
	if i.ClosedAtGT != nil {
		predicates = append(predicates, portal.ClosedAtGT(*i.ClosedAtGT))
	}
	if i.ClosedAtGTE != nil {
		predicates = append(predicates, portal.ClosedAtGTE(*i.ClosedAtGTE))
	}
	if i.ClosedAtLT != nil {
		predicates = append(predicates, portal.ClosedAtLT(*i.ClosedAtLT))
	}
	if i.ClosedAtLTE != nil {
		predicates = append(predicates, portal.ClosedAtLTE(*i.ClosedAtLTE))
	}
	if i.ClosedAtIsNil {
		predicates = append(predicates, portal.ClosedAtIsNil())
	}
	if i.ClosedAtNotNil {
		predicates = append(predicates, portal.ClosedAtNotNil())
	}

	if i.HasTask != nil {
		p := portal.HasTask()
		if !*i.HasTask {
			p = portal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, portal.HasTaskWith(with...))
	}
	if i.HasShellTask != nil {
		p := portal.HasShellTask()
		if !*i.HasShellTask {
			p = portal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShellTaskWith) > 0 {
		with := make([]predicate.ShellTask, 0, len(i.HasShellTaskWith))
		for _, w := range i.HasShellTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShellTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, portal.HasShellTaskWith(with...))
	}
	if i.HasBeacon != nil {
		p := portal.HasBeacon()
		if !*i.HasBeacon {
			p = portal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeaconWith) > 0 {
		with := make([]predicate.Beacon, 0, len(i.HasBeaconWith))
		for _, w := range i.HasBeaconWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBeaconWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, portal.HasBeaconWith(with...))
	}
	if i.HasOwner != nil {
		p := portal.HasOwner()
		if !*i.HasOwner {
			p = portal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, portal.HasOwnerWith(with...))
	}
	if i.HasActiveUsers != nil {
		p := portal.HasActiveUsers()
		if !*i.HasActiveUsers {
			p = portal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActiveUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasActiveUsersWith))
		for _, w := range i.HasActiveUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActiveUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, portal.HasActiveUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPortalWhereInput
	case 1:
		return predicates[0], nil
	default:
		return portal.And(predicates...), nil
	}
}

// QuestWhereInput represents a where input for filtering Quest queries.
type QuestWhereInput struct {
	Predicates []predicate.Quest  `json:"-"`
	Not        *QuestWhereInput   `json:"not,omitempty"`
	Or         []*QuestWhereInput `json:"or,omitempty"`
	And        []*QuestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "parameters" field predicates.
	Parameters             *string  `json:"parameters,omitempty"`
	ParametersNEQ          *string  `json:"parametersNEQ,omitempty"`
	ParametersIn           []string `json:"parametersIn,omitempty"`
	ParametersNotIn        []string `json:"parametersNotIn,omitempty"`
	ParametersGT           *string  `json:"parametersGT,omitempty"`
	ParametersGTE          *string  `json:"parametersGTE,omitempty"`
	ParametersLT           *string  `json:"parametersLT,omitempty"`
	ParametersLTE          *string  `json:"parametersLTE,omitempty"`
	ParametersContains     *string  `json:"parametersContains,omitempty"`
	ParametersHasPrefix    *string  `json:"parametersHasPrefix,omitempty"`
	ParametersHasSuffix    *string  `json:"parametersHasSuffix,omitempty"`
	ParametersIsNil        bool     `json:"parametersIsNil,omitempty"`
	ParametersNotNil       bool     `json:"parametersNotNil,omitempty"`
	ParametersEqualFold    *string  `json:"parametersEqualFold,omitempty"`
	ParametersContainsFold *string  `json:"parametersContainsFold,omitempty"`

	// "param_defs_at_creation" field predicates.
	ParamDefsAtCreation             *string  `json:"paramDefsAtCreation,omitempty"`
	ParamDefsAtCreationNEQ          *string  `json:"paramDefsAtCreationNEQ,omitempty"`
	ParamDefsAtCreationIn           []string `json:"paramDefsAtCreationIn,omitempty"`
	ParamDefsAtCreationNotIn        []string `json:"paramDefsAtCreationNotIn,omitempty"`
	ParamDefsAtCreationGT           *string  `json:"paramDefsAtCreationGT,omitempty"`
	ParamDefsAtCreationGTE          *string  `json:"paramDefsAtCreationGTE,omitempty"`
	ParamDefsAtCreationLT           *string  `json:"paramDefsAtCreationLT,omitempty"`
	ParamDefsAtCreationLTE          *string  `json:"paramDefsAtCreationLTE,omitempty"`
	ParamDefsAtCreationContains     *string  `json:"paramDefsAtCreationContains,omitempty"`
	ParamDefsAtCreationHasPrefix    *string  `json:"paramDefsAtCreationHasPrefix,omitempty"`
	ParamDefsAtCreationHasSuffix    *string  `json:"paramDefsAtCreationHasSuffix,omitempty"`
	ParamDefsAtCreationIsNil        bool     `json:"paramDefsAtCreationIsNil,omitempty"`
	ParamDefsAtCreationNotNil       bool     `json:"paramDefsAtCreationNotNil,omitempty"`
	ParamDefsAtCreationEqualFold    *string  `json:"paramDefsAtCreationEqualFold,omitempty"`
	ParamDefsAtCreationContainsFold *string  `json:"paramDefsAtCreationContainsFold,omitempty"`

	// "eldritch_at_creation" field predicates.
	EldritchAtCreation             *string  `json:"eldritchAtCreation,omitempty"`
	EldritchAtCreationNEQ          *string  `json:"eldritchAtCreationNEQ,omitempty"`
	EldritchAtCreationIn           []string `json:"eldritchAtCreationIn,omitempty"`
	EldritchAtCreationNotIn        []string `json:"eldritchAtCreationNotIn,omitempty"`
	EldritchAtCreationGT           *string  `json:"eldritchAtCreationGT,omitempty"`
	EldritchAtCreationGTE          *string  `json:"eldritchAtCreationGTE,omitempty"`
	EldritchAtCreationLT           *string  `json:"eldritchAtCreationLT,omitempty"`
	EldritchAtCreationLTE          *string  `json:"eldritchAtCreationLTE,omitempty"`
	EldritchAtCreationContains     *string  `json:"eldritchAtCreationContains,omitempty"`
	EldritchAtCreationHasPrefix    *string  `json:"eldritchAtCreationHasPrefix,omitempty"`
	EldritchAtCreationHasSuffix    *string  `json:"eldritchAtCreationHasSuffix,omitempty"`
	EldritchAtCreationIsNil        bool     `json:"eldritchAtCreationIsNil,omitempty"`
	EldritchAtCreationNotNil       bool     `json:"eldritchAtCreationNotNil,omitempty"`
	EldritchAtCreationEqualFold    *string  `json:"eldritchAtCreationEqualFold,omitempty"`
	EldritchAtCreationContainsFold *string  `json:"eldritchAtCreationContainsFold,omitempty"`

	// "tome" edge predicates.
	HasTome     *bool             `json:"hasTome,omitempty"`
	HasTomeWith []*TomeWhereInput `json:"hasTomeWith,omitempty"`

	// "bundle" edge predicates.
	HasBundle     *bool              `json:"hasBundle,omitempty"`
	HasBundleWith []*AssetWhereInput `json:"hasBundleWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *QuestWhereInput) AddPredicates(predicates ...predicate.Quest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the QuestWhereInput filter on the QuestQuery builder.
func (i *QuestWhereInput) Filter(q *QuestQuery) (*QuestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyQuestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyQuestWhereInput is returned in case the QuestWhereInput is empty.
var ErrEmptyQuestWhereInput = errors.New("ent: empty predicate QuestWhereInput")

// P returns a predicate for filtering quests.
// An error is returned if the input is empty or invalid.
func (i *QuestWhereInput) P() (predicate.Quest, error) {
	var predicates []predicate.Quest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, quest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Quest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, quest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Quest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, quest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, quest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, quest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, quest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, quest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, quest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, quest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, quest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, quest.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, quest.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, quest.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, quest.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, quest.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, quest.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, quest.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, quest.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, quest.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, quest.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, quest.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, quest.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, quest.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, quest.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, quest.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, quest.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, quest.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, quest.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, quest.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, quest.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, quest.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, quest.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, quest.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, quest.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, quest.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, quest.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, quest.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, quest.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, quest.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, quest.NameContainsFold(*i.NameContainsFold))
	}
	if i.Parameters != nil {
		predicates = append(predicates, quest.ParametersEQ(*i.Parameters))
	}
	if i.ParametersNEQ != nil {
		predicates = append(predicates, quest.ParametersNEQ(*i.ParametersNEQ))
	}
	if len(i.ParametersIn) > 0 {
		predicates = append(predicates, quest.ParametersIn(i.ParametersIn...))
	}
	if len(i.ParametersNotIn) > 0 {
		predicates = append(predicates, quest.ParametersNotIn(i.ParametersNotIn...))
	}
	if i.ParametersGT != nil {
		predicates = append(predicates, quest.ParametersGT(*i.ParametersGT))
	}
	if i.ParametersGTE != nil {
		predicates = append(predicates, quest.ParametersGTE(*i.ParametersGTE))
	}
	if i.ParametersLT != nil {
		predicates = append(predicates, quest.ParametersLT(*i.ParametersLT))
	}
	if i.ParametersLTE != nil {
		predicates = append(predicates, quest.ParametersLTE(*i.ParametersLTE))
	}
	if i.ParametersContains != nil {
		predicates = append(predicates, quest.ParametersContains(*i.ParametersContains))
	}
	if i.ParametersHasPrefix != nil {
		predicates = append(predicates, quest.ParametersHasPrefix(*i.ParametersHasPrefix))
	}
	if i.ParametersHasSuffix != nil {
		predicates = append(predicates, quest.ParametersHasSuffix(*i.ParametersHasSuffix))
	}
	if i.ParametersIsNil {
		predicates = append(predicates, quest.ParametersIsNil())
	}
	if i.ParametersNotNil {
		predicates = append(predicates, quest.ParametersNotNil())
	}
	if i.ParametersEqualFold != nil {
		predicates = append(predicates, quest.ParametersEqualFold(*i.ParametersEqualFold))
	}
	if i.ParametersContainsFold != nil {
		predicates = append(predicates, quest.ParametersContainsFold(*i.ParametersContainsFold))
	}
	if i.ParamDefsAtCreation != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationEQ(*i.ParamDefsAtCreation))
	}
	if i.ParamDefsAtCreationNEQ != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationNEQ(*i.ParamDefsAtCreationNEQ))
	}
	if len(i.ParamDefsAtCreationIn) > 0 {
		predicates = append(predicates, quest.ParamDefsAtCreationIn(i.ParamDefsAtCreationIn...))
	}
	if len(i.ParamDefsAtCreationNotIn) > 0 {
		predicates = append(predicates, quest.ParamDefsAtCreationNotIn(i.ParamDefsAtCreationNotIn...))
	}
	if i.ParamDefsAtCreationGT != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationGT(*i.ParamDefsAtCreationGT))
	}
	if i.ParamDefsAtCreationGTE != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationGTE(*i.ParamDefsAtCreationGTE))
	}
	if i.ParamDefsAtCreationLT != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationLT(*i.ParamDefsAtCreationLT))
	}
	if i.ParamDefsAtCreationLTE != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationLTE(*i.ParamDefsAtCreationLTE))
	}
	if i.ParamDefsAtCreationContains != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationContains(*i.ParamDefsAtCreationContains))
	}
	if i.ParamDefsAtCreationHasPrefix != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationHasPrefix(*i.ParamDefsAtCreationHasPrefix))
	}
	if i.ParamDefsAtCreationHasSuffix != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationHasSuffix(*i.ParamDefsAtCreationHasSuffix))
	}
	if i.ParamDefsAtCreationIsNil {
		predicates = append(predicates, quest.ParamDefsAtCreationIsNil())
	}
	if i.ParamDefsAtCreationNotNil {
		predicates = append(predicates, quest.ParamDefsAtCreationNotNil())
	}
	if i.ParamDefsAtCreationEqualFold != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationEqualFold(*i.ParamDefsAtCreationEqualFold))
	}
	if i.ParamDefsAtCreationContainsFold != nil {
		predicates = append(predicates, quest.ParamDefsAtCreationContainsFold(*i.ParamDefsAtCreationContainsFold))
	}
	if i.EldritchAtCreation != nil {
		predicates = append(predicates, quest.EldritchAtCreationEQ(*i.EldritchAtCreation))
	}
	if i.EldritchAtCreationNEQ != nil {
		predicates = append(predicates, quest.EldritchAtCreationNEQ(*i.EldritchAtCreationNEQ))
	}
	if len(i.EldritchAtCreationIn) > 0 {
		predicates = append(predicates, quest.EldritchAtCreationIn(i.EldritchAtCreationIn...))
	}
	if len(i.EldritchAtCreationNotIn) > 0 {
		predicates = append(predicates, quest.EldritchAtCreationNotIn(i.EldritchAtCreationNotIn...))
	}
	if i.EldritchAtCreationGT != nil {
		predicates = append(predicates, quest.EldritchAtCreationGT(*i.EldritchAtCreationGT))
	}
	if i.EldritchAtCreationGTE != nil {
		predicates = append(predicates, quest.EldritchAtCreationGTE(*i.EldritchAtCreationGTE))
	}
	if i.EldritchAtCreationLT != nil {
		predicates = append(predicates, quest.EldritchAtCreationLT(*i.EldritchAtCreationLT))
	}
	if i.EldritchAtCreationLTE != nil {
		predicates = append(predicates, quest.EldritchAtCreationLTE(*i.EldritchAtCreationLTE))
	}
	if i.EldritchAtCreationContains != nil {
		predicates = append(predicates, quest.EldritchAtCreationContains(*i.EldritchAtCreationContains))
	}
	if i.EldritchAtCreationHasPrefix != nil {
		predicates = append(predicates, quest.EldritchAtCreationHasPrefix(*i.EldritchAtCreationHasPrefix))
	}
	if i.EldritchAtCreationHasSuffix != nil {
		predicates = append(predicates, quest.EldritchAtCreationHasSuffix(*i.EldritchAtCreationHasSuffix))
	}
	if i.EldritchAtCreationIsNil {
		predicates = append(predicates, quest.EldritchAtCreationIsNil())
	}
	if i.EldritchAtCreationNotNil {
		predicates = append(predicates, quest.EldritchAtCreationNotNil())
	}
	if i.EldritchAtCreationEqualFold != nil {
		predicates = append(predicates, quest.EldritchAtCreationEqualFold(*i.EldritchAtCreationEqualFold))
	}
	if i.EldritchAtCreationContainsFold != nil {
		predicates = append(predicates, quest.EldritchAtCreationContainsFold(*i.EldritchAtCreationContainsFold))
	}

	if i.HasTome != nil {
		p := quest.HasTome()
		if !*i.HasTome {
			p = quest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTomeWith) > 0 {
		with := make([]predicate.Tome, 0, len(i.HasTomeWith))
		for _, w := range i.HasTomeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTomeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, quest.HasTomeWith(with...))
	}
	if i.HasBundle != nil {
		p := quest.HasBundle()
		if !*i.HasBundle {
			p = quest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBundleWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasBundleWith))
		for _, w := range i.HasBundleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBundleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, quest.HasBundleWith(with...))
	}
	if i.HasTasks != nil {
		p := quest.HasTasks()
		if !*i.HasTasks {
			p = quest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, quest.HasTasksWith(with...))
	}
	if i.HasCreator != nil {
		p := quest.HasCreator()
		if !*i.HasCreator {
			p = quest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, quest.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyQuestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return quest.And(predicates...), nil
	}
}

// RepositoryWhereInput represents a where input for filtering Repository queries.
type RepositoryWhereInput struct {
	Predicates []predicate.Repository  `json:"-"`
	Not        *RepositoryWhereInput   `json:"not,omitempty"`
	Or         []*RepositoryWhereInput `json:"or,omitempty"`
	And        []*RepositoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "public_key" field predicates.
	PublicKey             *string  `json:"publicKey,omitempty"`
	PublicKeyNEQ          *string  `json:"publicKeyNEQ,omitempty"`
	PublicKeyIn           []string `json:"publicKeyIn,omitempty"`
	PublicKeyNotIn        []string `json:"publicKeyNotIn,omitempty"`
	PublicKeyGT           *string  `json:"publicKeyGT,omitempty"`
	PublicKeyGTE          *string  `json:"publicKeyGTE,omitempty"`
	PublicKeyLT           *string  `json:"publicKeyLT,omitempty"`
	PublicKeyLTE          *string  `json:"publicKeyLTE,omitempty"`
	PublicKeyContains     *string  `json:"publicKeyContains,omitempty"`
	PublicKeyHasPrefix    *string  `json:"publicKeyHasPrefix,omitempty"`
	PublicKeyHasSuffix    *string  `json:"publicKeyHasSuffix,omitempty"`
	PublicKeyEqualFold    *string  `json:"publicKeyEqualFold,omitempty"`
	PublicKeyContainsFold *string  `json:"publicKeyContainsFold,omitempty"`

	// "last_imported_at" field predicates.
	LastImportedAt       *time.Time  `json:"lastImportedAt,omitempty"`
	LastImportedAtNEQ    *time.Time  `json:"lastImportedAtNEQ,omitempty"`
	LastImportedAtIn     []time.Time `json:"lastImportedAtIn,omitempty"`
	LastImportedAtNotIn  []time.Time `json:"lastImportedAtNotIn,omitempty"`
	LastImportedAtGT     *time.Time  `json:"lastImportedAtGT,omitempty"`
	LastImportedAtGTE    *time.Time  `json:"lastImportedAtGTE,omitempty"`
	LastImportedAtLT     *time.Time  `json:"lastImportedAtLT,omitempty"`
	LastImportedAtLTE    *time.Time  `json:"lastImportedAtLTE,omitempty"`
	LastImportedAtIsNil  bool        `json:"lastImportedAtIsNil,omitempty"`
	LastImportedAtNotNil bool        `json:"lastImportedAtNotNil,omitempty"`

	// "tomes" edge predicates.
	HasTomes     *bool             `json:"hasTomes,omitempty"`
	HasTomesWith []*TomeWhereInput `json:"hasTomesWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RepositoryWhereInput) AddPredicates(predicates ...predicate.Repository) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RepositoryWhereInput filter on the RepositoryQuery builder.
func (i *RepositoryWhereInput) Filter(q *RepositoryQuery) (*RepositoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRepositoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRepositoryWhereInput is returned in case the RepositoryWhereInput is empty.
var ErrEmptyRepositoryWhereInput = errors.New("ent: empty predicate RepositoryWhereInput")

// P returns a predicate for filtering repositories.
// An error is returned if the input is empty or invalid.
func (i *RepositoryWhereInput) P() (predicate.Repository, error) {
	var predicates []predicate.Repository
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, repository.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Repository, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, repository.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Repository, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, repository.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, repository.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, repository.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, repository.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, repository.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, repository.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, repository.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, repository.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, repository.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, repository.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, repository.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, repository.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, repository.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, repository.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, repository.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, repository.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, repository.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, repository.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, repository.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, repository.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, repository.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, repository.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, repository.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, repository.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, repository.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.URL != nil {
		predicates = append(predicates, repository.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, repository.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, repository.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, repository.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, repository.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, repository.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, repository.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, repository.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, repository.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, repository.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, repository.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, repository.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, repository.URLContainsFold(*i.URLContainsFold))
	}
	if i.PublicKey != nil {
		predicates = append(predicates, repository.PublicKeyEQ(*i.PublicKey))
	}
	if i.PublicKeyNEQ != nil {
		predicates = append(predicates, repository.PublicKeyNEQ(*i.PublicKeyNEQ))
	}
	if len(i.PublicKeyIn) > 0 {
		predicates = append(predicates, repository.PublicKeyIn(i.PublicKeyIn...))
	}
	if len(i.PublicKeyNotIn) > 0 {
		predicates = append(predicates, repository.PublicKeyNotIn(i.PublicKeyNotIn...))
	}
	if i.PublicKeyGT != nil {
		predicates = append(predicates, repository.PublicKeyGT(*i.PublicKeyGT))
	}
	if i.PublicKeyGTE != nil {
		predicates = append(predicates, repository.PublicKeyGTE(*i.PublicKeyGTE))
	}
	if i.PublicKeyLT != nil {
		predicates = append(predicates, repository.PublicKeyLT(*i.PublicKeyLT))
	}
	if i.PublicKeyLTE != nil {
		predicates = append(predicates, repository.PublicKeyLTE(*i.PublicKeyLTE))
	}
	if i.PublicKeyContains != nil {
		predicates = append(predicates, repository.PublicKeyContains(*i.PublicKeyContains))
	}
	if i.PublicKeyHasPrefix != nil {
		predicates = append(predicates, repository.PublicKeyHasPrefix(*i.PublicKeyHasPrefix))
	}
	if i.PublicKeyHasSuffix != nil {
		predicates = append(predicates, repository.PublicKeyHasSuffix(*i.PublicKeyHasSuffix))
	}
	if i.PublicKeyEqualFold != nil {
		predicates = append(predicates, repository.PublicKeyEqualFold(*i.PublicKeyEqualFold))
	}
	if i.PublicKeyContainsFold != nil {
		predicates = append(predicates, repository.PublicKeyContainsFold(*i.PublicKeyContainsFold))
	}
	if i.LastImportedAt != nil {
		predicates = append(predicates, repository.LastImportedAtEQ(*i.LastImportedAt))
	}
	if i.LastImportedAtNEQ != nil {
		predicates = append(predicates, repository.LastImportedAtNEQ(*i.LastImportedAtNEQ))
	}
	if len(i.LastImportedAtIn) > 0 {
		predicates = append(predicates, repository.LastImportedAtIn(i.LastImportedAtIn...))
	}
	if len(i.LastImportedAtNotIn) > 0 {
		predicates = append(predicates, repository.LastImportedAtNotIn(i.LastImportedAtNotIn...))
	}
	if i.LastImportedAtGT != nil {
		predicates = append(predicates, repository.LastImportedAtGT(*i.LastImportedAtGT))
	}
	if i.LastImportedAtGTE != nil {
		predicates = append(predicates, repository.LastImportedAtGTE(*i.LastImportedAtGTE))
	}
	if i.LastImportedAtLT != nil {
		predicates = append(predicates, repository.LastImportedAtLT(*i.LastImportedAtLT))
	}
	if i.LastImportedAtLTE != nil {
		predicates = append(predicates, repository.LastImportedAtLTE(*i.LastImportedAtLTE))
	}
	if i.LastImportedAtIsNil {
		predicates = append(predicates, repository.LastImportedAtIsNil())
	}
	if i.LastImportedAtNotNil {
		predicates = append(predicates, repository.LastImportedAtNotNil())
	}

	if i.HasTomes != nil {
		p := repository.HasTomes()
		if !*i.HasTomes {
			p = repository.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTomesWith) > 0 {
		with := make([]predicate.Tome, 0, len(i.HasTomesWith))
		for _, w := range i.HasTomesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTomesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, repository.HasTomesWith(with...))
	}
	if i.HasOwner != nil {
		p := repository.HasOwner()
		if !*i.HasOwner {
			p = repository.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, repository.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRepositoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return repository.And(predicates...), nil
	}
}

// ShellWhereInput represents a where input for filtering Shell queries.
type ShellWhereInput struct {
	Predicates []predicate.Shell  `json:"-"`
	Not        *ShellWhereInput   `json:"not,omitempty"`
	Or         []*ShellWhereInput `json:"or,omitempty"`
	And        []*ShellWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "closed_at" field predicates.
	ClosedAt       *time.Time  `json:"closedAt,omitempty"`
	ClosedAtNEQ    *time.Time  `json:"closedAtNEQ,omitempty"`
	ClosedAtIn     []time.Time `json:"closedAtIn,omitempty"`
	ClosedAtNotIn  []time.Time `json:"closedAtNotIn,omitempty"`
	ClosedAtGT     *time.Time  `json:"closedAtGT,omitempty"`
	ClosedAtGTE    *time.Time  `json:"closedAtGTE,omitempty"`
	ClosedAtLT     *time.Time  `json:"closedAtLT,omitempty"`
	ClosedAtLTE    *time.Time  `json:"closedAtLTE,omitempty"`
	ClosedAtIsNil  bool        `json:"closedAtIsNil,omitempty"`
	ClosedAtNotNil bool        `json:"closedAtNotNil,omitempty"`

	// "task" edge predicates.
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`

	// "beacon" edge predicates.
	HasBeacon     *bool               `json:"hasBeacon,omitempty"`
	HasBeaconWith []*BeaconWhereInput `json:"hasBeaconWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`

	// "portals" edge predicates.
	HasPortals     *bool               `json:"hasPortals,omitempty"`
	HasPortalsWith []*PortalWhereInput `json:"hasPortalsWith,omitempty"`

	// "active_users" edge predicates.
	HasActiveUsers     *bool             `json:"hasActiveUsers,omitempty"`
	HasActiveUsersWith []*UserWhereInput `json:"hasActiveUsersWith,omitempty"`

	// "shell_tasks" edge predicates.
	HasShellTasks     *bool                  `json:"hasShellTasks,omitempty"`
	HasShellTasksWith []*ShellTaskWhereInput `json:"hasShellTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShellWhereInput) AddPredicates(predicates ...predicate.Shell) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShellWhereInput filter on the ShellQuery builder.
func (i *ShellWhereInput) Filter(q *ShellQuery) (*ShellQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShellWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShellWhereInput is returned in case the ShellWhereInput is empty.
var ErrEmptyShellWhereInput = errors.New("ent: empty predicate ShellWhereInput")

// P returns a predicate for filtering shells.
// An error is returned if the input is empty or invalid.
func (i *ShellWhereInput) P() (predicate.Shell, error) {
	var predicates []predicate.Shell
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shell.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Shell, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shell.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Shell, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shell.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shell.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shell.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shell.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shell.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shell.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shell.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shell.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shell.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, shell.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, shell.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, shell.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, shell.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, shell.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, shell.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, shell.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, shell.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, shell.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, shell.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, shell.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, shell.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, shell.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, shell.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, shell.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, shell.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.ClosedAt != nil {
		predicates = append(predicates, shell.ClosedAtEQ(*i.ClosedAt))
	}
	if i.ClosedAtNEQ != nil {
		predicates = append(predicates, shell.ClosedAtNEQ(*i.ClosedAtNEQ))
	}
	if len(i.ClosedAtIn) > 0 {
		predicates = append(predicates, shell.ClosedAtIn(i.ClosedAtIn...))
	}
	if len(i.ClosedAtNotIn) > 0 {
		predicates = append(predicates, shell.ClosedAtNotIn(i.ClosedAtNotIn...))
	}
	if i.ClosedAtGT != nil {
		predicates = append(predicates, shell.ClosedAtGT(*i.ClosedAtGT))
	}
	if i.ClosedAtGTE != nil {
		predicates = append(predicates, shell.ClosedAtGTE(*i.ClosedAtGTE))
	}
	if i.ClosedAtLT != nil {
		predicates = append(predicates, shell.ClosedAtLT(*i.ClosedAtLT))
	}
	if i.ClosedAtLTE != nil {
		predicates = append(predicates, shell.ClosedAtLTE(*i.ClosedAtLTE))
	}
	if i.ClosedAtIsNil {
		predicates = append(predicates, shell.ClosedAtIsNil())
	}
	if i.ClosedAtNotNil {
		predicates = append(predicates, shell.ClosedAtNotNil())
	}

	if i.HasTask != nil {
		p := shell.HasTask()
		if !*i.HasTask {
			p = shell.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shell.HasTaskWith(with...))
	}
	if i.HasBeacon != nil {
		p := shell.HasBeacon()
		if !*i.HasBeacon {
			p = shell.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeaconWith) > 0 {
		with := make([]predicate.Beacon, 0, len(i.HasBeaconWith))
		for _, w := range i.HasBeaconWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBeaconWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shell.HasBeaconWith(with...))
	}
	if i.HasOwner != nil {
		p := shell.HasOwner()
		if !*i.HasOwner {
			p = shell.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shell.HasOwnerWith(with...))
	}
	if i.HasPortals != nil {
		p := shell.HasPortals()
		if !*i.HasPortals {
			p = shell.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPortalsWith) > 0 {
		with := make([]predicate.Portal, 0, len(i.HasPortalsWith))
		for _, w := range i.HasPortalsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPortalsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shell.HasPortalsWith(with...))
	}
	if i.HasActiveUsers != nil {
		p := shell.HasActiveUsers()
		if !*i.HasActiveUsers {
			p = shell.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActiveUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasActiveUsersWith))
		for _, w := range i.HasActiveUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActiveUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shell.HasActiveUsersWith(with...))
	}
	if i.HasShellTasks != nil {
		p := shell.HasShellTasks()
		if !*i.HasShellTasks {
			p = shell.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShellTasksWith) > 0 {
		with := make([]predicate.ShellTask, 0, len(i.HasShellTasksWith))
		for _, w := range i.HasShellTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShellTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shell.HasShellTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShellWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shell.And(predicates...), nil
	}
}

// ShellTaskWhereInput represents a where input for filtering ShellTask queries.
type ShellTaskWhereInput struct {
	Predicates []predicate.ShellTask  `json:"-"`
	Not        *ShellTaskWhereInput   `json:"not,omitempty"`
	Or         []*ShellTaskWhereInput `json:"or,omitempty"`
	And        []*ShellTaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "input" field predicates.
	Input             *string  `json:"input,omitempty"`
	InputNEQ          *string  `json:"inputNEQ,omitempty"`
	InputIn           []string `json:"inputIn,omitempty"`
	InputNotIn        []string `json:"inputNotIn,omitempty"`
	InputGT           *string  `json:"inputGT,omitempty"`
	InputGTE          *string  `json:"inputGTE,omitempty"`
	InputLT           *string  `json:"inputLT,omitempty"`
	InputLTE          *string  `json:"inputLTE,omitempty"`
	InputContains     *string  `json:"inputContains,omitempty"`
	InputHasPrefix    *string  `json:"inputHasPrefix,omitempty"`
	InputHasSuffix    *string  `json:"inputHasSuffix,omitempty"`
	InputEqualFold    *string  `json:"inputEqualFold,omitempty"`
	InputContainsFold *string  `json:"inputContainsFold,omitempty"`

	// "output" field predicates.
	Output             *string  `json:"output,omitempty"`
	OutputNEQ          *string  `json:"outputNEQ,omitempty"`
	OutputIn           []string `json:"outputIn,omitempty"`
	OutputNotIn        []string `json:"outputNotIn,omitempty"`
	OutputGT           *string  `json:"outputGT,omitempty"`
	OutputGTE          *string  `json:"outputGTE,omitempty"`
	OutputLT           *string  `json:"outputLT,omitempty"`
	OutputLTE          *string  `json:"outputLTE,omitempty"`
	OutputContains     *string  `json:"outputContains,omitempty"`
	OutputHasPrefix    *string  `json:"outputHasPrefix,omitempty"`
	OutputHasSuffix    *string  `json:"outputHasSuffix,omitempty"`
	OutputIsNil        bool     `json:"outputIsNil,omitempty"`
	OutputNotNil       bool     `json:"outputNotNil,omitempty"`
	OutputEqualFold    *string  `json:"outputEqualFold,omitempty"`
	OutputContainsFold *string  `json:"outputContainsFold,omitempty"`

	// "error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        bool     `json:"errorIsNil,omitempty"`
	ErrorNotNil       bool     `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`

	// "stream_id" field predicates.
	StreamID             *string  `json:"streamID,omitempty"`
	StreamIDNEQ          *string  `json:"streamIDNEQ,omitempty"`
	StreamIDIn           []string `json:"streamIDIn,omitempty"`
	StreamIDNotIn        []string `json:"streamIDNotIn,omitempty"`
	StreamIDGT           *string  `json:"streamIDGT,omitempty"`
	StreamIDGTE          *string  `json:"streamIDGTE,omitempty"`
	StreamIDLT           *string  `json:"streamIDLT,omitempty"`
	StreamIDLTE          *string  `json:"streamIDLTE,omitempty"`
	StreamIDContains     *string  `json:"streamIDContains,omitempty"`
	StreamIDHasPrefix    *string  `json:"streamIDHasPrefix,omitempty"`
	StreamIDHasSuffix    *string  `json:"streamIDHasSuffix,omitempty"`
	StreamIDEqualFold    *string  `json:"streamIDEqualFold,omitempty"`
	StreamIDContainsFold *string  `json:"streamIDContainsFold,omitempty"`

	// "sequence_id" field predicates.
	SequenceID      *uint64  `json:"sequenceID,omitempty"`
	SequenceIDNEQ   *uint64  `json:"sequenceIDNEQ,omitempty"`
	SequenceIDIn    []uint64 `json:"sequenceIDIn,omitempty"`
	SequenceIDNotIn []uint64 `json:"sequenceIDNotIn,omitempty"`
	SequenceIDGT    *uint64  `json:"sequenceIDGT,omitempty"`
	SequenceIDGTE   *uint64  `json:"sequenceIDGTE,omitempty"`
	SequenceIDLT    *uint64  `json:"sequenceIDLT,omitempty"`
	SequenceIDLTE   *uint64  `json:"sequenceIDLTE,omitempty"`

	// "claimed_at" field predicates.
	ClaimedAt       *time.Time  `json:"claimedAt,omitempty"`
	ClaimedAtNEQ    *time.Time  `json:"claimedAtNEQ,omitempty"`
	ClaimedAtIn     []time.Time `json:"claimedAtIn,omitempty"`
	ClaimedAtNotIn  []time.Time `json:"claimedAtNotIn,omitempty"`
	ClaimedAtGT     *time.Time  `json:"claimedAtGT,omitempty"`
	ClaimedAtGTE    *time.Time  `json:"claimedAtGTE,omitempty"`
	ClaimedAtLT     *time.Time  `json:"claimedAtLT,omitempty"`
	ClaimedAtLTE    *time.Time  `json:"claimedAtLTE,omitempty"`
	ClaimedAtIsNil  bool        `json:"claimedAtIsNil,omitempty"`
	ClaimedAtNotNil bool        `json:"claimedAtNotNil,omitempty"`

	// "exec_started_at" field predicates.
	ExecStartedAt       *time.Time  `json:"execStartedAt,omitempty"`
	ExecStartedAtNEQ    *time.Time  `json:"execStartedAtNEQ,omitempty"`
	ExecStartedAtIn     []time.Time `json:"execStartedAtIn,omitempty"`
	ExecStartedAtNotIn  []time.Time `json:"execStartedAtNotIn,omitempty"`
	ExecStartedAtGT     *time.Time  `json:"execStartedAtGT,omitempty"`
	ExecStartedAtGTE    *time.Time  `json:"execStartedAtGTE,omitempty"`
	ExecStartedAtLT     *time.Time  `json:"execStartedAtLT,omitempty"`
	ExecStartedAtLTE    *time.Time  `json:"execStartedAtLTE,omitempty"`
	ExecStartedAtIsNil  bool        `json:"execStartedAtIsNil,omitempty"`
	ExecStartedAtNotNil bool        `json:"execStartedAtNotNil,omitempty"`

	// "exec_finished_at" field predicates.
	ExecFinishedAt       *time.Time  `json:"execFinishedAt,omitempty"`
	ExecFinishedAtNEQ    *time.Time  `json:"execFinishedAtNEQ,omitempty"`
	ExecFinishedAtIn     []time.Time `json:"execFinishedAtIn,omitempty"`
	ExecFinishedAtNotIn  []time.Time `json:"execFinishedAtNotIn,omitempty"`
	ExecFinishedAtGT     *time.Time  `json:"execFinishedAtGT,omitempty"`
	ExecFinishedAtGTE    *time.Time  `json:"execFinishedAtGTE,omitempty"`
	ExecFinishedAtLT     *time.Time  `json:"execFinishedAtLT,omitempty"`
	ExecFinishedAtLTE    *time.Time  `json:"execFinishedAtLTE,omitempty"`
	ExecFinishedAtIsNil  bool        `json:"execFinishedAtIsNil,omitempty"`
	ExecFinishedAtNotNil bool        `json:"execFinishedAtNotNil,omitempty"`

	// "shell" edge predicates.
	HasShell     *bool              `json:"hasShell,omitempty"`
	HasShellWith []*ShellWhereInput `json:"hasShellWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "reported_credentials" edge predicates.
	HasReportedCredentials     *bool                       `json:"hasReportedCredentials,omitempty"`
	HasReportedCredentialsWith []*HostCredentialWhereInput `json:"hasReportedCredentialsWith,omitempty"`

	// "reported_files" edge predicates.
	HasReportedFiles     *bool                 `json:"hasReportedFiles,omitempty"`
	HasReportedFilesWith []*HostFileWhereInput `json:"hasReportedFilesWith,omitempty"`

	// "reported_processes" edge predicates.
	HasReportedProcesses     *bool                    `json:"hasReportedProcesses,omitempty"`
	HasReportedProcessesWith []*HostProcessWhereInput `json:"hasReportedProcessesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShellTaskWhereInput) AddPredicates(predicates ...predicate.ShellTask) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShellTaskWhereInput filter on the ShellTaskQuery builder.
func (i *ShellTaskWhereInput) Filter(q *ShellTaskQuery) (*ShellTaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShellTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShellTaskWhereInput is returned in case the ShellTaskWhereInput is empty.
var ErrEmptyShellTaskWhereInput = errors.New("ent: empty predicate ShellTaskWhereInput")

// P returns a predicate for filtering shelltasks.
// An error is returned if the input is empty or invalid.
func (i *ShellTaskWhereInput) P() (predicate.ShellTask, error) {
	var predicates []predicate.ShellTask
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shelltask.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShellTask, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shelltask.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShellTask, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shelltask.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shelltask.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shelltask.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shelltask.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shelltask.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shelltask.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shelltask.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shelltask.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shelltask.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, shelltask.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, shelltask.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, shelltask.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, shelltask.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, shelltask.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, shelltask.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, shelltask.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, shelltask.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, shelltask.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, shelltask.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, shelltask.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, shelltask.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, shelltask.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, shelltask.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, shelltask.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, shelltask.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Input != nil {
		predicates = append(predicates, shelltask.InputEQ(*i.Input))
	}
	if i.InputNEQ != nil {
		predicates = append(predicates, shelltask.InputNEQ(*i.InputNEQ))
	}
	if len(i.InputIn) > 0 {
		predicates = append(predicates, shelltask.InputIn(i.InputIn...))
	}
	if len(i.InputNotIn) > 0 {
		predicates = append(predicates, shelltask.InputNotIn(i.InputNotIn...))
	}
	if i.InputGT != nil {
		predicates = append(predicates, shelltask.InputGT(*i.InputGT))
	}
	if i.InputGTE != nil {
		predicates = append(predicates, shelltask.InputGTE(*i.InputGTE))
	}
	if i.InputLT != nil {
		predicates = append(predicates, shelltask.InputLT(*i.InputLT))
	}
	if i.InputLTE != nil {
		predicates = append(predicates, shelltask.InputLTE(*i.InputLTE))
	}
	if i.InputContains != nil {
		predicates = append(predicates, shelltask.InputContains(*i.InputContains))
	}
	if i.InputHasPrefix != nil {
		predicates = append(predicates, shelltask.InputHasPrefix(*i.InputHasPrefix))
	}
	if i.InputHasSuffix != nil {
		predicates = append(predicates, shelltask.InputHasSuffix(*i.InputHasSuffix))
	}
	if i.InputEqualFold != nil {
		predicates = append(predicates, shelltask.InputEqualFold(*i.InputEqualFold))
	}
	if i.InputContainsFold != nil {
		predicates = append(predicates, shelltask.InputContainsFold(*i.InputContainsFold))
	}
	if i.Output != nil {
		predicates = append(predicates, shelltask.OutputEQ(*i.Output))
	}
	if i.OutputNEQ != nil {
		predicates = append(predicates, shelltask.OutputNEQ(*i.OutputNEQ))
	}
	if len(i.OutputIn) > 0 {
		predicates = append(predicates, shelltask.OutputIn(i.OutputIn...))
	}
	if len(i.OutputNotIn) > 0 {
		predicates = append(predicates, shelltask.OutputNotIn(i.OutputNotIn...))
	}
	if i.OutputGT != nil {
		predicates = append(predicates, shelltask.OutputGT(*i.OutputGT))
	}
	if i.OutputGTE != nil {
		predicates = append(predicates, shelltask.OutputGTE(*i.OutputGTE))
	}
	if i.OutputLT != nil {
		predicates = append(predicates, shelltask.OutputLT(*i.OutputLT))
	}
	if i.OutputLTE != nil {
		predicates = append(predicates, shelltask.OutputLTE(*i.OutputLTE))
	}
	if i.OutputContains != nil {
		predicates = append(predicates, shelltask.OutputContains(*i.OutputContains))
	}
	if i.OutputHasPrefix != nil {
		predicates = append(predicates, shelltask.OutputHasPrefix(*i.OutputHasPrefix))
	}
	if i.OutputHasSuffix != nil {
		predicates = append(predicates, shelltask.OutputHasSuffix(*i.OutputHasSuffix))
	}
	if i.OutputIsNil {
		predicates = append(predicates, shelltask.OutputIsNil())
	}
	if i.OutputNotNil {
		predicates = append(predicates, shelltask.OutputNotNil())
	}
	if i.OutputEqualFold != nil {
		predicates = append(predicates, shelltask.OutputEqualFold(*i.OutputEqualFold))
	}
	if i.OutputContainsFold != nil {
		predicates = append(predicates, shelltask.OutputContainsFold(*i.OutputContainsFold))
	}
	if i.Error != nil {
		predicates = append(predicates, shelltask.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, shelltask.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, shelltask.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, shelltask.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, shelltask.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, shelltask.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, shelltask.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, shelltask.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, shelltask.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, shelltask.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, shelltask.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorIsNil {
		predicates = append(predicates, shelltask.ErrorIsNil())
	}
	if i.ErrorNotNil {
		predicates = append(predicates, shelltask.ErrorNotNil())
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, shelltask.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, shelltask.ErrorContainsFold(*i.ErrorContainsFold))
	}
	if i.StreamID != nil {
		predicates = append(predicates, shelltask.StreamIDEQ(*i.StreamID))
	}
	if i.StreamIDNEQ != nil {
		predicates = append(predicates, shelltask.StreamIDNEQ(*i.StreamIDNEQ))
	}
	if len(i.StreamIDIn) > 0 {
		predicates = append(predicates, shelltask.StreamIDIn(i.StreamIDIn...))
	}
	if len(i.StreamIDNotIn) > 0 {
		predicates = append(predicates, shelltask.StreamIDNotIn(i.StreamIDNotIn...))
	}
	if i.StreamIDGT != nil {
		predicates = append(predicates, shelltask.StreamIDGT(*i.StreamIDGT))
	}
	if i.StreamIDGTE != nil {
		predicates = append(predicates, shelltask.StreamIDGTE(*i.StreamIDGTE))
	}
	if i.StreamIDLT != nil {
		predicates = append(predicates, shelltask.StreamIDLT(*i.StreamIDLT))
	}
	if i.StreamIDLTE != nil {
		predicates = append(predicates, shelltask.StreamIDLTE(*i.StreamIDLTE))
	}
	if i.StreamIDContains != nil {
		predicates = append(predicates, shelltask.StreamIDContains(*i.StreamIDContains))
	}
	if i.StreamIDHasPrefix != nil {
		predicates = append(predicates, shelltask.StreamIDHasPrefix(*i.StreamIDHasPrefix))
	}
	if i.StreamIDHasSuffix != nil {
		predicates = append(predicates, shelltask.StreamIDHasSuffix(*i.StreamIDHasSuffix))
	}
	if i.StreamIDEqualFold != nil {
		predicates = append(predicates, shelltask.StreamIDEqualFold(*i.StreamIDEqualFold))
	}
	if i.StreamIDContainsFold != nil {
		predicates = append(predicates, shelltask.StreamIDContainsFold(*i.StreamIDContainsFold))
	}
	if i.SequenceID != nil {
		predicates = append(predicates, shelltask.SequenceIDEQ(*i.SequenceID))
	}
	if i.SequenceIDNEQ != nil {
		predicates = append(predicates, shelltask.SequenceIDNEQ(*i.SequenceIDNEQ))
	}
	if len(i.SequenceIDIn) > 0 {
		predicates = append(predicates, shelltask.SequenceIDIn(i.SequenceIDIn...))
	}
	if len(i.SequenceIDNotIn) > 0 {
		predicates = append(predicates, shelltask.SequenceIDNotIn(i.SequenceIDNotIn...))
	}
	if i.SequenceIDGT != nil {
		predicates = append(predicates, shelltask.SequenceIDGT(*i.SequenceIDGT))
	}
	if i.SequenceIDGTE != nil {
		predicates = append(predicates, shelltask.SequenceIDGTE(*i.SequenceIDGTE))
	}
	if i.SequenceIDLT != nil {
		predicates = append(predicates, shelltask.SequenceIDLT(*i.SequenceIDLT))
	}
	if i.SequenceIDLTE != nil {
		predicates = append(predicates, shelltask.SequenceIDLTE(*i.SequenceIDLTE))
	}
	if i.ClaimedAt != nil {
		predicates = append(predicates, shelltask.ClaimedAtEQ(*i.ClaimedAt))
	}
	if i.ClaimedAtNEQ != nil {
		predicates = append(predicates, shelltask.ClaimedAtNEQ(*i.ClaimedAtNEQ))
	}
	if len(i.ClaimedAtIn) > 0 {
		predicates = append(predicates, shelltask.ClaimedAtIn(i.ClaimedAtIn...))
	}
	if len(i.ClaimedAtNotIn) > 0 {
		predicates = append(predicates, shelltask.ClaimedAtNotIn(i.ClaimedAtNotIn...))
	}
	if i.ClaimedAtGT != nil {
		predicates = append(predicates, shelltask.ClaimedAtGT(*i.ClaimedAtGT))
	}
	if i.ClaimedAtGTE != nil {
		predicates = append(predicates, shelltask.ClaimedAtGTE(*i.ClaimedAtGTE))
	}
	if i.ClaimedAtLT != nil {
		predicates = append(predicates, shelltask.ClaimedAtLT(*i.ClaimedAtLT))
	}
	if i.ClaimedAtLTE != nil {
		predicates = append(predicates, shelltask.ClaimedAtLTE(*i.ClaimedAtLTE))
	}
	if i.ClaimedAtIsNil {
		predicates = append(predicates, shelltask.ClaimedAtIsNil())
	}
	if i.ClaimedAtNotNil {
		predicates = append(predicates, shelltask.ClaimedAtNotNil())
	}
	if i.ExecStartedAt != nil {
		predicates = append(predicates, shelltask.ExecStartedAtEQ(*i.ExecStartedAt))
	}
	if i.ExecStartedAtNEQ != nil {
		predicates = append(predicates, shelltask.ExecStartedAtNEQ(*i.ExecStartedAtNEQ))
	}
	if len(i.ExecStartedAtIn) > 0 {
		predicates = append(predicates, shelltask.ExecStartedAtIn(i.ExecStartedAtIn...))
	}
	if len(i.ExecStartedAtNotIn) > 0 {
		predicates = append(predicates, shelltask.ExecStartedAtNotIn(i.ExecStartedAtNotIn...))
	}
	if i.ExecStartedAtGT != nil {
		predicates = append(predicates, shelltask.ExecStartedAtGT(*i.ExecStartedAtGT))
	}
	if i.ExecStartedAtGTE != nil {
		predicates = append(predicates, shelltask.ExecStartedAtGTE(*i.ExecStartedAtGTE))
	}
	if i.ExecStartedAtLT != nil {
		predicates = append(predicates, shelltask.ExecStartedAtLT(*i.ExecStartedAtLT))
	}
	if i.ExecStartedAtLTE != nil {
		predicates = append(predicates, shelltask.ExecStartedAtLTE(*i.ExecStartedAtLTE))
	}
	if i.ExecStartedAtIsNil {
		predicates = append(predicates, shelltask.ExecStartedAtIsNil())
	}
	if i.ExecStartedAtNotNil {
		predicates = append(predicates, shelltask.ExecStartedAtNotNil())
	}
	if i.ExecFinishedAt != nil {
		predicates = append(predicates, shelltask.ExecFinishedAtEQ(*i.ExecFinishedAt))
	}
	if i.ExecFinishedAtNEQ != nil {
		predicates = append(predicates, shelltask.ExecFinishedAtNEQ(*i.ExecFinishedAtNEQ))
	}
	if len(i.ExecFinishedAtIn) > 0 {
		predicates = append(predicates, shelltask.ExecFinishedAtIn(i.ExecFinishedAtIn...))
	}
	if len(i.ExecFinishedAtNotIn) > 0 {
		predicates = append(predicates, shelltask.ExecFinishedAtNotIn(i.ExecFinishedAtNotIn...))
	}
	if i.ExecFinishedAtGT != nil {
		predicates = append(predicates, shelltask.ExecFinishedAtGT(*i.ExecFinishedAtGT))
	}
	if i.ExecFinishedAtGTE != nil {
		predicates = append(predicates, shelltask.ExecFinishedAtGTE(*i.ExecFinishedAtGTE))
	}
	if i.ExecFinishedAtLT != nil {
		predicates = append(predicates, shelltask.ExecFinishedAtLT(*i.ExecFinishedAtLT))
	}
	if i.ExecFinishedAtLTE != nil {
		predicates = append(predicates, shelltask.ExecFinishedAtLTE(*i.ExecFinishedAtLTE))
	}
	if i.ExecFinishedAtIsNil {
		predicates = append(predicates, shelltask.ExecFinishedAtIsNil())
	}
	if i.ExecFinishedAtNotNil {
		predicates = append(predicates, shelltask.ExecFinishedAtNotNil())
	}

	if i.HasShell != nil {
		p := shelltask.HasShell()
		if !*i.HasShell {
			p = shelltask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShellWith) > 0 {
		with := make([]predicate.Shell, 0, len(i.HasShellWith))
		for _, w := range i.HasShellWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShellWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shelltask.HasShellWith(with...))
	}
	if i.HasCreator != nil {
		p := shelltask.HasCreator()
		if !*i.HasCreator {
			p = shelltask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shelltask.HasCreatorWith(with...))
	}
	if i.HasReportedCredentials != nil {
		p := shelltask.HasReportedCredentials()
		if !*i.HasReportedCredentials {
			p = shelltask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReportedCredentialsWith) > 0 {
		with := make([]predicate.HostCredential, 0, len(i.HasReportedCredentialsWith))
		for _, w := range i.HasReportedCredentialsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReportedCredentialsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shelltask.HasReportedCredentialsWith(with...))
	}
	if i.HasReportedFiles != nil {
		p := shelltask.HasReportedFiles()
		if !*i.HasReportedFiles {
			p = shelltask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReportedFilesWith) > 0 {
		with := make([]predicate.HostFile, 0, len(i.HasReportedFilesWith))
		for _, w := range i.HasReportedFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReportedFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shelltask.HasReportedFilesWith(with...))
	}
	if i.HasReportedProcesses != nil {
		p := shelltask.HasReportedProcesses()
		if !*i.HasReportedProcesses {
			p = shelltask.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReportedProcessesWith) > 0 {
		with := make([]predicate.HostProcess, 0, len(i.HasReportedProcessesWith))
		for _, w := range i.HasReportedProcessesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReportedProcessesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shelltask.HasReportedProcessesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShellTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shelltask.And(predicates...), nil
	}
}

// TagWhereInput represents a where input for filtering Tag queries.
type TagWhereInput struct {
	Predicates []predicate.Tag  `json:"-"`
	Not        *TagWhereInput   `json:"not,omitempty"`
	Or         []*TagWhereInput `json:"or,omitempty"`
	And        []*TagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *tag.Kind  `json:"kind,omitempty"`
	KindNEQ   *tag.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []tag.Kind `json:"kindIn,omitempty"`
	KindNotIn []tag.Kind `json:"kindNotIn,omitempty"`

	// "hosts" edge predicates.
	HasHosts     *bool             `json:"hasHosts,omitempty"`
	HasHostsWith []*HostWhereInput `json:"hasHostsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TagWhereInput) AddPredicates(predicates ...predicate.Tag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TagWhereInput filter on the TagQuery builder.
func (i *TagWhereInput) Filter(q *TagQuery) (*TagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTagWhereInput is returned in case the TagWhereInput is empty.
var ErrEmptyTagWhereInput = errors.New("ent: empty predicate TagWhereInput")

// P returns a predicate for filtering tags.
// An error is returned if the input is empty or invalid.
func (i *TagWhereInput) P() (predicate.Tag, error) {
	var predicates []predicate.Tag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tag.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tag.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, tag.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, tag.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, tag.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, tag.KindNotIn(i.KindNotIn...))
	}

	if i.HasHosts != nil {
		p := tag.HasHosts()
		if !*i.HasHosts {
			p = tag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHostsWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasHostsWith))
		for _, w := range i.HasHostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tag.HasHostsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tag.And(predicates...), nil
	}
}

// TaskWhereInput represents a where input for filtering Task queries.
type TaskWhereInput struct {
	Predicates []predicate.Task  `json:"-"`
	Not        *TaskWhereInput   `json:"not,omitempty"`
	Or         []*TaskWhereInput `json:"or,omitempty"`
	And        []*TaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "claimed_at" field predicates.
	ClaimedAt       *time.Time  `json:"claimedAt,omitempty"`
	ClaimedAtNEQ    *time.Time  `json:"claimedAtNEQ,omitempty"`
	ClaimedAtIn     []time.Time `json:"claimedAtIn,omitempty"`
	ClaimedAtNotIn  []time.Time `json:"claimedAtNotIn,omitempty"`
	ClaimedAtGT     *time.Time  `json:"claimedAtGT,omitempty"`
	ClaimedAtGTE    *time.Time  `json:"claimedAtGTE,omitempty"`
	ClaimedAtLT     *time.Time  `json:"claimedAtLT,omitempty"`
	ClaimedAtLTE    *time.Time  `json:"claimedAtLTE,omitempty"`
	ClaimedAtIsNil  bool        `json:"claimedAtIsNil,omitempty"`
	ClaimedAtNotNil bool        `json:"claimedAtNotNil,omitempty"`

	// "exec_started_at" field predicates.
	ExecStartedAt       *time.Time  `json:"execStartedAt,omitempty"`
	ExecStartedAtNEQ    *time.Time  `json:"execStartedAtNEQ,omitempty"`
	ExecStartedAtIn     []time.Time `json:"execStartedAtIn,omitempty"`
	ExecStartedAtNotIn  []time.Time `json:"execStartedAtNotIn,omitempty"`
	ExecStartedAtGT     *time.Time  `json:"execStartedAtGT,omitempty"`
	ExecStartedAtGTE    *time.Time  `json:"execStartedAtGTE,omitempty"`
	ExecStartedAtLT     *time.Time  `json:"execStartedAtLT,omitempty"`
	ExecStartedAtLTE    *time.Time  `json:"execStartedAtLTE,omitempty"`
	ExecStartedAtIsNil  bool        `json:"execStartedAtIsNil,omitempty"`
	ExecStartedAtNotNil bool        `json:"execStartedAtNotNil,omitempty"`

	// "exec_finished_at" field predicates.
	ExecFinishedAt       *time.Time  `json:"execFinishedAt,omitempty"`
	ExecFinishedAtNEQ    *time.Time  `json:"execFinishedAtNEQ,omitempty"`
	ExecFinishedAtIn     []time.Time `json:"execFinishedAtIn,omitempty"`
	ExecFinishedAtNotIn  []time.Time `json:"execFinishedAtNotIn,omitempty"`
	ExecFinishedAtGT     *time.Time  `json:"execFinishedAtGT,omitempty"`
	ExecFinishedAtGTE    *time.Time  `json:"execFinishedAtGTE,omitempty"`
	ExecFinishedAtLT     *time.Time  `json:"execFinishedAtLT,omitempty"`
	ExecFinishedAtLTE    *time.Time  `json:"execFinishedAtLTE,omitempty"`
	ExecFinishedAtIsNil  bool        `json:"execFinishedAtIsNil,omitempty"`
	ExecFinishedAtNotNil bool        `json:"execFinishedAtNotNil,omitempty"`

	// "output" field predicates.
	Output             *string  `json:"output,omitempty"`
	OutputNEQ          *string  `json:"outputNEQ,omitempty"`
	OutputIn           []string `json:"outputIn,omitempty"`
	OutputNotIn        []string `json:"outputNotIn,omitempty"`
	OutputGT           *string  `json:"outputGT,omitempty"`
	OutputGTE          *string  `json:"outputGTE,omitempty"`
	OutputLT           *string  `json:"outputLT,omitempty"`
	OutputLTE          *string  `json:"outputLTE,omitempty"`
	OutputContains     *string  `json:"outputContains,omitempty"`
	OutputHasPrefix    *string  `json:"outputHasPrefix,omitempty"`
	OutputHasSuffix    *string  `json:"outputHasSuffix,omitempty"`
	OutputIsNil        bool     `json:"outputIsNil,omitempty"`
	OutputNotNil       bool     `json:"outputNotNil,omitempty"`
	OutputEqualFold    *string  `json:"outputEqualFold,omitempty"`
	OutputContainsFold *string  `json:"outputContainsFold,omitempty"`

	// "output_size" field predicates.
	OutputSize      *int  `json:"outputSize,omitempty"`
	OutputSizeNEQ   *int  `json:"outputSizeNEQ,omitempty"`
	OutputSizeIn    []int `json:"outputSizeIn,omitempty"`
	OutputSizeNotIn []int `json:"outputSizeNotIn,omitempty"`
	OutputSizeGT    *int  `json:"outputSizeGT,omitempty"`
	OutputSizeGTE   *int  `json:"outputSizeGTE,omitempty"`
	OutputSizeLT    *int  `json:"outputSizeLT,omitempty"`
	OutputSizeLTE   *int  `json:"outputSizeLTE,omitempty"`

	// "error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        bool     `json:"errorIsNil,omitempty"`
	ErrorNotNil       bool     `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`

	// "quest" edge predicates.
	HasQuest     *bool              `json:"hasQuest,omitempty"`
	HasQuestWith []*QuestWhereInput `json:"hasQuestWith,omitempty"`

	// "beacon" edge predicates.
	HasBeacon     *bool               `json:"hasBeacon,omitempty"`
	HasBeaconWith []*BeaconWhereInput `json:"hasBeaconWith,omitempty"`

	// "reported_files" edge predicates.
	HasReportedFiles     *bool                 `json:"hasReportedFiles,omitempty"`
	HasReportedFilesWith []*HostFileWhereInput `json:"hasReportedFilesWith,omitempty"`

	// "reported_processes" edge predicates.
	HasReportedProcesses     *bool                    `json:"hasReportedProcesses,omitempty"`
	HasReportedProcessesWith []*HostProcessWhereInput `json:"hasReportedProcessesWith,omitempty"`

	// "reported_credentials" edge predicates.
	HasReportedCredentials     *bool                       `json:"hasReportedCredentials,omitempty"`
	HasReportedCredentialsWith []*HostCredentialWhereInput `json:"hasReportedCredentialsWith,omitempty"`

	// "shells" edge predicates.
	HasShells     *bool              `json:"hasShells,omitempty"`
	HasShellsWith []*ShellWhereInput `json:"hasShellsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TaskWhereInput) AddPredicates(predicates ...predicate.Task) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TaskWhereInput filter on the TaskQuery builder.
func (i *TaskWhereInput) Filter(q *TaskQuery) (*TaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTaskWhereInput is returned in case the TaskWhereInput is empty.
var ErrEmptyTaskWhereInput = errors.New("ent: empty predicate TaskWhereInput")

// P returns a predicate for filtering tasks.
// An error is returned if the input is empty or invalid.
func (i *TaskWhereInput) P() (predicate.Task, error) {
	var predicates []predicate.Task
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, task.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Task, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, task.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Task, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, task.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, task.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, task.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, task.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, task.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, task.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, task.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, task.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, task.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, task.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, task.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, task.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, task.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, task.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, task.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, task.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, task.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, task.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, task.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, task.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, task.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, task.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, task.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, task.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, task.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.ClaimedAt != nil {
		predicates = append(predicates, task.ClaimedAtEQ(*i.ClaimedAt))
	}
	if i.ClaimedAtNEQ != nil {
		predicates = append(predicates, task.ClaimedAtNEQ(*i.ClaimedAtNEQ))
	}
	if len(i.ClaimedAtIn) > 0 {
		predicates = append(predicates, task.ClaimedAtIn(i.ClaimedAtIn...))
	}
	if len(i.ClaimedAtNotIn) > 0 {
		predicates = append(predicates, task.ClaimedAtNotIn(i.ClaimedAtNotIn...))
	}
	if i.ClaimedAtGT != nil {
		predicates = append(predicates, task.ClaimedAtGT(*i.ClaimedAtGT))
	}
	if i.ClaimedAtGTE != nil {
		predicates = append(predicates, task.ClaimedAtGTE(*i.ClaimedAtGTE))
	}
	if i.ClaimedAtLT != nil {
		predicates = append(predicates, task.ClaimedAtLT(*i.ClaimedAtLT))
	}
	if i.ClaimedAtLTE != nil {
		predicates = append(predicates, task.ClaimedAtLTE(*i.ClaimedAtLTE))
	}
	if i.ClaimedAtIsNil {
		predicates = append(predicates, task.ClaimedAtIsNil())
	}
	if i.ClaimedAtNotNil {
		predicates = append(predicates, task.ClaimedAtNotNil())
	}
	if i.ExecStartedAt != nil {
		predicates = append(predicates, task.ExecStartedAtEQ(*i.ExecStartedAt))
	}
	if i.ExecStartedAtNEQ != nil {
		predicates = append(predicates, task.ExecStartedAtNEQ(*i.ExecStartedAtNEQ))
	}
	if len(i.ExecStartedAtIn) > 0 {
		predicates = append(predicates, task.ExecStartedAtIn(i.ExecStartedAtIn...))
	}
	if len(i.ExecStartedAtNotIn) > 0 {
		predicates = append(predicates, task.ExecStartedAtNotIn(i.ExecStartedAtNotIn...))
	}
	if i.ExecStartedAtGT != nil {
		predicates = append(predicates, task.ExecStartedAtGT(*i.ExecStartedAtGT))
	}
	if i.ExecStartedAtGTE != nil {
		predicates = append(predicates, task.ExecStartedAtGTE(*i.ExecStartedAtGTE))
	}
	if i.ExecStartedAtLT != nil {
		predicates = append(predicates, task.ExecStartedAtLT(*i.ExecStartedAtLT))
	}
	if i.ExecStartedAtLTE != nil {
		predicates = append(predicates, task.ExecStartedAtLTE(*i.ExecStartedAtLTE))
	}
	if i.ExecStartedAtIsNil {
		predicates = append(predicates, task.ExecStartedAtIsNil())
	}
	if i.ExecStartedAtNotNil {
		predicates = append(predicates, task.ExecStartedAtNotNil())
	}
	if i.ExecFinishedAt != nil {
		predicates = append(predicates, task.ExecFinishedAtEQ(*i.ExecFinishedAt))
	}
	if i.ExecFinishedAtNEQ != nil {
		predicates = append(predicates, task.ExecFinishedAtNEQ(*i.ExecFinishedAtNEQ))
	}
	if len(i.ExecFinishedAtIn) > 0 {
		predicates = append(predicates, task.ExecFinishedAtIn(i.ExecFinishedAtIn...))
	}
	if len(i.ExecFinishedAtNotIn) > 0 {
		predicates = append(predicates, task.ExecFinishedAtNotIn(i.ExecFinishedAtNotIn...))
	}
	if i.ExecFinishedAtGT != nil {
		predicates = append(predicates, task.ExecFinishedAtGT(*i.ExecFinishedAtGT))
	}
	if i.ExecFinishedAtGTE != nil {
		predicates = append(predicates, task.ExecFinishedAtGTE(*i.ExecFinishedAtGTE))
	}
	if i.ExecFinishedAtLT != nil {
		predicates = append(predicates, task.ExecFinishedAtLT(*i.ExecFinishedAtLT))
	}
	if i.ExecFinishedAtLTE != nil {
		predicates = append(predicates, task.ExecFinishedAtLTE(*i.ExecFinishedAtLTE))
	}
	if i.ExecFinishedAtIsNil {
		predicates = append(predicates, task.ExecFinishedAtIsNil())
	}
	if i.ExecFinishedAtNotNil {
		predicates = append(predicates, task.ExecFinishedAtNotNil())
	}
	if i.Output != nil {
		predicates = append(predicates, task.OutputEQ(*i.Output))
	}
	if i.OutputNEQ != nil {
		predicates = append(predicates, task.OutputNEQ(*i.OutputNEQ))
	}
	if len(i.OutputIn) > 0 {
		predicates = append(predicates, task.OutputIn(i.OutputIn...))
	}
	if len(i.OutputNotIn) > 0 {
		predicates = append(predicates, task.OutputNotIn(i.OutputNotIn...))
	}
	if i.OutputGT != nil {
		predicates = append(predicates, task.OutputGT(*i.OutputGT))
	}
	if i.OutputGTE != nil {
		predicates = append(predicates, task.OutputGTE(*i.OutputGTE))
	}
	if i.OutputLT != nil {
		predicates = append(predicates, task.OutputLT(*i.OutputLT))
	}
	if i.OutputLTE != nil {
		predicates = append(predicates, task.OutputLTE(*i.OutputLTE))
	}
	if i.OutputContains != nil {
		predicates = append(predicates, task.OutputContains(*i.OutputContains))
	}
	if i.OutputHasPrefix != nil {
		predicates = append(predicates, task.OutputHasPrefix(*i.OutputHasPrefix))
	}
	if i.OutputHasSuffix != nil {
		predicates = append(predicates, task.OutputHasSuffix(*i.OutputHasSuffix))
	}
	if i.OutputIsNil {
		predicates = append(predicates, task.OutputIsNil())
	}
	if i.OutputNotNil {
		predicates = append(predicates, task.OutputNotNil())
	}
	if i.OutputEqualFold != nil {
		predicates = append(predicates, task.OutputEqualFold(*i.OutputEqualFold))
	}
	if i.OutputContainsFold != nil {
		predicates = append(predicates, task.OutputContainsFold(*i.OutputContainsFold))
	}
	if i.OutputSize != nil {
		predicates = append(predicates, task.OutputSizeEQ(*i.OutputSize))
	}
	if i.OutputSizeNEQ != nil {
		predicates = append(predicates, task.OutputSizeNEQ(*i.OutputSizeNEQ))
	}
	if len(i.OutputSizeIn) > 0 {
		predicates = append(predicates, task.OutputSizeIn(i.OutputSizeIn...))
	}
	if len(i.OutputSizeNotIn) > 0 {
		predicates = append(predicates, task.OutputSizeNotIn(i.OutputSizeNotIn...))
	}
	if i.OutputSizeGT != nil {
		predicates = append(predicates, task.OutputSizeGT(*i.OutputSizeGT))
	}
	if i.OutputSizeGTE != nil {
		predicates = append(predicates, task.OutputSizeGTE(*i.OutputSizeGTE))
	}
	if i.OutputSizeLT != nil {
		predicates = append(predicates, task.OutputSizeLT(*i.OutputSizeLT))
	}
	if i.OutputSizeLTE != nil {
		predicates = append(predicates, task.OutputSizeLTE(*i.OutputSizeLTE))
	}
	if i.Error != nil {
		predicates = append(predicates, task.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, task.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, task.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, task.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, task.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, task.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, task.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, task.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, task.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, task.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, task.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorIsNil {
		predicates = append(predicates, task.ErrorIsNil())
	}
	if i.ErrorNotNil {
		predicates = append(predicates, task.ErrorNotNil())
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, task.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, task.ErrorContainsFold(*i.ErrorContainsFold))
	}

	if i.HasQuest != nil {
		p := task.HasQuest()
		if !*i.HasQuest {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasQuestWith) > 0 {
		with := make([]predicate.Quest, 0, len(i.HasQuestWith))
		for _, w := range i.HasQuestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasQuestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasQuestWith(with...))
	}
	if i.HasBeacon != nil {
		p := task.HasBeacon()
		if !*i.HasBeacon {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeaconWith) > 0 {
		with := make([]predicate.Beacon, 0, len(i.HasBeaconWith))
		for _, w := range i.HasBeaconWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBeaconWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasBeaconWith(with...))
	}
	if i.HasReportedFiles != nil {
		p := task.HasReportedFiles()
		if !*i.HasReportedFiles {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReportedFilesWith) > 0 {
		with := make([]predicate.HostFile, 0, len(i.HasReportedFilesWith))
		for _, w := range i.HasReportedFilesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReportedFilesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasReportedFilesWith(with...))
	}
	if i.HasReportedProcesses != nil {
		p := task.HasReportedProcesses()
		if !*i.HasReportedProcesses {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReportedProcessesWith) > 0 {
		with := make([]predicate.HostProcess, 0, len(i.HasReportedProcessesWith))
		for _, w := range i.HasReportedProcessesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReportedProcessesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasReportedProcessesWith(with...))
	}
	if i.HasReportedCredentials != nil {
		p := task.HasReportedCredentials()
		if !*i.HasReportedCredentials {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReportedCredentialsWith) > 0 {
		with := make([]predicate.HostCredential, 0, len(i.HasReportedCredentialsWith))
		for _, w := range i.HasReportedCredentialsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReportedCredentialsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasReportedCredentialsWith(with...))
	}
	if i.HasShells != nil {
		p := task.HasShells()
		if !*i.HasShells {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShellsWith) > 0 {
		with := make([]predicate.Shell, 0, len(i.HasShellsWith))
		for _, w := range i.HasShellsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShellsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasShellsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return task.And(predicates...), nil
	}
}

// TomeWhereInput represents a where input for filtering Tome queries.
type TomeWhereInput struct {
	Predicates []predicate.Tome  `json:"-"`
	Not        *TomeWhereInput   `json:"not,omitempty"`
	Or         []*TomeWhereInput `json:"or,omitempty"`
	And        []*TomeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_modified_at" field predicates.
	LastModifiedAt      *time.Time  `json:"lastModifiedAt,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastModifiedAtNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastModifiedAtIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastModifiedAtNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastModifiedAtGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastModifiedAtGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastModifiedAtLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastModifiedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "author" field predicates.
	Author             *string  `json:"author,omitempty"`
	AuthorNEQ          *string  `json:"authorNEQ,omitempty"`
	AuthorIn           []string `json:"authorIn,omitempty"`
	AuthorNotIn        []string `json:"authorNotIn,omitempty"`
	AuthorGT           *string  `json:"authorGT,omitempty"`
	AuthorGTE          *string  `json:"authorGTE,omitempty"`
	AuthorLT           *string  `json:"authorLT,omitempty"`
	AuthorLTE          *string  `json:"authorLTE,omitempty"`
	AuthorContains     *string  `json:"authorContains,omitempty"`
	AuthorHasPrefix    *string  `json:"authorHasPrefix,omitempty"`
	AuthorHasSuffix    *string  `json:"authorHasSuffix,omitempty"`
	AuthorEqualFold    *string  `json:"authorEqualFold,omitempty"`
	AuthorContainsFold *string  `json:"authorContainsFold,omitempty"`

	// "support_model" field predicates.
	SupportModel      *tome.SupportModel  `json:"supportModel,omitempty"`
	SupportModelNEQ   *tome.SupportModel  `json:"supportModelNEQ,omitempty"`
	SupportModelIn    []tome.SupportModel `json:"supportModelIn,omitempty"`
	SupportModelNotIn []tome.SupportModel `json:"supportModelNotIn,omitempty"`

	// "tactic" field predicates.
	Tactic      *tome.Tactic  `json:"tactic,omitempty"`
	TacticNEQ   *tome.Tactic  `json:"tacticNEQ,omitempty"`
	TacticIn    []tome.Tactic `json:"tacticIn,omitempty"`
	TacticNotIn []tome.Tactic `json:"tacticNotIn,omitempty"`

	// "run_on_new_beacon_callback" field predicates.
	RunOnNewBeaconCallback    *bool `json:"runOnNewBeaconCallback,omitempty"`
	RunOnNewBeaconCallbackNEQ *bool `json:"runOnNewBeaconCallbackNEQ,omitempty"`

	// "run_on_first_host_callback" field predicates.
	RunOnFirstHostCallback    *bool `json:"runOnFirstHostCallback,omitempty"`
	RunOnFirstHostCallbackNEQ *bool `json:"runOnFirstHostCallbackNEQ,omitempty"`

	// "run_on_schedule" field predicates.
	RunOnSchedule             *string  `json:"runOnSchedule,omitempty"`
	RunOnScheduleNEQ          *string  `json:"runOnScheduleNEQ,omitempty"`
	RunOnScheduleIn           []string `json:"runOnScheduleIn,omitempty"`
	RunOnScheduleNotIn        []string `json:"runOnScheduleNotIn,omitempty"`
	RunOnScheduleGT           *string  `json:"runOnScheduleGT,omitempty"`
	RunOnScheduleGTE          *string  `json:"runOnScheduleGTE,omitempty"`
	RunOnScheduleLT           *string  `json:"runOnScheduleLT,omitempty"`
	RunOnScheduleLTE          *string  `json:"runOnScheduleLTE,omitempty"`
	RunOnScheduleContains     *string  `json:"runOnScheduleContains,omitempty"`
	RunOnScheduleHasPrefix    *string  `json:"runOnScheduleHasPrefix,omitempty"`
	RunOnScheduleHasSuffix    *string  `json:"runOnScheduleHasSuffix,omitempty"`
	RunOnScheduleEqualFold    *string  `json:"runOnScheduleEqualFold,omitempty"`
	RunOnScheduleContainsFold *string  `json:"runOnScheduleContainsFold,omitempty"`

	// "param_defs" field predicates.
	ParamDefs             *string  `json:"paramDefs,omitempty"`
	ParamDefsNEQ          *string  `json:"paramDefsNEQ,omitempty"`
	ParamDefsIn           []string `json:"paramDefsIn,omitempty"`
	ParamDefsNotIn        []string `json:"paramDefsNotIn,omitempty"`
	ParamDefsGT           *string  `json:"paramDefsGT,omitempty"`
	ParamDefsGTE          *string  `json:"paramDefsGTE,omitempty"`
	ParamDefsLT           *string  `json:"paramDefsLT,omitempty"`
	ParamDefsLTE          *string  `json:"paramDefsLTE,omitempty"`
	ParamDefsContains     *string  `json:"paramDefsContains,omitempty"`
	ParamDefsHasPrefix    *string  `json:"paramDefsHasPrefix,omitempty"`
	ParamDefsHasSuffix    *string  `json:"paramDefsHasSuffix,omitempty"`
	ParamDefsIsNil        bool     `json:"paramDefsIsNil,omitempty"`
	ParamDefsNotNil       bool     `json:"paramDefsNotNil,omitempty"`
	ParamDefsEqualFold    *string  `json:"paramDefsEqualFold,omitempty"`
	ParamDefsContainsFold *string  `json:"paramDefsContainsFold,omitempty"`

	// "eldritch" field predicates.
	Eldritch             *string  `json:"eldritch,omitempty"`
	EldritchNEQ          *string  `json:"eldritchNEQ,omitempty"`
	EldritchIn           []string `json:"eldritchIn,omitempty"`
	EldritchNotIn        []string `json:"eldritchNotIn,omitempty"`
	EldritchGT           *string  `json:"eldritchGT,omitempty"`
	EldritchGTE          *string  `json:"eldritchGTE,omitempty"`
	EldritchLT           *string  `json:"eldritchLT,omitempty"`
	EldritchLTE          *string  `json:"eldritchLTE,omitempty"`
	EldritchContains     *string  `json:"eldritchContains,omitempty"`
	EldritchHasPrefix    *string  `json:"eldritchHasPrefix,omitempty"`
	EldritchHasSuffix    *string  `json:"eldritchHasSuffix,omitempty"`
	EldritchEqualFold    *string  `json:"eldritchEqualFold,omitempty"`
	EldritchContainsFold *string  `json:"eldritchContainsFold,omitempty"`

	// "assets" edge predicates.
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`

	// "uploader" edge predicates.
	HasUploader     *bool             `json:"hasUploader,omitempty"`
	HasUploaderWith []*UserWhereInput `json:"hasUploaderWith,omitempty"`

	// "repository" edge predicates.
	HasRepository     *bool                   `json:"hasRepository,omitempty"`
	HasRepositoryWith []*RepositoryWhereInput `json:"hasRepositoryWith,omitempty"`

	// "scheduled_hosts" edge predicates.
	HasScheduledHosts     *bool             `json:"hasScheduledHosts,omitempty"`
	HasScheduledHostsWith []*HostWhereInput `json:"hasScheduledHostsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TomeWhereInput) AddPredicates(predicates ...predicate.Tome) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TomeWhereInput filter on the TomeQuery builder.
func (i *TomeWhereInput) Filter(q *TomeQuery) (*TomeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTomeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTomeWhereInput is returned in case the TomeWhereInput is empty.
var ErrEmptyTomeWhereInput = errors.New("ent: empty predicate TomeWhereInput")

// P returns a predicate for filtering tomes.
// An error is returned if the input is empty or invalid.
func (i *TomeWhereInput) P() (predicate.Tome, error) {
	var predicates []predicate.Tome
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tome.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tome, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tome.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tome, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tome.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tome.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tome.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tome.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tome.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tome.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tome.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tome.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tome.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, tome.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, tome.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, tome.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, tome.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, tome.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, tome.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, tome.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, tome.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, tome.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, tome.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, tome.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, tome.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, tome.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, tome.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, tome.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, tome.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tome.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tome.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tome.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tome.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tome.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tome.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tome.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tome.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tome.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tome.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tome.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tome.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tome.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, tome.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, tome.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, tome.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, tome.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, tome.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, tome.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, tome.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, tome.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, tome.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, tome.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, tome.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, tome.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, tome.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Author != nil {
		predicates = append(predicates, tome.AuthorEQ(*i.Author))
	}
	if i.AuthorNEQ != nil {
		predicates = append(predicates, tome.AuthorNEQ(*i.AuthorNEQ))
	}
	if len(i.AuthorIn) > 0 {
		predicates = append(predicates, tome.AuthorIn(i.AuthorIn...))
	}
	if len(i.AuthorNotIn) > 0 {
		predicates = append(predicates, tome.AuthorNotIn(i.AuthorNotIn...))
	}
	if i.AuthorGT != nil {
		predicates = append(predicates, tome.AuthorGT(*i.AuthorGT))
	}
	if i.AuthorGTE != nil {
		predicates = append(predicates, tome.AuthorGTE(*i.AuthorGTE))
	}
	if i.AuthorLT != nil {
		predicates = append(predicates, tome.AuthorLT(*i.AuthorLT))
	}
	if i.AuthorLTE != nil {
		predicates = append(predicates, tome.AuthorLTE(*i.AuthorLTE))
	}
	if i.AuthorContains != nil {
		predicates = append(predicates, tome.AuthorContains(*i.AuthorContains))
	}
	if i.AuthorHasPrefix != nil {
		predicates = append(predicates, tome.AuthorHasPrefix(*i.AuthorHasPrefix))
	}
	if i.AuthorHasSuffix != nil {
		predicates = append(predicates, tome.AuthorHasSuffix(*i.AuthorHasSuffix))
	}
	if i.AuthorEqualFold != nil {
		predicates = append(predicates, tome.AuthorEqualFold(*i.AuthorEqualFold))
	}
	if i.AuthorContainsFold != nil {
		predicates = append(predicates, tome.AuthorContainsFold(*i.AuthorContainsFold))
	}
	if i.SupportModel != nil {
		predicates = append(predicates, tome.SupportModelEQ(*i.SupportModel))
	}
	if i.SupportModelNEQ != nil {
		predicates = append(predicates, tome.SupportModelNEQ(*i.SupportModelNEQ))
	}
	if len(i.SupportModelIn) > 0 {
		predicates = append(predicates, tome.SupportModelIn(i.SupportModelIn...))
	}
	if len(i.SupportModelNotIn) > 0 {
		predicates = append(predicates, tome.SupportModelNotIn(i.SupportModelNotIn...))
	}
	if i.Tactic != nil {
		predicates = append(predicates, tome.TacticEQ(*i.Tactic))
	}
	if i.TacticNEQ != nil {
		predicates = append(predicates, tome.TacticNEQ(*i.TacticNEQ))
	}
	if len(i.TacticIn) > 0 {
		predicates = append(predicates, tome.TacticIn(i.TacticIn...))
	}
	if len(i.TacticNotIn) > 0 {
		predicates = append(predicates, tome.TacticNotIn(i.TacticNotIn...))
	}
	if i.RunOnNewBeaconCallback != nil {
		predicates = append(predicates, tome.RunOnNewBeaconCallbackEQ(*i.RunOnNewBeaconCallback))
	}
	if i.RunOnNewBeaconCallbackNEQ != nil {
		predicates = append(predicates, tome.RunOnNewBeaconCallbackNEQ(*i.RunOnNewBeaconCallbackNEQ))
	}
	if i.RunOnFirstHostCallback != nil {
		predicates = append(predicates, tome.RunOnFirstHostCallbackEQ(*i.RunOnFirstHostCallback))
	}
	if i.RunOnFirstHostCallbackNEQ != nil {
		predicates = append(predicates, tome.RunOnFirstHostCallbackNEQ(*i.RunOnFirstHostCallbackNEQ))
	}
	if i.RunOnSchedule != nil {
		predicates = append(predicates, tome.RunOnScheduleEQ(*i.RunOnSchedule))
	}
	if i.RunOnScheduleNEQ != nil {
		predicates = append(predicates, tome.RunOnScheduleNEQ(*i.RunOnScheduleNEQ))
	}
	if len(i.RunOnScheduleIn) > 0 {
		predicates = append(predicates, tome.RunOnScheduleIn(i.RunOnScheduleIn...))
	}
	if len(i.RunOnScheduleNotIn) > 0 {
		predicates = append(predicates, tome.RunOnScheduleNotIn(i.RunOnScheduleNotIn...))
	}
	if i.RunOnScheduleGT != nil {
		predicates = append(predicates, tome.RunOnScheduleGT(*i.RunOnScheduleGT))
	}
	if i.RunOnScheduleGTE != nil {
		predicates = append(predicates, tome.RunOnScheduleGTE(*i.RunOnScheduleGTE))
	}
	if i.RunOnScheduleLT != nil {
		predicates = append(predicates, tome.RunOnScheduleLT(*i.RunOnScheduleLT))
	}
	if i.RunOnScheduleLTE != nil {
		predicates = append(predicates, tome.RunOnScheduleLTE(*i.RunOnScheduleLTE))
	}
	if i.RunOnScheduleContains != nil {
		predicates = append(predicates, tome.RunOnScheduleContains(*i.RunOnScheduleContains))
	}
	if i.RunOnScheduleHasPrefix != nil {
		predicates = append(predicates, tome.RunOnScheduleHasPrefix(*i.RunOnScheduleHasPrefix))
	}
	if i.RunOnScheduleHasSuffix != nil {
		predicates = append(predicates, tome.RunOnScheduleHasSuffix(*i.RunOnScheduleHasSuffix))
	}
	if i.RunOnScheduleEqualFold != nil {
		predicates = append(predicates, tome.RunOnScheduleEqualFold(*i.RunOnScheduleEqualFold))
	}
	if i.RunOnScheduleContainsFold != nil {
		predicates = append(predicates, tome.RunOnScheduleContainsFold(*i.RunOnScheduleContainsFold))
	}
	if i.ParamDefs != nil {
		predicates = append(predicates, tome.ParamDefsEQ(*i.ParamDefs))
	}
	if i.ParamDefsNEQ != nil {
		predicates = append(predicates, tome.ParamDefsNEQ(*i.ParamDefsNEQ))
	}
	if len(i.ParamDefsIn) > 0 {
		predicates = append(predicates, tome.ParamDefsIn(i.ParamDefsIn...))
	}
	if len(i.ParamDefsNotIn) > 0 {
		predicates = append(predicates, tome.ParamDefsNotIn(i.ParamDefsNotIn...))
	}
	if i.ParamDefsGT != nil {
		predicates = append(predicates, tome.ParamDefsGT(*i.ParamDefsGT))
	}
	if i.ParamDefsGTE != nil {
		predicates = append(predicates, tome.ParamDefsGTE(*i.ParamDefsGTE))
	}
	if i.ParamDefsLT != nil {
		predicates = append(predicates, tome.ParamDefsLT(*i.ParamDefsLT))
	}
	if i.ParamDefsLTE != nil {
		predicates = append(predicates, tome.ParamDefsLTE(*i.ParamDefsLTE))
	}
	if i.ParamDefsContains != nil {
		predicates = append(predicates, tome.ParamDefsContains(*i.ParamDefsContains))
	}
	if i.ParamDefsHasPrefix != nil {
		predicates = append(predicates, tome.ParamDefsHasPrefix(*i.ParamDefsHasPrefix))
	}
	if i.ParamDefsHasSuffix != nil {
		predicates = append(predicates, tome.ParamDefsHasSuffix(*i.ParamDefsHasSuffix))
	}
	if i.ParamDefsIsNil {
		predicates = append(predicates, tome.ParamDefsIsNil())
	}
	if i.ParamDefsNotNil {
		predicates = append(predicates, tome.ParamDefsNotNil())
	}
	if i.ParamDefsEqualFold != nil {
		predicates = append(predicates, tome.ParamDefsEqualFold(*i.ParamDefsEqualFold))
	}
	if i.ParamDefsContainsFold != nil {
		predicates = append(predicates, tome.ParamDefsContainsFold(*i.ParamDefsContainsFold))
	}
	if i.Eldritch != nil {
		predicates = append(predicates, tome.EldritchEQ(*i.Eldritch))
	}
	if i.EldritchNEQ != nil {
		predicates = append(predicates, tome.EldritchNEQ(*i.EldritchNEQ))
	}
	if len(i.EldritchIn) > 0 {
		predicates = append(predicates, tome.EldritchIn(i.EldritchIn...))
	}
	if len(i.EldritchNotIn) > 0 {
		predicates = append(predicates, tome.EldritchNotIn(i.EldritchNotIn...))
	}
	if i.EldritchGT != nil {
		predicates = append(predicates, tome.EldritchGT(*i.EldritchGT))
	}
	if i.EldritchGTE != nil {
		predicates = append(predicates, tome.EldritchGTE(*i.EldritchGTE))
	}
	if i.EldritchLT != nil {
		predicates = append(predicates, tome.EldritchLT(*i.EldritchLT))
	}
	if i.EldritchLTE != nil {
		predicates = append(predicates, tome.EldritchLTE(*i.EldritchLTE))
	}
	if i.EldritchContains != nil {
		predicates = append(predicates, tome.EldritchContains(*i.EldritchContains))
	}
	if i.EldritchHasPrefix != nil {
		predicates = append(predicates, tome.EldritchHasPrefix(*i.EldritchHasPrefix))
	}
	if i.EldritchHasSuffix != nil {
		predicates = append(predicates, tome.EldritchHasSuffix(*i.EldritchHasSuffix))
	}
	if i.EldritchEqualFold != nil {
		predicates = append(predicates, tome.EldritchEqualFold(*i.EldritchEqualFold))
	}
	if i.EldritchContainsFold != nil {
		predicates = append(predicates, tome.EldritchContainsFold(*i.EldritchContainsFold))
	}

	if i.HasAssets != nil {
		p := tome.HasAssets()
		if !*i.HasAssets {
			p = tome.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssetsWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasAssetsWith))
		for _, w := range i.HasAssetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tome.HasAssetsWith(with...))
	}
	if i.HasUploader != nil {
		p := tome.HasUploader()
		if !*i.HasUploader {
			p = tome.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUploaderWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUploaderWith))
		for _, w := range i.HasUploaderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUploaderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tome.HasUploaderWith(with...))
	}
	if i.HasRepository != nil {
		p := tome.HasRepository()
		if !*i.HasRepository {
			p = tome.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRepositoryWith) > 0 {
		with := make([]predicate.Repository, 0, len(i.HasRepositoryWith))
		for _, w := range i.HasRepositoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRepositoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tome.HasRepositoryWith(with...))
	}
	if i.HasScheduledHosts != nil {
		p := tome.HasScheduledHosts()
		if !*i.HasScheduledHosts {
			p = tome.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduledHostsWith) > 0 {
		with := make([]predicate.Host, 0, len(i.HasScheduledHostsWith))
		for _, w := range i.HasScheduledHostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduledHostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tome.HasScheduledHostsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTomeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tome.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "oauth_id" field predicates.
	OauthID             *string  `json:"oauthID,omitempty"`
	OauthIDNEQ          *string  `json:"oauthIDNEQ,omitempty"`
	OauthIDIn           []string `json:"oauthIDIn,omitempty"`
	OauthIDNotIn        []string `json:"oauthIDNotIn,omitempty"`
	OauthIDGT           *string  `json:"oauthIDGT,omitempty"`
	OauthIDGTE          *string  `json:"oauthIDGTE,omitempty"`
	OauthIDLT           *string  `json:"oauthIDLT,omitempty"`
	OauthIDLTE          *string  `json:"oauthIDLTE,omitempty"`
	OauthIDContains     *string  `json:"oauthIDContains,omitempty"`
	OauthIDHasPrefix    *string  `json:"oauthIDHasPrefix,omitempty"`
	OauthIDHasSuffix    *string  `json:"oauthIDHasSuffix,omitempty"`
	OauthIDEqualFold    *string  `json:"oauthIDEqualFold,omitempty"`
	OauthIDContainsFold *string  `json:"oauthIDContainsFold,omitempty"`

	// "photo_url" field predicates.
	PhotoURL             *string  `json:"photoURL,omitempty"`
	PhotoURLNEQ          *string  `json:"photoURLNEQ,omitempty"`
	PhotoURLIn           []string `json:"photoURLIn,omitempty"`
	PhotoURLNotIn        []string `json:"photoURLNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photoURLGT,omitempty"`
	PhotoURLGTE          *string  `json:"photoURLGTE,omitempty"`
	PhotoURLLT           *string  `json:"photoURLLT,omitempty"`
	PhotoURLLTE          *string  `json:"photoURLLTE,omitempty"`
	PhotoURLContains     *string  `json:"photoURLContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photoURLHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photoURLHasSuffix,omitempty"`
	PhotoURLEqualFold    *string  `json:"photoURLEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photoURLContainsFold,omitempty"`

	// "is_activated" field predicates.
	IsActivated    *bool `json:"isActivated,omitempty"`
	IsActivatedNEQ *bool `json:"isActivatedNEQ,omitempty"`

	// "is_admin" field predicates.
	IsAdmin    *bool `json:"isAdmin,omitempty"`
	IsAdminNEQ *bool `json:"isAdminNEQ,omitempty"`

	// "tomes" edge predicates.
	HasTomes     *bool             `json:"hasTomes,omitempty"`
	HasTomesWith []*TomeWhereInput `json:"hasTomesWith,omitempty"`

	// "active_shells" edge predicates.
	HasActiveShells     *bool              `json:"hasActiveShells,omitempty"`
	HasActiveShellsWith []*ShellWhereInput `json:"hasActiveShellsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.OauthID != nil {
		predicates = append(predicates, user.OauthIDEQ(*i.OauthID))
	}
	if i.OauthIDNEQ != nil {
		predicates = append(predicates, user.OauthIDNEQ(*i.OauthIDNEQ))
	}
	if len(i.OauthIDIn) > 0 {
		predicates = append(predicates, user.OauthIDIn(i.OauthIDIn...))
	}
	if len(i.OauthIDNotIn) > 0 {
		predicates = append(predicates, user.OauthIDNotIn(i.OauthIDNotIn...))
	}
	if i.OauthIDGT != nil {
		predicates = append(predicates, user.OauthIDGT(*i.OauthIDGT))
	}
	if i.OauthIDGTE != nil {
		predicates = append(predicates, user.OauthIDGTE(*i.OauthIDGTE))
	}
	if i.OauthIDLT != nil {
		predicates = append(predicates, user.OauthIDLT(*i.OauthIDLT))
	}
	if i.OauthIDLTE != nil {
		predicates = append(predicates, user.OauthIDLTE(*i.OauthIDLTE))
	}
	if i.OauthIDContains != nil {
		predicates = append(predicates, user.OauthIDContains(*i.OauthIDContains))
	}
	if i.OauthIDHasPrefix != nil {
		predicates = append(predicates, user.OauthIDHasPrefix(*i.OauthIDHasPrefix))
	}
	if i.OauthIDHasSuffix != nil {
		predicates = append(predicates, user.OauthIDHasSuffix(*i.OauthIDHasSuffix))
	}
	if i.OauthIDEqualFold != nil {
		predicates = append(predicates, user.OauthIDEqualFold(*i.OauthIDEqualFold))
	}
	if i.OauthIDContainsFold != nil {
		predicates = append(predicates, user.OauthIDContainsFold(*i.OauthIDContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, user.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, user.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, user.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, user.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, user.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, user.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, user.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, user.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, user.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, user.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, user.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, user.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, user.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.IsActivated != nil {
		predicates = append(predicates, user.IsActivatedEQ(*i.IsActivated))
	}
	if i.IsActivatedNEQ != nil {
		predicates = append(predicates, user.IsActivatedNEQ(*i.IsActivatedNEQ))
	}
	if i.IsAdmin != nil {
		predicates = append(predicates, user.IsAdminEQ(*i.IsAdmin))
	}
	if i.IsAdminNEQ != nil {
		predicates = append(predicates, user.IsAdminNEQ(*i.IsAdminNEQ))
	}

	if i.HasTomes != nil {
		p := user.HasTomes()
		if !*i.HasTomes {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTomesWith) > 0 {
		with := make([]predicate.Tome, 0, len(i.HasTomesWith))
		for _, w := range i.HasTomesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTomesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTomesWith(with...))
	}
	if i.HasActiveShells != nil {
		p := user.HasActiveShells()
		if !*i.HasActiveShells {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActiveShellsWith) > 0 {
		with := make([]predicate.Shell, 0, len(i.HasActiveShellsWith))
		for _, w := range i.HasActiveShellsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActiveShellsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasActiveShellsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
