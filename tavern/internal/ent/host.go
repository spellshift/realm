// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"realm.pub/tavern/internal/c2/c2pb"
	"realm.pub/tavern/internal/ent/host"
)

// Host is the model entity for the Host schema.
type Host struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Timestamp of when this ent was created
	CreatedAt time.Time `json:"created_at,omitempty"`
	// Timestamp of when this ent was last updated
	LastModifiedAt time.Time `json:"last_modified_at,omitempty"`
	// Unique identifier for the host. Unique to each host.
	Identifier string `json:"identifier,omitempty"`
	// A human readable identifier for the host.
	Name string `json:"name,omitempty"`
	// Primary interface IP address reported by the agent.
	PrimaryIP string `json:"primary_ip,omitempty"`
	// Incoming IP from Proxy. Will return first proxy IP if multiple.
	ExternalIP string `json:"external_ip,omitempty"`
	// Platform the agent is operating on.
	Platform c2pb.Host_Platform `json:"platform,omitempty"`
	// Timestamp of when a task was last claimed or updated for the host.
	LastSeenAt time.Time `json:"last_seen_at,omitempty"`
	// Timestamp of when a task is next expected to be claimed or updated for the host.
	NextSeenAt time.Time `json:"next_seen_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the HostQuery when eager-loading is set.
	Edges        HostEdges `json:"edges"`
	selectValues sql.SelectValues
}

// HostEdges holds the relations/edges for other nodes in the graph.
type HostEdges struct {
	// Tags used to group this host with other hosts.
	Tags []*Tag `json:"tags,omitempty"`
	// Beacons that are present on this host system.
	Beacons []*Beacon `json:"beacons,omitempty"`
	// Files reported on this host system.
	Files []*HostFile `json:"files,omitempty"`
	// Processes reported as running on this host system.
	Processes []*HostProcess `json:"processes,omitempty"`
	// Credentials reported from this host system.
	Credentials []*HostCredential `json:"credentials,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
	// totalCount holds the count of the edges above.
	totalCount [5]map[string]int

	namedTags        map[string][]*Tag
	namedBeacons     map[string][]*Beacon
	namedFiles       map[string][]*HostFile
	namedProcesses   map[string][]*HostProcess
	namedCredentials map[string][]*HostCredential
}

// TagsOrErr returns the Tags value or an error if the edge
// was not loaded in eager-loading.
func (e HostEdges) TagsOrErr() ([]*Tag, error) {
	if e.loadedTypes[0] {
		return e.Tags, nil
	}
	return nil, &NotLoadedError{edge: "tags"}
}

// BeaconsOrErr returns the Beacons value or an error if the edge
// was not loaded in eager-loading.
func (e HostEdges) BeaconsOrErr() ([]*Beacon, error) {
	if e.loadedTypes[1] {
		return e.Beacons, nil
	}
	return nil, &NotLoadedError{edge: "beacons"}
}

// FilesOrErr returns the Files value or an error if the edge
// was not loaded in eager-loading.
func (e HostEdges) FilesOrErr() ([]*HostFile, error) {
	if e.loadedTypes[2] {
		return e.Files, nil
	}
	return nil, &NotLoadedError{edge: "files"}
}

// ProcessesOrErr returns the Processes value or an error if the edge
// was not loaded in eager-loading.
func (e HostEdges) ProcessesOrErr() ([]*HostProcess, error) {
	if e.loadedTypes[3] {
		return e.Processes, nil
	}
	return nil, &NotLoadedError{edge: "processes"}
}

// CredentialsOrErr returns the Credentials value or an error if the edge
// was not loaded in eager-loading.
func (e HostEdges) CredentialsOrErr() ([]*HostCredential, error) {
	if e.loadedTypes[4] {
		return e.Credentials, nil
	}
	return nil, &NotLoadedError{edge: "credentials"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Host) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case host.FieldPlatform:
			values[i] = new(c2pb.Host_Platform)
		case host.FieldID:
			values[i] = new(sql.NullInt64)
		case host.FieldIdentifier, host.FieldName, host.FieldPrimaryIP, host.FieldExternalIP:
			values[i] = new(sql.NullString)
		case host.FieldCreatedAt, host.FieldLastModifiedAt, host.FieldLastSeenAt, host.FieldNextSeenAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Host fields.
func (_m *Host) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case host.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			_m.ID = int(value.Int64)
		case host.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case host.FieldLastModifiedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_modified_at", values[i])
			} else if value.Valid {
				_m.LastModifiedAt = value.Time
			}
		case host.FieldIdentifier:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field identifier", values[i])
			} else if value.Valid {
				_m.Identifier = value.String
			}
		case host.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				_m.Name = value.String
			}
		case host.FieldPrimaryIP:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field primary_ip", values[i])
			} else if value.Valid {
				_m.PrimaryIP = value.String
			}
		case host.FieldExternalIP:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field external_ip", values[i])
			} else if value.Valid {
				_m.ExternalIP = value.String
			}
		case host.FieldPlatform:
			if value, ok := values[i].(*c2pb.Host_Platform); !ok {
				return fmt.Errorf("unexpected type %T for field platform", values[i])
			} else if value != nil {
				_m.Platform = *value
			}
		case host.FieldLastSeenAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_seen_at", values[i])
			} else if value.Valid {
				_m.LastSeenAt = value.Time
			}
		case host.FieldNextSeenAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field next_seen_at", values[i])
			} else if value.Valid {
				_m.NextSeenAt = value.Time
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Host.
// This includes values selected through modifiers, order, etc.
func (_m *Host) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryTags queries the "tags" edge of the Host entity.
func (_m *Host) QueryTags() *TagQuery {
	return NewHostClient(_m.config).QueryTags(_m)
}

// QueryBeacons queries the "beacons" edge of the Host entity.
func (_m *Host) QueryBeacons() *BeaconQuery {
	return NewHostClient(_m.config).QueryBeacons(_m)
}

// QueryFiles queries the "files" edge of the Host entity.
func (_m *Host) QueryFiles() *HostFileQuery {
	return NewHostClient(_m.config).QueryFiles(_m)
}

// QueryProcesses queries the "processes" edge of the Host entity.
func (_m *Host) QueryProcesses() *HostProcessQuery {
	return NewHostClient(_m.config).QueryProcesses(_m)
}

// QueryCredentials queries the "credentials" edge of the Host entity.
func (_m *Host) QueryCredentials() *HostCredentialQuery {
	return NewHostClient(_m.config).QueryCredentials(_m)
}

// Update returns a builder for updating this Host.
// Note that you need to call Host.Unwrap() before calling this method if this Host
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Host) Update() *HostUpdateOne {
	return NewHostClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the Host entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Host) Unwrap() *Host {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Host is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *Host) String() string {
	var builder strings.Builder
	builder.WriteString("Host(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("last_modified_at=")
	builder.WriteString(_m.LastModifiedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("identifier=")
	builder.WriteString(_m.Identifier)
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(_m.Name)
	builder.WriteString(", ")
	builder.WriteString("primary_ip=")
	builder.WriteString(_m.PrimaryIP)
	builder.WriteString(", ")
	builder.WriteString("external_ip=")
	builder.WriteString(_m.ExternalIP)
	builder.WriteString(", ")
	builder.WriteString("platform=")
	builder.WriteString(fmt.Sprintf("%v", _m.Platform))
	builder.WriteString(", ")
	builder.WriteString("last_seen_at=")
	builder.WriteString(_m.LastSeenAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("next_seen_at=")
	builder.WriteString(_m.NextSeenAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// NamedTags returns the Tags named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Host) NamedTags(name string) ([]*Tag, error) {
	if _m.Edges.namedTags == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedTags[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Host) appendNamedTags(name string, edges ...*Tag) {
	if _m.Edges.namedTags == nil {
		_m.Edges.namedTags = make(map[string][]*Tag)
	}
	if len(edges) == 0 {
		_m.Edges.namedTags[name] = []*Tag{}
	} else {
		_m.Edges.namedTags[name] = append(_m.Edges.namedTags[name], edges...)
	}
}

// NamedBeacons returns the Beacons named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Host) NamedBeacons(name string) ([]*Beacon, error) {
	if _m.Edges.namedBeacons == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedBeacons[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Host) appendNamedBeacons(name string, edges ...*Beacon) {
	if _m.Edges.namedBeacons == nil {
		_m.Edges.namedBeacons = make(map[string][]*Beacon)
	}
	if len(edges) == 0 {
		_m.Edges.namedBeacons[name] = []*Beacon{}
	} else {
		_m.Edges.namedBeacons[name] = append(_m.Edges.namedBeacons[name], edges...)
	}
}

// NamedFiles returns the Files named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Host) NamedFiles(name string) ([]*HostFile, error) {
	if _m.Edges.namedFiles == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedFiles[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Host) appendNamedFiles(name string, edges ...*HostFile) {
	if _m.Edges.namedFiles == nil {
		_m.Edges.namedFiles = make(map[string][]*HostFile)
	}
	if len(edges) == 0 {
		_m.Edges.namedFiles[name] = []*HostFile{}
	} else {
		_m.Edges.namedFiles[name] = append(_m.Edges.namedFiles[name], edges...)
	}
}

// NamedProcesses returns the Processes named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Host) NamedProcesses(name string) ([]*HostProcess, error) {
	if _m.Edges.namedProcesses == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedProcesses[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Host) appendNamedProcesses(name string, edges ...*HostProcess) {
	if _m.Edges.namedProcesses == nil {
		_m.Edges.namedProcesses = make(map[string][]*HostProcess)
	}
	if len(edges) == 0 {
		_m.Edges.namedProcesses[name] = []*HostProcess{}
	} else {
		_m.Edges.namedProcesses[name] = append(_m.Edges.namedProcesses[name], edges...)
	}
}

// NamedCredentials returns the Credentials named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *Host) NamedCredentials(name string) ([]*HostCredential, error) {
	if _m.Edges.namedCredentials == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedCredentials[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *Host) appendNamedCredentials(name string, edges ...*HostCredential) {
	if _m.Edges.namedCredentials == nil {
		_m.Edges.namedCredentials = make(map[string][]*HostCredential)
	}
	if len(edges) == 0 {
		_m.Edges.namedCredentials[name] = []*HostCredential{}
	} else {
		_m.Edges.namedCredentials[name] = append(_m.Edges.namedCredentials[name], edges...)
	}
}

// Hosts is a parsable slice of Host.
type Hosts []*Host
