package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	"realm.pub/tavern/internal/ent"
	"realm.pub/tavern/internal/ent/beacon"
	"realm.pub/tavern/internal/ent/host"
	"realm.pub/tavern/internal/ent/quest"
	"realm.pub/tavern/internal/ent/tag"
	"realm.pub/tavern/internal/ent/task"
	"realm.pub/tavern/internal/ent/tome"
	"realm.pub/tavern/internal/graphql/models"
)

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) (*models.Dashboard, error) {
	dashboard := &models.Dashboard{
		HostMetrics: &models.DashboardHostMetrics{
			Group:    []*models.DashboardHostMetric{},
			Service:  []*models.DashboardHostMetric{},
			Platform: []*models.DashboardHostMetric{},
		},
		QuestMetrics: &models.DashboardQuestMetrics{
			TomeUsage:    []*models.DashboardQuestMetric{},
			TaskTimeline: []*models.DashboardTimelineItem{},
			TaskTactics:  []string{},
			GroupUsage:   []*models.DashboardQuestMetric{},
			ServiceUsage: []*models.DashboardQuestMetric{},
		},
	}

	// --- Host Metrics ---

	// Fetch Hosts with Beacons and Tags, selecting only necessary fields
	hosts, err := r.client.Host.Query().
		Select(host.FieldID, host.FieldPlatform, host.FieldLastSeenAt).
		WithBeacons(func(b *ent.BeaconQuery) {
			b.Select(beacon.FieldLastSeenAt, beacon.FieldInterval)
		}).
		WithTags(func(t *ent.TagQuery) {
			t.Select(tag.FieldName, tag.FieldKind, tag.FieldID)
		}).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query hosts: %w", err)
	}

	groupMetrics := make(map[string]*models.DashboardHostMetric)
	serviceMetrics := make(map[string]*models.DashboardHostMetric)
	platformMetrics := make(map[string]*models.DashboardHostMetric)

	now := time.Now()

	var onlineHostCount, offlineHostCount, totalHostCount int

	for _, h := range hosts {
		isOnline := false
		onlineBeacons := 0
		offlineBeacons := 0

		for _, b := range h.Edges.Beacons {
			// interval is uint64 seconds
			interval := time.Duration(b.Interval) * time.Second
			// logic: lastSeenAt + interval + 1m >= now
			deadline := b.LastSeenAt.Add(interval).Add(time.Minute)
			if deadline.After(now) {
				onlineBeacons++
				isOnline = true
			} else {
				offlineBeacons++
			}
		}

		totalHostCount++
		if isOnline {
			onlineHostCount++
		} else {
			offlineHostCount++
		}

		// Helper to update metrics map
		updateMetric := func(m map[string]*models.DashboardHostMetric, key string, id string, lastSeen time.Time) {
			if _, ok := m[key]; !ok {
				m[key] = &models.DashboardHostMetric{
					Tag:   key,
					TagID: id,
				}
			}
			entry := m[key]
			entry.Total += (onlineBeacons + offlineBeacons)
			entry.Online += onlineBeacons
			entry.HostsTotal++
			if isOnline {
				entry.HostsOnline++
			}
			if !lastSeen.IsZero() {
				if entry.LastSeenAt == nil || lastSeen.After(*entry.LastSeenAt) {
					t := lastSeen
					entry.LastSeenAt = &t
				}
			}
		}

		// Update Group Metrics
		for _, tg := range h.Edges.Tags {
			if tg.Kind == tag.KindGroup {
				updateMetric(groupMetrics, tg.Name, strconv.Itoa(tg.ID), h.LastSeenAt)
			} else if tg.Kind == tag.KindService {
				updateMetric(serviceMetrics, tg.Name, strconv.Itoa(tg.ID), h.LastSeenAt)
			}
		}

		// Update Platform Metrics
		updateMetric(platformMetrics, h.Platform.String(), h.Platform.String(), h.LastSeenAt)
	}

	dashboard.HostMetrics.OnlineHostCount = onlineHostCount
	dashboard.HostMetrics.OfflineHostCount = offlineHostCount
	dashboard.HostMetrics.TotalHostCount = totalHostCount
	dashboard.HostMetrics.Group = values(groupMetrics)
	dashboard.HostMetrics.Service = values(serviceMetrics)
	dashboard.HostMetrics.Platform = values(platformMetrics)

	// --- Quest Metrics ---

	// Fetch Tasks with Quest->Tome and Beacon->Host->Tags
	// Optimize: Select only needed fields. Exclude potentially large Output.
	tasks, err := r.client.Task.Query().
		Select(task.FieldID, task.FieldCreatedAt, task.FieldError, task.FieldOutputSize).
		WithQuest(func(q *ent.QuestQuery) {
			q.Select(quest.FieldID).WithTome(func(t *ent.TomeQuery) {
				t.Select(tome.FieldName, tome.FieldTactic, tome.FieldID)
			})
		}).
		WithBeacon(func(b *ent.BeaconQuery) {
			b.Select(beacon.FieldID).WithHost(func(h *ent.HostQuery) {
				h.Select(host.FieldID).WithTags(func(t *ent.TagQuery) {
					t.Select(tag.FieldName, tag.FieldKind, tag.FieldID)
				})
			})
		}).
		Order(ent.Asc(task.FieldCreatedAt)). // Order by creation for timeline
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query tasks: %w", err)
	}

	tomeUsage := make(map[string]*models.DashboardQuestMetric)
	groupUsage := make(map[string]*models.DashboardQuestMetric)
	serviceUsage := make(map[string]*models.DashboardQuestMetric)
	uniqueQuests := make(map[int]bool)
	uniqueTactics := make(map[string]bool)

	// Timeline map: key = hour timestamp (time.Time), value = *DashboardTimelineItem
	timelineMap := make(map[time.Time]*models.DashboardTimelineItem)
	// To keep order of hours encountered
	var timelineKeys []time.Time
	seenTimelineKeys := make(map[time.Time]bool)

	var totalOutput, totalErrors int

	updateQuestMetric := func(m map[string]*models.DashboardQuestMetric, key string, id string, hasError bool) {
		if _, ok := m[key]; !ok {
			m[key] = &models.DashboardQuestMetric{Name: key, ID: id}
		}
		if hasError {
			m[key].TasksError++
		} else {
			m[key].TasksNoError++
		}
	}

	for _, t := range tasks {
		hasError := t.Error != ""
		if hasError {
			totalErrors++
		}
		if t.OutputSize > 0 {
			totalOutput++
		}

		if t.Edges.Quest != nil {
			uniqueQuests[t.Edges.Quest.ID] = true
			if t.Edges.Quest.Edges.Tome != nil {
				tome := t.Edges.Quest.Edges.Tome
				updateQuestMetric(tomeUsage, tome.Name, strconv.Itoa(tome.ID), hasError)

				tacticStr := strings.ToLower(string(tome.Tactic))
				uniqueTactics[tacticStr] = true

				// Timeline
				hour := t.CreatedAt.Truncate(time.Hour)
				if _, ok := timelineMap[hour]; !ok {
					item := &models.DashboardTimelineItem{
						Label:     hour.Format("Mon 3PM"), // "iii haaa" roughly
						Timestamp: hour,
						Tactics:   []*models.DashboardTacticCount{},
					}
					timelineMap[hour] = item
					if !seenTimelineKeys[hour] {
						timelineKeys = append(timelineKeys, hour)
						seenTimelineKeys[hour] = true
					}
				}
				item := timelineMap[hour]
				item.TaskCreated++

				found := false
				for _, tac := range item.Tactics {
					if tac.Tactic == tacticStr {
						tac.Count++
						found = true
						break
					}
				}
				if !found {
					item.Tactics = append(item.Tactics, &models.DashboardTacticCount{
						Tactic: tacticStr,
						Count:  1,
					})
				}
			}
		}

		if t.Edges.Beacon != nil && t.Edges.Beacon.Edges.Host != nil {
			host := t.Edges.Beacon.Edges.Host
			for _, tg := range host.Edges.Tags {
				if tg.Kind == tag.KindGroup {
					updateQuestMetric(groupUsage, tg.Name, strconv.Itoa(tg.ID), hasError)
				} else if tg.Kind == tag.KindService {
					updateQuestMetric(serviceUsage, tg.Name, strconv.Itoa(tg.ID), hasError)
				}
			}
		}
	}

	dashboard.QuestMetrics.TotalTasks = len(tasks)
	dashboard.QuestMetrics.TotalQuests = len(uniqueQuests)
	dashboard.QuestMetrics.TotalOutput = totalOutput
	dashboard.QuestMetrics.TotalErrors = totalErrors

	dashboard.QuestMetrics.TomeUsage = valuesQuest(tomeUsage)
	dashboard.QuestMetrics.GroupUsage = valuesQuest(groupUsage)
	dashboard.QuestMetrics.ServiceUsage = valuesQuest(serviceUsage)

	for tactic := range uniqueTactics {
		dashboard.QuestMetrics.TaskTactics = append(dashboard.QuestMetrics.TaskTactics, tactic)
	}

	// Sort timeline keys to be sure
	sort.Slice(timelineKeys, func(i, j int) bool {
		return timelineKeys[i].Before(timelineKeys[j])
	})

	for _, k := range timelineKeys {
		dashboard.QuestMetrics.TaskTimeline = append(dashboard.QuestMetrics.TaskTimeline, timelineMap[k])
	}

	return dashboard, nil
}

func values(m map[string]*models.DashboardHostMetric) []*models.DashboardHostMetric {
	v := make([]*models.DashboardHostMetric, 0, len(m))
	for _, val := range m {
		v = append(v, val)
	}
	return v
}

func valuesQuest(m map[string]*models.DashboardQuestMetric) []*models.DashboardQuestMetric {
	v := make([]*models.DashboardQuestMetric, 0, len(m))
	for _, val := range m {
		v = append(v, val)
	}
	return v
}
