// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"realm.pub/tavern/internal/ent"
	"realm.pub/tavern/internal/graphql/models"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	RequireRole func(ctx context.Context, obj any, next graphql.Resolver, role models.Role) (res any, err error)
}

type ComplexityRoot struct {
	Beacon struct {
		AgentIdentifier func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Host            func(childComplexity int) int
		ID              func(childComplexity int) int
		Identifier      func(childComplexity int) int
		Interval        func(childComplexity int) int
		LastModifiedAt  func(childComplexity int) int
		LastSeenAt      func(childComplexity int) int
		Name            func(childComplexity int) int
		NextSeenAt      func(childComplexity int) int
		Principal       func(childComplexity int) int
		Shells          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellOrder, where *ent.ShellWhereInput) int
		Tasks           func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Transport       func(childComplexity int) int
	}

	BeaconConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BeaconEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	File struct {
		CreatedAt      func(childComplexity int) int
		Hash           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Size           func(childComplexity int) int
		Tomes          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TomeOrder, where *ent.TomeWhereInput) int
	}

	FileConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	FileEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Host struct {
		Beacons        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.BeaconOrder, where *ent.BeaconWhereInput) int
		CreatedAt      func(childComplexity int) int
		Credentials    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostCredentialOrder, where *ent.HostCredentialWhereInput) int
		ExternalIP     func(childComplexity int) int
		Files          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostFileOrder, where *ent.HostFileWhereInput) int
		ID             func(childComplexity int) int
		Identifier     func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		LastSeenAt     func(childComplexity int) int
		Name           func(childComplexity int) int
		NextSeenAt     func(childComplexity int) int
		Platform       func(childComplexity int) int
		PrimaryIP      func(childComplexity int) int
		Processes      func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostProcessOrder, where *ent.HostProcessWhereInput) int
		Tags           func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TagOrder, where *ent.TagWhereInput) int
	}

	HostConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HostCredential struct {
		CreatedAt      func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		Kind           func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Principal      func(childComplexity int) int
		Secret         func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	HostCredentialConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HostCredentialEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	HostEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	HostFile struct {
		CreatedAt      func(childComplexity int) int
		Group          func(childComplexity int) int
		Hash           func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Owner          func(childComplexity int) int
		Path           func(childComplexity int) int
		Permissions    func(childComplexity int) int
		Size           func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	HostFileConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HostFileEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	HostProcess struct {
		Cmd            func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Cwd            func(childComplexity int) int
		Env            func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Pid            func(childComplexity int) int
		Ppid           func(childComplexity int) int
		Principal      func(childComplexity int) int
		Status         func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	HostProcessConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HostProcessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		CreateCredential func(childComplexity int, input ent.CreateHostCredentialInput) int
		CreateQuest      func(childComplexity int, beaconIDs []int, input ent.CreateQuestInput) int
		CreateRepository func(childComplexity int, input ent.CreateRepositoryInput) int
		CreateTag        func(childComplexity int, input ent.CreateTagInput) int
		CreateTome       func(childComplexity int, input ent.CreateTomeInput) int
		DeleteTome       func(childComplexity int, tomeID int) int
		DropAllData      func(childComplexity int) int
		ImportRepository func(childComplexity int, repoID int, input *models.ImportRepositoryInput) int
		UpdateBeacon     func(childComplexity int, beaconID int, input ent.UpdateBeaconInput) int
		UpdateHost       func(childComplexity int, hostID int, input ent.UpdateHostInput) int
		UpdateTag        func(childComplexity int, tagID int, input ent.UpdateTagInput) int
		UpdateTome       func(childComplexity int, tomeID int, input ent.UpdateTomeInput) int
		UpdateUser       func(childComplexity int, userID int, input ent.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Beacons      func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.BeaconOrder, where *ent.BeaconWhereInput) int
		Files        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.FileOrder, where *ent.FileWhereInput) int
		Hosts        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostOrder, where *ent.HostWhereInput) int
		Me           func(childComplexity int) int
		Node         func(childComplexity int, id int) int
		Nodes        func(childComplexity int, ids []int) int
		Quests       func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.QuestOrder, where *ent.QuestWhereInput) int
		Repositories func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.RepositoryOrder, where *ent.RepositoryWhereInput) int
		Shells       func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellOrder, where *ent.ShellWhereInput) int
		Tags         func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TagOrder, where *ent.TagWhereInput) int
		Tasks        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Tomes        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TomeOrder, where *ent.TomeWhereInput) int
		Users        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
	}

	Quest struct {
		Bundle              func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		Creator             func(childComplexity int) int
		EldritchAtCreation  func(childComplexity int) int
		ID                  func(childComplexity int) int
		LastModifiedAt      func(childComplexity int) int
		Name                func(childComplexity int) int
		ParamDefsAtCreation func(childComplexity int) int
		Parameters          func(childComplexity int) int
		Tasks               func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Tome                func(childComplexity int) int
	}

	QuestConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	QuestEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Repository struct {
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastImportedAt func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Owner          func(childComplexity int) int
		PublicKey      func(childComplexity int) int
		Tomes          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TomeOrder, where *ent.TomeWhereInput) int
		URL            func(childComplexity int) int
	}

	RepositoryConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Shell struct {
		ActiveUsers    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
		Beacon         func(childComplexity int) int
		ClosedAt       func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Owner          func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	ShellConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ShellEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Tag struct {
		Hosts func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostOrder, where *ent.HostWhereInput) int
		ID    func(childComplexity int) int
		Kind  func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	TagConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TagEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Task struct {
		Beacon              func(childComplexity int) int
		ClaimedAt           func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		Error               func(childComplexity int) int
		ExecFinishedAt      func(childComplexity int) int
		ExecStartedAt       func(childComplexity int) int
		ID                  func(childComplexity int) int
		LastModifiedAt      func(childComplexity int) int
		Output              func(childComplexity int) int
		OutputSize          func(childComplexity int) int
		Quest               func(childComplexity int) int
		ReportedCredentials func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostCredentialOrder, where *ent.HostCredentialWhereInput) int
		ReportedFiles       func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostFileOrder, where *ent.HostFileWhereInput) int
		ReportedProcesses   func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostProcessOrder, where *ent.HostProcessWhereInput) int
		Shells              func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellOrder, where *ent.ShellWhereInput) int
	}

	TaskConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TaskEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Tome struct {
		Author         func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Description    func(childComplexity int) int
		Eldritch       func(childComplexity int) int
		Files          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.FileOrder, where *ent.FileWhereInput) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		ParamDefs      func(childComplexity int) int
		Repository     func(childComplexity int) int
		SupportModel   func(childComplexity int) int
		Tactic         func(childComplexity int) int
		Uploader       func(childComplexity int) int
	}

	TomeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TomeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	User struct {
		ActiveShells func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellOrder, where *ent.ShellWhereInput) int
		ID           func(childComplexity int) int
		IsActivated  func(childComplexity int) int
		IsAdmin      func(childComplexity int) int
		Name         func(childComplexity int) int
		PhotoURL     func(childComplexity int) int
		Tomes        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TomeOrder, where *ent.TomeWhereInput) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Beacon.agentIdentifier":
		if e.complexity.Beacon.AgentIdentifier == nil {
			break
		}

		return e.complexity.Beacon.AgentIdentifier(childComplexity), true

	case "Beacon.createdAt":
		if e.complexity.Beacon.CreatedAt == nil {
			break
		}

		return e.complexity.Beacon.CreatedAt(childComplexity), true

	case "Beacon.host":
		if e.complexity.Beacon.Host == nil {
			break
		}

		return e.complexity.Beacon.Host(childComplexity), true

	case "Beacon.id":
		if e.complexity.Beacon.ID == nil {
			break
		}

		return e.complexity.Beacon.ID(childComplexity), true

	case "Beacon.identifier":
		if e.complexity.Beacon.Identifier == nil {
			break
		}

		return e.complexity.Beacon.Identifier(childComplexity), true

	case "Beacon.interval":
		if e.complexity.Beacon.Interval == nil {
			break
		}

		return e.complexity.Beacon.Interval(childComplexity), true

	case "Beacon.lastModifiedAt":
		if e.complexity.Beacon.LastModifiedAt == nil {
			break
		}

		return e.complexity.Beacon.LastModifiedAt(childComplexity), true

	case "Beacon.lastSeenAt":
		if e.complexity.Beacon.LastSeenAt == nil {
			break
		}

		return e.complexity.Beacon.LastSeenAt(childComplexity), true

	case "Beacon.name":
		if e.complexity.Beacon.Name == nil {
			break
		}

		return e.complexity.Beacon.Name(childComplexity), true

	case "Beacon.nextSeenAt":
		if e.complexity.Beacon.NextSeenAt == nil {
			break
		}

		return e.complexity.Beacon.NextSeenAt(childComplexity), true

	case "Beacon.principal":
		if e.complexity.Beacon.Principal == nil {
			break
		}

		return e.complexity.Beacon.Principal(childComplexity), true

	case "Beacon.shells":
		if e.complexity.Beacon.Shells == nil {
			break
		}

		args, err := ec.field_Beacon_shells_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Beacon.Shells(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellOrder), args["where"].(*ent.ShellWhereInput)), true

	case "Beacon.tasks":
		if e.complexity.Beacon.Tasks == nil {
			break
		}

		args, err := ec.field_Beacon_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Beacon.Tasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Beacon.transport":
		if e.complexity.Beacon.Transport == nil {
			break
		}

		return e.complexity.Beacon.Transport(childComplexity), true

	case "BeaconConnection.edges":
		if e.complexity.BeaconConnection.Edges == nil {
			break
		}

		return e.complexity.BeaconConnection.Edges(childComplexity), true

	case "BeaconConnection.pageInfo":
		if e.complexity.BeaconConnection.PageInfo == nil {
			break
		}

		return e.complexity.BeaconConnection.PageInfo(childComplexity), true

	case "BeaconConnection.totalCount":
		if e.complexity.BeaconConnection.TotalCount == nil {
			break
		}

		return e.complexity.BeaconConnection.TotalCount(childComplexity), true

	case "BeaconEdge.cursor":
		if e.complexity.BeaconEdge.Cursor == nil {
			break
		}

		return e.complexity.BeaconEdge.Cursor(childComplexity), true

	case "BeaconEdge.node":
		if e.complexity.BeaconEdge.Node == nil {
			break
		}

		return e.complexity.BeaconEdge.Node(childComplexity), true

	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.hash":
		if e.complexity.File.Hash == nil {
			break
		}

		return e.complexity.File.Hash(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.lastModifiedAt":
		if e.complexity.File.LastModifiedAt == nil {
			break
		}

		return e.complexity.File.LastModifiedAt(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "File.tomes":
		if e.complexity.File.Tomes == nil {
			break
		}

		args, err := ec.field_File_tomes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.File.Tomes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TomeOrder), args["where"].(*ent.TomeWhereInput)), true

	case "FileConnection.edges":
		if e.complexity.FileConnection.Edges == nil {
			break
		}

		return e.complexity.FileConnection.Edges(childComplexity), true

	case "FileConnection.pageInfo":
		if e.complexity.FileConnection.PageInfo == nil {
			break
		}

		return e.complexity.FileConnection.PageInfo(childComplexity), true

	case "FileConnection.totalCount":
		if e.complexity.FileConnection.TotalCount == nil {
			break
		}

		return e.complexity.FileConnection.TotalCount(childComplexity), true

	case "FileEdge.cursor":
		if e.complexity.FileEdge.Cursor == nil {
			break
		}

		return e.complexity.FileEdge.Cursor(childComplexity), true

	case "FileEdge.node":
		if e.complexity.FileEdge.Node == nil {
			break
		}

		return e.complexity.FileEdge.Node(childComplexity), true

	case "Host.beacons":
		if e.complexity.Host.Beacons == nil {
			break
		}

		args, err := ec.field_Host_beacons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Beacons(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.BeaconOrder), args["where"].(*ent.BeaconWhereInput)), true

	case "Host.createdAt":
		if e.complexity.Host.CreatedAt == nil {
			break
		}

		return e.complexity.Host.CreatedAt(childComplexity), true

	case "Host.credentials":
		if e.complexity.Host.Credentials == nil {
			break
		}

		args, err := ec.field_Host_credentials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Credentials(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostCredentialOrder), args["where"].(*ent.HostCredentialWhereInput)), true

	case "Host.externalIP":
		if e.complexity.Host.ExternalIP == nil {
			break
		}

		return e.complexity.Host.ExternalIP(childComplexity), true

	case "Host.files":
		if e.complexity.Host.Files == nil {
			break
		}

		args, err := ec.field_Host_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Files(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostFileOrder), args["where"].(*ent.HostFileWhereInput)), true

	case "Host.id":
		if e.complexity.Host.ID == nil {
			break
		}

		return e.complexity.Host.ID(childComplexity), true

	case "Host.identifier":
		if e.complexity.Host.Identifier == nil {
			break
		}

		return e.complexity.Host.Identifier(childComplexity), true

	case "Host.lastModifiedAt":
		if e.complexity.Host.LastModifiedAt == nil {
			break
		}

		return e.complexity.Host.LastModifiedAt(childComplexity), true

	case "Host.lastSeenAt":
		if e.complexity.Host.LastSeenAt == nil {
			break
		}

		return e.complexity.Host.LastSeenAt(childComplexity), true

	case "Host.name":
		if e.complexity.Host.Name == nil {
			break
		}

		return e.complexity.Host.Name(childComplexity), true

	case "Host.nextSeenAt":
		if e.complexity.Host.NextSeenAt == nil {
			break
		}

		return e.complexity.Host.NextSeenAt(childComplexity), true

	case "Host.platform":
		if e.complexity.Host.Platform == nil {
			break
		}

		return e.complexity.Host.Platform(childComplexity), true

	case "Host.primaryIP":
		if e.complexity.Host.PrimaryIP == nil {
			break
		}

		return e.complexity.Host.PrimaryIP(childComplexity), true

	case "Host.processes":
		if e.complexity.Host.Processes == nil {
			break
		}

		args, err := ec.field_Host_processes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Processes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostProcessOrder), args["where"].(*ent.HostProcessWhereInput)), true

	case "Host.tags":
		if e.complexity.Host.Tags == nil {
			break
		}

		args, err := ec.field_Host_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Tags(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TagOrder), args["where"].(*ent.TagWhereInput)), true

	case "HostConnection.edges":
		if e.complexity.HostConnection.Edges == nil {
			break
		}

		return e.complexity.HostConnection.Edges(childComplexity), true

	case "HostConnection.pageInfo":
		if e.complexity.HostConnection.PageInfo == nil {
			break
		}

		return e.complexity.HostConnection.PageInfo(childComplexity), true

	case "HostConnection.totalCount":
		if e.complexity.HostConnection.TotalCount == nil {
			break
		}

		return e.complexity.HostConnection.TotalCount(childComplexity), true

	case "HostCredential.createdAt":
		if e.complexity.HostCredential.CreatedAt == nil {
			break
		}

		return e.complexity.HostCredential.CreatedAt(childComplexity), true

	case "HostCredential.host":
		if e.complexity.HostCredential.Host == nil {
			break
		}

		return e.complexity.HostCredential.Host(childComplexity), true

	case "HostCredential.id":
		if e.complexity.HostCredential.ID == nil {
			break
		}

		return e.complexity.HostCredential.ID(childComplexity), true

	case "HostCredential.kind":
		if e.complexity.HostCredential.Kind == nil {
			break
		}

		return e.complexity.HostCredential.Kind(childComplexity), true

	case "HostCredential.lastModifiedAt":
		if e.complexity.HostCredential.LastModifiedAt == nil {
			break
		}

		return e.complexity.HostCredential.LastModifiedAt(childComplexity), true

	case "HostCredential.principal":
		if e.complexity.HostCredential.Principal == nil {
			break
		}

		return e.complexity.HostCredential.Principal(childComplexity), true

	case "HostCredential.secret":
		if e.complexity.HostCredential.Secret == nil {
			break
		}

		return e.complexity.HostCredential.Secret(childComplexity), true

	case "HostCredential.task":
		if e.complexity.HostCredential.Task == nil {
			break
		}

		return e.complexity.HostCredential.Task(childComplexity), true

	case "HostCredentialConnection.edges":
		if e.complexity.HostCredentialConnection.Edges == nil {
			break
		}

		return e.complexity.HostCredentialConnection.Edges(childComplexity), true

	case "HostCredentialConnection.pageInfo":
		if e.complexity.HostCredentialConnection.PageInfo == nil {
			break
		}

		return e.complexity.HostCredentialConnection.PageInfo(childComplexity), true

	case "HostCredentialConnection.totalCount":
		if e.complexity.HostCredentialConnection.TotalCount == nil {
			break
		}

		return e.complexity.HostCredentialConnection.TotalCount(childComplexity), true

	case "HostCredentialEdge.cursor":
		if e.complexity.HostCredentialEdge.Cursor == nil {
			break
		}

		return e.complexity.HostCredentialEdge.Cursor(childComplexity), true

	case "HostCredentialEdge.node":
		if e.complexity.HostCredentialEdge.Node == nil {
			break
		}

		return e.complexity.HostCredentialEdge.Node(childComplexity), true

	case "HostEdge.cursor":
		if e.complexity.HostEdge.Cursor == nil {
			break
		}

		return e.complexity.HostEdge.Cursor(childComplexity), true

	case "HostEdge.node":
		if e.complexity.HostEdge.Node == nil {
			break
		}

		return e.complexity.HostEdge.Node(childComplexity), true

	case "HostFile.createdAt":
		if e.complexity.HostFile.CreatedAt == nil {
			break
		}

		return e.complexity.HostFile.CreatedAt(childComplexity), true

	case "HostFile.group":
		if e.complexity.HostFile.Group == nil {
			break
		}

		return e.complexity.HostFile.Group(childComplexity), true

	case "HostFile.hash":
		if e.complexity.HostFile.Hash == nil {
			break
		}

		return e.complexity.HostFile.Hash(childComplexity), true

	case "HostFile.host":
		if e.complexity.HostFile.Host == nil {
			break
		}

		return e.complexity.HostFile.Host(childComplexity), true

	case "HostFile.id":
		if e.complexity.HostFile.ID == nil {
			break
		}

		return e.complexity.HostFile.ID(childComplexity), true

	case "HostFile.lastModifiedAt":
		if e.complexity.HostFile.LastModifiedAt == nil {
			break
		}

		return e.complexity.HostFile.LastModifiedAt(childComplexity), true

	case "HostFile.owner":
		if e.complexity.HostFile.Owner == nil {
			break
		}

		return e.complexity.HostFile.Owner(childComplexity), true

	case "HostFile.path":
		if e.complexity.HostFile.Path == nil {
			break
		}

		return e.complexity.HostFile.Path(childComplexity), true

	case "HostFile.permissions":
		if e.complexity.HostFile.Permissions == nil {
			break
		}

		return e.complexity.HostFile.Permissions(childComplexity), true

	case "HostFile.size":
		if e.complexity.HostFile.Size == nil {
			break
		}

		return e.complexity.HostFile.Size(childComplexity), true

	case "HostFile.task":
		if e.complexity.HostFile.Task == nil {
			break
		}

		return e.complexity.HostFile.Task(childComplexity), true

	case "HostFileConnection.edges":
		if e.complexity.HostFileConnection.Edges == nil {
			break
		}

		return e.complexity.HostFileConnection.Edges(childComplexity), true

	case "HostFileConnection.pageInfo":
		if e.complexity.HostFileConnection.PageInfo == nil {
			break
		}

		return e.complexity.HostFileConnection.PageInfo(childComplexity), true

	case "HostFileConnection.totalCount":
		if e.complexity.HostFileConnection.TotalCount == nil {
			break
		}

		return e.complexity.HostFileConnection.TotalCount(childComplexity), true

	case "HostFileEdge.cursor":
		if e.complexity.HostFileEdge.Cursor == nil {
			break
		}

		return e.complexity.HostFileEdge.Cursor(childComplexity), true

	case "HostFileEdge.node":
		if e.complexity.HostFileEdge.Node == nil {
			break
		}

		return e.complexity.HostFileEdge.Node(childComplexity), true

	case "HostProcess.cmd":
		if e.complexity.HostProcess.Cmd == nil {
			break
		}

		return e.complexity.HostProcess.Cmd(childComplexity), true

	case "HostProcess.createdAt":
		if e.complexity.HostProcess.CreatedAt == nil {
			break
		}

		return e.complexity.HostProcess.CreatedAt(childComplexity), true

	case "HostProcess.cwd":
		if e.complexity.HostProcess.Cwd == nil {
			break
		}

		return e.complexity.HostProcess.Cwd(childComplexity), true

	case "HostProcess.env":
		if e.complexity.HostProcess.Env == nil {
			break
		}

		return e.complexity.HostProcess.Env(childComplexity), true

	case "HostProcess.host":
		if e.complexity.HostProcess.Host == nil {
			break
		}

		return e.complexity.HostProcess.Host(childComplexity), true

	case "HostProcess.id":
		if e.complexity.HostProcess.ID == nil {
			break
		}

		return e.complexity.HostProcess.ID(childComplexity), true

	case "HostProcess.lastModifiedAt":
		if e.complexity.HostProcess.LastModifiedAt == nil {
			break
		}

		return e.complexity.HostProcess.LastModifiedAt(childComplexity), true

	case "HostProcess.name":
		if e.complexity.HostProcess.Name == nil {
			break
		}

		return e.complexity.HostProcess.Name(childComplexity), true

	case "HostProcess.path":
		if e.complexity.HostProcess.Path == nil {
			break
		}

		return e.complexity.HostProcess.Path(childComplexity), true

	case "HostProcess.pid":
		if e.complexity.HostProcess.Pid == nil {
			break
		}

		return e.complexity.HostProcess.Pid(childComplexity), true

	case "HostProcess.ppid":
		if e.complexity.HostProcess.Ppid == nil {
			break
		}

		return e.complexity.HostProcess.Ppid(childComplexity), true

	case "HostProcess.principal":
		if e.complexity.HostProcess.Principal == nil {
			break
		}

		return e.complexity.HostProcess.Principal(childComplexity), true

	case "HostProcess.status":
		if e.complexity.HostProcess.Status == nil {
			break
		}

		return e.complexity.HostProcess.Status(childComplexity), true

	case "HostProcess.task":
		if e.complexity.HostProcess.Task == nil {
			break
		}

		return e.complexity.HostProcess.Task(childComplexity), true

	case "HostProcessConnection.edges":
		if e.complexity.HostProcessConnection.Edges == nil {
			break
		}

		return e.complexity.HostProcessConnection.Edges(childComplexity), true

	case "HostProcessConnection.pageInfo":
		if e.complexity.HostProcessConnection.PageInfo == nil {
			break
		}

		return e.complexity.HostProcessConnection.PageInfo(childComplexity), true

	case "HostProcessConnection.totalCount":
		if e.complexity.HostProcessConnection.TotalCount == nil {
			break
		}

		return e.complexity.HostProcessConnection.TotalCount(childComplexity), true

	case "HostProcessEdge.cursor":
		if e.complexity.HostProcessEdge.Cursor == nil {
			break
		}

		return e.complexity.HostProcessEdge.Cursor(childComplexity), true

	case "HostProcessEdge.node":
		if e.complexity.HostProcessEdge.Node == nil {
			break
		}

		return e.complexity.HostProcessEdge.Node(childComplexity), true

	case "Mutation.createCredential":
		if e.complexity.Mutation.CreateCredential == nil {
			break
		}

		args, err := ec.field_Mutation_createCredential_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCredential(childComplexity, args["input"].(ent.CreateHostCredentialInput)), true

	case "Mutation.createQuest":
		if e.complexity.Mutation.CreateQuest == nil {
			break
		}

		args, err := ec.field_Mutation_createQuest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateQuest(childComplexity, args["beaconIDs"].([]int), args["input"].(ent.CreateQuestInput)), true

	case "Mutation.createRepository":
		if e.complexity.Mutation.CreateRepository == nil {
			break
		}

		args, err := ec.field_Mutation_createRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRepository(childComplexity, args["input"].(ent.CreateRepositoryInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(ent.CreateTagInput)), true

	case "Mutation.createTome":
		if e.complexity.Mutation.CreateTome == nil {
			break
		}

		args, err := ec.field_Mutation_createTome_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTome(childComplexity, args["input"].(ent.CreateTomeInput)), true

	case "Mutation.deleteTome":
		if e.complexity.Mutation.DeleteTome == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTome_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTome(childComplexity, args["tomeID"].(int)), true

	case "Mutation.dropAllData":
		if e.complexity.Mutation.DropAllData == nil {
			break
		}

		return e.complexity.Mutation.DropAllData(childComplexity), true

	case "Mutation.importRepository":
		if e.complexity.Mutation.ImportRepository == nil {
			break
		}

		args, err := ec.field_Mutation_importRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ImportRepository(childComplexity, args["repoID"].(int), args["input"].(*models.ImportRepositoryInput)), true

	case "Mutation.updateBeacon":
		if e.complexity.Mutation.UpdateBeacon == nil {
			break
		}

		args, err := ec.field_Mutation_updateBeacon_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBeacon(childComplexity, args["beaconID"].(int), args["input"].(ent.UpdateBeaconInput)), true

	case "Mutation.updateHost":
		if e.complexity.Mutation.UpdateHost == nil {
			break
		}

		args, err := ec.field_Mutation_updateHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHost(childComplexity, args["hostID"].(int), args["input"].(ent.UpdateHostInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["tagID"].(int), args["input"].(ent.UpdateTagInput)), true

	case "Mutation.updateTome":
		if e.complexity.Mutation.UpdateTome == nil {
			break
		}

		args, err := ec.field_Mutation_updateTome_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTome(childComplexity, args["tomeID"].(int), args["input"].(ent.UpdateTomeInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["userID"].(int), args["input"].(ent.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.beacons":
		if e.complexity.Query.Beacons == nil {
			break
		}

		args, err := ec.field_Query_beacons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Beacons(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.BeaconOrder), args["where"].(*ent.BeaconWhereInput)), true

	case "Query.files":
		if e.complexity.Query.Files == nil {
			break
		}

		args, err := ec.field_Query_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Files(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.FileOrder), args["where"].(*ent.FileWhereInput)), true

	case "Query.hosts":
		if e.complexity.Query.Hosts == nil {
			break
		}

		args, err := ec.field_Query_hosts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hosts(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostOrder), args["where"].(*ent.HostWhereInput)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.quests":
		if e.complexity.Query.Quests == nil {
			break
		}

		args, err := ec.field_Query_quests_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Quests(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.QuestOrder), args["where"].(*ent.QuestWhereInput)), true

	case "Query.repositories":
		if e.complexity.Query.Repositories == nil {
			break
		}

		args, err := ec.field_Query_repositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Repositories(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.RepositoryOrder), args["where"].(*ent.RepositoryWhereInput)), true

	case "Query.shells":
		if e.complexity.Query.Shells == nil {
			break
		}

		args, err := ec.field_Query_shells_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Shells(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellOrder), args["where"].(*ent.ShellWhereInput)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		args, err := ec.field_Query_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tags(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TagOrder), args["where"].(*ent.TagWhereInput)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		args, err := ec.field_Query_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Query.tomes":
		if e.complexity.Query.Tomes == nil {
			break
		}

		args, err := ec.field_Query_tomes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tomes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TomeOrder), args["where"].(*ent.TomeWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Quest.bundle":
		if e.complexity.Quest.Bundle == nil {
			break
		}

		return e.complexity.Quest.Bundle(childComplexity), true

	case "Quest.createdAt":
		if e.complexity.Quest.CreatedAt == nil {
			break
		}

		return e.complexity.Quest.CreatedAt(childComplexity), true

	case "Quest.creator":
		if e.complexity.Quest.Creator == nil {
			break
		}

		return e.complexity.Quest.Creator(childComplexity), true

	case "Quest.eldritchAtCreation":
		if e.complexity.Quest.EldritchAtCreation == nil {
			break
		}

		return e.complexity.Quest.EldritchAtCreation(childComplexity), true

	case "Quest.id":
		if e.complexity.Quest.ID == nil {
			break
		}

		return e.complexity.Quest.ID(childComplexity), true

	case "Quest.lastModifiedAt":
		if e.complexity.Quest.LastModifiedAt == nil {
			break
		}

		return e.complexity.Quest.LastModifiedAt(childComplexity), true

	case "Quest.name":
		if e.complexity.Quest.Name == nil {
			break
		}

		return e.complexity.Quest.Name(childComplexity), true

	case "Quest.paramDefsAtCreation":
		if e.complexity.Quest.ParamDefsAtCreation == nil {
			break
		}

		return e.complexity.Quest.ParamDefsAtCreation(childComplexity), true

	case "Quest.parameters":
		if e.complexity.Quest.Parameters == nil {
			break
		}

		return e.complexity.Quest.Parameters(childComplexity), true

	case "Quest.tasks":
		if e.complexity.Quest.Tasks == nil {
			break
		}

		args, err := ec.field_Quest_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Quest.Tasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Quest.tome":
		if e.complexity.Quest.Tome == nil {
			break
		}

		return e.complexity.Quest.Tome(childComplexity), true

	case "QuestConnection.edges":
		if e.complexity.QuestConnection.Edges == nil {
			break
		}

		return e.complexity.QuestConnection.Edges(childComplexity), true

	case "QuestConnection.pageInfo":
		if e.complexity.QuestConnection.PageInfo == nil {
			break
		}

		return e.complexity.QuestConnection.PageInfo(childComplexity), true

	case "QuestConnection.totalCount":
		if e.complexity.QuestConnection.TotalCount == nil {
			break
		}

		return e.complexity.QuestConnection.TotalCount(childComplexity), true

	case "QuestEdge.cursor":
		if e.complexity.QuestEdge.Cursor == nil {
			break
		}

		return e.complexity.QuestEdge.Cursor(childComplexity), true

	case "QuestEdge.node":
		if e.complexity.QuestEdge.Node == nil {
			break
		}

		return e.complexity.QuestEdge.Node(childComplexity), true

	case "Repository.createdAt":
		if e.complexity.Repository.CreatedAt == nil {
			break
		}

		return e.complexity.Repository.CreatedAt(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.lastImportedAt":
		if e.complexity.Repository.LastImportedAt == nil {
			break
		}

		return e.complexity.Repository.LastImportedAt(childComplexity), true

	case "Repository.lastModifiedAt":
		if e.complexity.Repository.LastModifiedAt == nil {
			break
		}

		return e.complexity.Repository.LastModifiedAt(childComplexity), true

	case "Repository.owner":
		if e.complexity.Repository.Owner == nil {
			break
		}

		return e.complexity.Repository.Owner(childComplexity), true

	case "Repository.publicKey":
		if e.complexity.Repository.PublicKey == nil {
			break
		}

		return e.complexity.Repository.PublicKey(childComplexity), true

	case "Repository.tomes":
		if e.complexity.Repository.Tomes == nil {
			break
		}

		args, err := ec.field_Repository_tomes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Tomes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TomeOrder), args["where"].(*ent.TomeWhereInput)), true

	case "Repository.url":
		if e.complexity.Repository.URL == nil {
			break
		}

		return e.complexity.Repository.URL(childComplexity), true

	case "RepositoryConnection.edges":
		if e.complexity.RepositoryConnection.Edges == nil {
			break
		}

		return e.complexity.RepositoryConnection.Edges(childComplexity), true

	case "RepositoryConnection.pageInfo":
		if e.complexity.RepositoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.RepositoryConnection.PageInfo(childComplexity), true

	case "RepositoryConnection.totalCount":
		if e.complexity.RepositoryConnection.TotalCount == nil {
			break
		}

		return e.complexity.RepositoryConnection.TotalCount(childComplexity), true

	case "RepositoryEdge.cursor":
		if e.complexity.RepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryEdge.Cursor(childComplexity), true

	case "RepositoryEdge.node":
		if e.complexity.RepositoryEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryEdge.Node(childComplexity), true

	case "Shell.activeUsers":
		if e.complexity.Shell.ActiveUsers == nil {
			break
		}

		args, err := ec.field_Shell_activeUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Shell.ActiveUsers(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Shell.beacon":
		if e.complexity.Shell.Beacon == nil {
			break
		}

		return e.complexity.Shell.Beacon(childComplexity), true

	case "Shell.closedAt":
		if e.complexity.Shell.ClosedAt == nil {
			break
		}

		return e.complexity.Shell.ClosedAt(childComplexity), true

	case "Shell.createdAt":
		if e.complexity.Shell.CreatedAt == nil {
			break
		}

		return e.complexity.Shell.CreatedAt(childComplexity), true

	case "Shell.id":
		if e.complexity.Shell.ID == nil {
			break
		}

		return e.complexity.Shell.ID(childComplexity), true

	case "Shell.lastModifiedAt":
		if e.complexity.Shell.LastModifiedAt == nil {
			break
		}

		return e.complexity.Shell.LastModifiedAt(childComplexity), true

	case "Shell.owner":
		if e.complexity.Shell.Owner == nil {
			break
		}

		return e.complexity.Shell.Owner(childComplexity), true

	case "Shell.task":
		if e.complexity.Shell.Task == nil {
			break
		}

		return e.complexity.Shell.Task(childComplexity), true

	case "ShellConnection.edges":
		if e.complexity.ShellConnection.Edges == nil {
			break
		}

		return e.complexity.ShellConnection.Edges(childComplexity), true

	case "ShellConnection.pageInfo":
		if e.complexity.ShellConnection.PageInfo == nil {
			break
		}

		return e.complexity.ShellConnection.PageInfo(childComplexity), true

	case "ShellConnection.totalCount":
		if e.complexity.ShellConnection.TotalCount == nil {
			break
		}

		return e.complexity.ShellConnection.TotalCount(childComplexity), true

	case "ShellEdge.cursor":
		if e.complexity.ShellEdge.Cursor == nil {
			break
		}

		return e.complexity.ShellEdge.Cursor(childComplexity), true

	case "ShellEdge.node":
		if e.complexity.ShellEdge.Node == nil {
			break
		}

		return e.complexity.ShellEdge.Node(childComplexity), true

	case "Tag.hosts":
		if e.complexity.Tag.Hosts == nil {
			break
		}

		args, err := ec.field_Tag_hosts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tag.Hosts(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostOrder), args["where"].(*ent.HostWhereInput)), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.kind":
		if e.complexity.Tag.Kind == nil {
			break
		}

		return e.complexity.Tag.Kind(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "TagConnection.edges":
		if e.complexity.TagConnection.Edges == nil {
			break
		}

		return e.complexity.TagConnection.Edges(childComplexity), true

	case "TagConnection.pageInfo":
		if e.complexity.TagConnection.PageInfo == nil {
			break
		}

		return e.complexity.TagConnection.PageInfo(childComplexity), true

	case "TagConnection.totalCount":
		if e.complexity.TagConnection.TotalCount == nil {
			break
		}

		return e.complexity.TagConnection.TotalCount(childComplexity), true

	case "TagEdge.cursor":
		if e.complexity.TagEdge.Cursor == nil {
			break
		}

		return e.complexity.TagEdge.Cursor(childComplexity), true

	case "TagEdge.node":
		if e.complexity.TagEdge.Node == nil {
			break
		}

		return e.complexity.TagEdge.Node(childComplexity), true

	case "Task.beacon":
		if e.complexity.Task.Beacon == nil {
			break
		}

		return e.complexity.Task.Beacon(childComplexity), true

	case "Task.claimedAt":
		if e.complexity.Task.ClaimedAt == nil {
			break
		}

		return e.complexity.Task.ClaimedAt(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.error":
		if e.complexity.Task.Error == nil {
			break
		}

		return e.complexity.Task.Error(childComplexity), true

	case "Task.execFinishedAt":
		if e.complexity.Task.ExecFinishedAt == nil {
			break
		}

		return e.complexity.Task.ExecFinishedAt(childComplexity), true

	case "Task.execStartedAt":
		if e.complexity.Task.ExecStartedAt == nil {
			break
		}

		return e.complexity.Task.ExecStartedAt(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.lastModifiedAt":
		if e.complexity.Task.LastModifiedAt == nil {
			break
		}

		return e.complexity.Task.LastModifiedAt(childComplexity), true

	case "Task.output":
		if e.complexity.Task.Output == nil {
			break
		}

		return e.complexity.Task.Output(childComplexity), true

	case "Task.outputSize":
		if e.complexity.Task.OutputSize == nil {
			break
		}

		return e.complexity.Task.OutputSize(childComplexity), true

	case "Task.quest":
		if e.complexity.Task.Quest == nil {
			break
		}

		return e.complexity.Task.Quest(childComplexity), true

	case "Task.reportedCredentials":
		if e.complexity.Task.ReportedCredentials == nil {
			break
		}

		args, err := ec.field_Task_reportedCredentials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.ReportedCredentials(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostCredentialOrder), args["where"].(*ent.HostCredentialWhereInput)), true

	case "Task.reportedFiles":
		if e.complexity.Task.ReportedFiles == nil {
			break
		}

		args, err := ec.field_Task_reportedFiles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.ReportedFiles(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostFileOrder), args["where"].(*ent.HostFileWhereInput)), true

	case "Task.reportedProcesses":
		if e.complexity.Task.ReportedProcesses == nil {
			break
		}

		args, err := ec.field_Task_reportedProcesses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.ReportedProcesses(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostProcessOrder), args["where"].(*ent.HostProcessWhereInput)), true

	case "Task.shells":
		if e.complexity.Task.Shells == nil {
			break
		}

		args, err := ec.field_Task_shells_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.Shells(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellOrder), args["where"].(*ent.ShellWhereInput)), true

	case "TaskConnection.edges":
		if e.complexity.TaskConnection.Edges == nil {
			break
		}

		return e.complexity.TaskConnection.Edges(childComplexity), true

	case "TaskConnection.pageInfo":
		if e.complexity.TaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.TaskConnection.PageInfo(childComplexity), true

	case "TaskConnection.totalCount":
		if e.complexity.TaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.TaskConnection.TotalCount(childComplexity), true

	case "TaskEdge.cursor":
		if e.complexity.TaskEdge.Cursor == nil {
			break
		}

		return e.complexity.TaskEdge.Cursor(childComplexity), true

	case "TaskEdge.node":
		if e.complexity.TaskEdge.Node == nil {
			break
		}

		return e.complexity.TaskEdge.Node(childComplexity), true

	case "Tome.author":
		if e.complexity.Tome.Author == nil {
			break
		}

		return e.complexity.Tome.Author(childComplexity), true

	case "Tome.createdAt":
		if e.complexity.Tome.CreatedAt == nil {
			break
		}

		return e.complexity.Tome.CreatedAt(childComplexity), true

	case "Tome.description":
		if e.complexity.Tome.Description == nil {
			break
		}

		return e.complexity.Tome.Description(childComplexity), true

	case "Tome.eldritch":
		if e.complexity.Tome.Eldritch == nil {
			break
		}

		return e.complexity.Tome.Eldritch(childComplexity), true

	case "Tome.files":
		if e.complexity.Tome.Files == nil {
			break
		}

		args, err := ec.field_Tome_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tome.Files(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.FileOrder), args["where"].(*ent.FileWhereInput)), true

	case "Tome.id":
		if e.complexity.Tome.ID == nil {
			break
		}

		return e.complexity.Tome.ID(childComplexity), true

	case "Tome.lastModifiedAt":
		if e.complexity.Tome.LastModifiedAt == nil {
			break
		}

		return e.complexity.Tome.LastModifiedAt(childComplexity), true

	case "Tome.name":
		if e.complexity.Tome.Name == nil {
			break
		}

		return e.complexity.Tome.Name(childComplexity), true

	case "Tome.paramDefs":
		if e.complexity.Tome.ParamDefs == nil {
			break
		}

		return e.complexity.Tome.ParamDefs(childComplexity), true

	case "Tome.repository":
		if e.complexity.Tome.Repository == nil {
			break
		}

		return e.complexity.Tome.Repository(childComplexity), true

	case "Tome.supportModel":
		if e.complexity.Tome.SupportModel == nil {
			break
		}

		return e.complexity.Tome.SupportModel(childComplexity), true

	case "Tome.tactic":
		if e.complexity.Tome.Tactic == nil {
			break
		}

		return e.complexity.Tome.Tactic(childComplexity), true

	case "Tome.uploader":
		if e.complexity.Tome.Uploader == nil {
			break
		}

		return e.complexity.Tome.Uploader(childComplexity), true

	case "TomeConnection.edges":
		if e.complexity.TomeConnection.Edges == nil {
			break
		}

		return e.complexity.TomeConnection.Edges(childComplexity), true

	case "TomeConnection.pageInfo":
		if e.complexity.TomeConnection.PageInfo == nil {
			break
		}

		return e.complexity.TomeConnection.PageInfo(childComplexity), true

	case "TomeConnection.totalCount":
		if e.complexity.TomeConnection.TotalCount == nil {
			break
		}

		return e.complexity.TomeConnection.TotalCount(childComplexity), true

	case "TomeEdge.cursor":
		if e.complexity.TomeEdge.Cursor == nil {
			break
		}

		return e.complexity.TomeEdge.Cursor(childComplexity), true

	case "TomeEdge.node":
		if e.complexity.TomeEdge.Node == nil {
			break
		}

		return e.complexity.TomeEdge.Node(childComplexity), true

	case "User.activeShells":
		if e.complexity.User.ActiveShells == nil {
			break
		}

		args, err := ec.field_User_activeShells_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.ActiveShells(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellOrder), args["where"].(*ent.ShellWhereInput)), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isActivated":
		if e.complexity.User.IsActivated == nil {
			break
		}

		return e.complexity.User.IsActivated(childComplexity), true

	case "User.isAdmin":
		if e.complexity.User.IsAdmin == nil {
			break
		}

		return e.complexity.User.IsAdmin(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.photoURL":
		if e.complexity.User.PhotoURL == nil {
			break
		}

		return e.complexity.User.PhotoURL(childComplexity), true

	case "User.tomes":
		if e.complexity.User.Tomes == nil {
			break
		}

		args, err := ec.field_User_tomes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Tomes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TomeOrder), args["where"].(*ent.TomeWhereInput)), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBeaconOrder,
		ec.unmarshalInputBeaconWhereInput,
		ec.unmarshalInputClaimTasksInput,
		ec.unmarshalInputCreateHostCredentialInput,
		ec.unmarshalInputCreateQuestInput,
		ec.unmarshalInputCreateRepositoryInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputCreateTomeInput,
		ec.unmarshalInputFileOrder,
		ec.unmarshalInputFileWhereInput,
		ec.unmarshalInputHostCredentialOrder,
		ec.unmarshalInputHostCredentialWhereInput,
		ec.unmarshalInputHostFileOrder,
		ec.unmarshalInputHostFileWhereInput,
		ec.unmarshalInputHostOrder,
		ec.unmarshalInputHostProcessOrder,
		ec.unmarshalInputHostProcessWhereInput,
		ec.unmarshalInputHostWhereInput,
		ec.unmarshalInputImportRepositoryInput,
		ec.unmarshalInputQuestOrder,
		ec.unmarshalInputQuestWhereInput,
		ec.unmarshalInputRepositoryOrder,
		ec.unmarshalInputRepositoryWhereInput,
		ec.unmarshalInputShellOrder,
		ec.unmarshalInputShellWhereInput,
		ec.unmarshalInputSubmitTaskResultInput,
		ec.unmarshalInputTagOrder,
		ec.unmarshalInputTagWhereInput,
		ec.unmarshalInputTaskOrder,
		ec.unmarshalInputTaskWhereInput,
		ec.unmarshalInputTomeOrder,
		ec.unmarshalInputTomeWhereInput,
		ec.unmarshalInputUpdateBeaconInput,
		ec.unmarshalInputUpdateHostInput,
		ec.unmarshalInputUpdateTagInput,
		ec.unmarshalInputUpdateTomeInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/directives.graphql", Input: `directive @requireRole(role: Role!) on FIELD_DEFINITION

enum Role {
    ADMIN
    USER
}`, BuiltIn: false},
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Beacon implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  A human readable identifier for the beacon.
  """
  name: String!
  """
  The identity the beacon is authenticated as (e.g. 'root')
  """
  principal: String
  """
  Unique identifier for the beacon. Unique to each instance of the beacon.
  """
  identifier: String!
  """
  Identifies the agent that the beacon is running as (e.g. 'imix').
  """
  agentIdentifier: String
  """
  Timestamp of when a task was last claimed or updated for the beacon.
  """
  lastSeenAt: Time
  """
  Timestamp of when a beacon is expected to check for tasks next.
  """
  nextSeenAt: Time
  """
  Duration until next callback, in seconds.
  """
  interval: Uint64
  """
  The transport the beacon is using.
  """
  transport: BeaconTransport!
  """
  Host this beacon is running on.
  """
  host: Host!
  tasks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tasks returned from the connection.
    """
    orderBy: [TaskOrder!]

    """
    Filtering options for Tasks returned from the connection.
    """
    where: TaskWhereInput
  ): TaskConnection!
  shells(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Shells returned from the connection.
    """
    orderBy: [ShellOrder!]

    """
    Filtering options for Shells returned from the connection.
    """
    where: ShellWhereInput
  ): ShellConnection!
}
"""
A connection to a list of items.
"""
type BeaconConnection {
  """
  A list of edges.
  """
  edges: [BeaconEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type BeaconEdge {
  """
  The item at the end of the edge.
  """
  node: Beacon
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Beacon connections
"""
input BeaconOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Beacons.
  """
  field: BeaconOrderField!
}
"""
Properties by which Beacon connections can be ordered.
"""
enum BeaconOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_SEEN_AT
  NEXT_SEEN_AT
  INTERVAL
}
"""
BeaconTransport is enum for the field transport
"""
enum BeaconTransport @goModel(model: "realm.pub/tavern/internal/ent/beacon.Transport") {
  UNSPECIFIED
  GRPC
  HTTP1
}
"""
BeaconWhereInput is used for filtering Beacon objects.
Input was generated by ent.
"""
input BeaconWhereInput {
  not: BeaconWhereInput
  and: [BeaconWhereInput!]
  or: [BeaconWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  principal field predicates
  """
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalIsNil: Boolean
  principalNotNil: Boolean
  principalEqualFold: String
  principalContainsFold: String
  """
  identifier field predicates
  """
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """
  agent_identifier field predicates
  """
  agentIdentifier: String
  agentIdentifierNEQ: String
  agentIdentifierIn: [String!]
  agentIdentifierNotIn: [String!]
  agentIdentifierGT: String
  agentIdentifierGTE: String
  agentIdentifierLT: String
  agentIdentifierLTE: String
  agentIdentifierContains: String
  agentIdentifierHasPrefix: String
  agentIdentifierHasSuffix: String
  agentIdentifierIsNil: Boolean
  agentIdentifierNotNil: Boolean
  agentIdentifierEqualFold: String
  agentIdentifierContainsFold: String
  """
  last_seen_at field predicates
  """
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """
  next_seen_at field predicates
  """
  nextSeenAt: Time
  nextSeenAtNEQ: Time
  nextSeenAtIn: [Time!]
  nextSeenAtNotIn: [Time!]
  nextSeenAtGT: Time
  nextSeenAtGTE: Time
  nextSeenAtLT: Time
  nextSeenAtLTE: Time
  nextSeenAtIsNil: Boolean
  nextSeenAtNotNil: Boolean
  """
  interval field predicates
  """
  interval: Uint64
  intervalNEQ: Uint64
  intervalIn: [Uint64!]
  intervalNotIn: [Uint64!]
  intervalGT: Uint64
  intervalGTE: Uint64
  intervalLT: Uint64
  intervalLTE: Uint64
  intervalIsNil: Boolean
  intervalNotNil: Boolean
  """
  transport field predicates
  """
  transport: BeaconTransport
  transportNEQ: BeaconTransport
  transportIn: [BeaconTransport!]
  transportNotIn: [BeaconTransport!]
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  tasks edge predicates
  """
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
  """
  shells edge predicates
  """
  hasShells: Boolean
  hasShellsWith: [ShellWhereInput!]
}
"""
CreateHostCredentialInput is used for create HostCredential object.
Input was generated by ent.
"""
input CreateHostCredentialInput {
  """
  Identity associated with this credential (e.g. username).
  """
  principal: String!
  """
  Secret for this credential (e.g. password).
  """
  secret: String!
  """
  Kind of credential.
  """
  kind: HostCredentialKind!
  hostID: ID!
  taskID: ID
}
"""
CreateQuestInput is used for create Quest object.
Input was generated by ent.
"""
input CreateQuestInput {
  """
  Name of the quest
  """
  name: String!
  """
  Value of parameters that were specified for the quest (as a JSON string).
  """
  parameters: String
  tomeID: ID!
}
"""
CreateRepositoryInput is used for create Repository object.
Input was generated by ent.
"""
input CreateRepositoryInput {
  """
  URL of the repository
  """
  url: String!
}
"""
CreateTagInput is used for create Tag object.
Input was generated by ent.
"""
input CreateTagInput {
  """
  Name of the tag
  """
  name: String!
  """
  Describes the type of tag this is
  """
  kind: TagKind!
  hostIDs: [ID!]
}
"""
CreateTomeInput is used for create Tome object.
Input was generated by ent.
"""
input CreateTomeInput {
  """
  Name of the tome
  """
  name: String!
  """
  Information about the tome
  """
  description: String!
  """
  Name of the author who created the tome.
  """
  author: String!
  """
  Information about the tomes support model.
  """
  supportModel: TomeSupportModel
  """
  MITRE ATT&CK tactic provided by the tome.
  """
  tactic: TomeTactic
  """
  JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter.
  """
  paramDefs: String
  """
  Eldritch script that will be executed when the tome is run
  """
  eldritch: String!
  fileIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type File implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  The name of the file, used to reference it for downloads
  """
  name: String!
  """
  The size of the file in bytes
  """
  size: Int!
  """
  A SHA3-256 digest of the content field
  """
  hash: String!
  tomes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tomes returned from the connection.
    """
    orderBy: [TomeOrder!]

    """
    Filtering options for Tomes returned from the connection.
    """
    where: TomeWhereInput
  ): TomeConnection!
}
"""
A connection to a list of items.
"""
type FileConnection {
  """
  A list of edges.
  """
  edges: [FileEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type FileEdge {
  """
  The item at the end of the edge.
  """
  node: File
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for File connections
"""
input FileOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Files.
  """
  field: FileOrderField!
}
"""
Properties by which File connections can be ordered.
"""
enum FileOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
FileWhereInput is used for filtering File objects.
Input was generated by ent.
"""
input FileWhereInput {
  not: FileWhereInput
  and: [FileWhereInput!]
  or: [FileWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  size field predicates
  """
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """
  hash field predicates
  """
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashEqualFold: String
  hashContainsFold: String
  """
  tomes edge predicates
  """
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
}
type Host implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Unique identifier for the host. Unique to each host.
  """
  identifier: String!
  """
  A human readable identifier for the host.
  """
  name: String
  """
  Primary interface IP address reported by the agent.
  """
  primaryIP: String
  """
  Incoming IP from Proxy. Will return first proxy IP if multiple.
  """
  externalIP: String
  """
  Platform the agent is operating on.
  """
  platform: HostPlatform!
  """
  Timestamp of when a task was last claimed or updated for the host.
  """
  lastSeenAt: Time
  """
  Timestamp of when a task is next expected to be claimed or updated for the host.
  """
  nextSeenAt: Time
  tags(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tags returned from the connection.
    """
    orderBy: [TagOrder!]

    """
    Filtering options for Tags returned from the connection.
    """
    where: TagWhereInput
  ): TagConnection!
  beacons(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Beacons returned from the connection.
    """
    orderBy: [BeaconOrder!]

    """
    Filtering options for Beacons returned from the connection.
    """
    where: BeaconWhereInput
  ): BeaconConnection!
  files(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostFiles returned from the connection.
    """
    orderBy: [HostFileOrder!]

    """
    Filtering options for HostFiles returned from the connection.
    """
    where: HostFileWhereInput
  ): HostFileConnection!
  processes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostProcesses returned from the connection.
    """
    orderBy: [HostProcessOrder!]

    """
    Filtering options for HostProcesses returned from the connection.
    """
    where: HostProcessWhereInput
  ): HostProcessConnection!
  credentials(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostCredentials returned from the connection.
    """
    orderBy: [HostCredentialOrder!]

    """
    Filtering options for HostCredentials returned from the connection.
    """
    where: HostCredentialWhereInput
  ): HostCredentialConnection!
}
"""
A connection to a list of items.
"""
type HostConnection {
  """
  A list of edges.
  """
  edges: [HostEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
type HostCredential implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Identity associated with this credential (e.g. username).
  """
  principal: String!
  """
  Secret for this credential (e.g. password).
  """
  secret: String!
  """
  Kind of credential.
  """
  kind: HostCredentialKind!
  """
  Host the credential was reported on.
  """
  host: Host!
  """
  Task that reported this credential.
  """
  task: Task
}
"""
A connection to a list of items.
"""
type HostCredentialConnection {
  """
  A list of edges.
  """
  edges: [HostCredentialEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type HostCredentialEdge {
  """
  The item at the end of the edge.
  """
  node: HostCredential
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
HostCredentialKind is enum for the field kind
"""
enum HostCredentialKind @goModel(model: "realm.pub/tavern/internal/c2/epb.Credential_Kind") {
  KIND_PASSWORD
  KIND_SSH_KEY
  KIND_UNSPECIFIED
}
"""
Ordering options for HostCredential connections
"""
input HostCredentialOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order HostCredentials.
  """
  field: HostCredentialOrderField!
}
"""
Properties by which HostCredential connections can be ordered.
"""
enum HostCredentialOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  PRINCIPAL
}
"""
HostCredentialWhereInput is used for filtering HostCredential objects.
Input was generated by ent.
"""
input HostCredentialWhereInput {
  not: HostCredentialWhereInput
  and: [HostCredentialWhereInput!]
  or: [HostCredentialWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  principal field predicates
  """
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalEqualFold: String
  principalContainsFold: String
  """
  secret field predicates
  """
  secret: String
  secretNEQ: String
  secretIn: [String!]
  secretNotIn: [String!]
  secretGT: String
  secretGTE: String
  secretLT: String
  secretLTE: String
  secretContains: String
  secretHasPrefix: String
  secretHasSuffix: String
  secretEqualFold: String
  secretContainsFold: String
  """
  kind field predicates
  """
  kind: HostCredentialKind
  kindNEQ: HostCredentialKind
  kindIn: [HostCredentialKind!]
  kindNotIn: [HostCredentialKind!]
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
}
"""
An edge in a connection.
"""
type HostEdge {
  """
  The item at the end of the edge.
  """
  node: Host
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
type HostFile implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Path to the file on the host system.
  """
  path: String!
  """
  User who owns the file on the host system.
  """
  owner: String
  """
  Group who owns the file on the host system.
  """
  group: String
  """
  Permissions for the file on the host system.
  """
  permissions: String
  """
  The size of the file in bytes
  """
  size: Uint64!
  """
  A SHA3-256 digest of the content field
  """
  hash: String
  """
  Host the file was reported on.
  """
  host: Host!
  """
  Task that reported this file.
  """
  task: Task!
}
"""
A connection to a list of items.
"""
type HostFileConnection {
  """
  A list of edges.
  """
  edges: [HostFileEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type HostFileEdge {
  """
  The item at the end of the edge.
  """
  node: HostFile
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for HostFile connections
"""
input HostFileOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order HostFiles.
  """
  field: HostFileOrderField!
}
"""
Properties by which HostFile connections can be ordered.
"""
enum HostFileOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
HostFileWhereInput is used for filtering HostFile objects.
Input was generated by ent.
"""
input HostFileWhereInput {
  not: HostFileWhereInput
  and: [HostFileWhereInput!]
  or: [HostFileWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  path field predicates
  """
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathEqualFold: String
  pathContainsFold: String
  """
  owner field predicates
  """
  owner: String
  ownerNEQ: String
  ownerIn: [String!]
  ownerNotIn: [String!]
  ownerGT: String
  ownerGTE: String
  ownerLT: String
  ownerLTE: String
  ownerContains: String
  ownerHasPrefix: String
  ownerHasSuffix: String
  ownerIsNil: Boolean
  ownerNotNil: Boolean
  ownerEqualFold: String
  ownerContainsFold: String
  """
  group field predicates
  """
  group: String
  groupNEQ: String
  groupIn: [String!]
  groupNotIn: [String!]
  groupGT: String
  groupGTE: String
  groupLT: String
  groupLTE: String
  groupContains: String
  groupHasPrefix: String
  groupHasSuffix: String
  groupIsNil: Boolean
  groupNotNil: Boolean
  groupEqualFold: String
  groupContainsFold: String
  """
  permissions field predicates
  """
  permissions: String
  permissionsNEQ: String
  permissionsIn: [String!]
  permissionsNotIn: [String!]
  permissionsGT: String
  permissionsGTE: String
  permissionsLT: String
  permissionsLTE: String
  permissionsContains: String
  permissionsHasPrefix: String
  permissionsHasSuffix: String
  permissionsIsNil: Boolean
  permissionsNotNil: Boolean
  permissionsEqualFold: String
  permissionsContainsFold: String
  """
  size field predicates
  """
  size: Uint64
  sizeNEQ: Uint64
  sizeIn: [Uint64!]
  sizeNotIn: [Uint64!]
  sizeGT: Uint64
  sizeGTE: Uint64
  sizeLT: Uint64
  sizeLTE: Uint64
  """
  hash field predicates
  """
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashIsNil: Boolean
  hashNotNil: Boolean
  hashEqualFold: String
  hashContainsFold: String
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
}
"""
Ordering options for Host connections
"""
input HostOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Hosts.
  """
  field: HostOrderField!
}
"""
Properties by which Host connections can be ordered.
"""
enum HostOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_SEEN_AT
  NEXT_SEEN_AT
}
"""
HostPlatform is enum for the field platform
"""
enum HostPlatform @goModel(model: "realm.pub/tavern/internal/c2/c2pb.Host_Platform") {
  PLATFORM_BSD
  PLATFORM_LINUX
  PLATFORM_MACOS
  PLATFORM_UNSPECIFIED
  PLATFORM_WINDOWS
}
type HostProcess implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  ID of the process.
  """
  pid: Uint64!
  """
  ID of the parent process.
  """
  ppid: Uint64!
  """
  The name of the process.
  """
  name: String!
  """
  The user the process is running as.
  """
  principal: String!
  """
  The path to the process executable.
  """
  path: String
  """
  The command used to execute the process.
  """
  cmd: String
  """
  The environment variables set for the process.
  """
  env: String
  """
  The current working directory for the process.
  """
  cwd: String
  """
  Current process status.
  """
  status: HostProcessStatus!
  """
  Host the process was reported on.
  """
  host: Host!
  """
  Task that reported this process.
  """
  task: Task!
}
"""
A connection to a list of items.
"""
type HostProcessConnection {
  """
  A list of edges.
  """
  edges: [HostProcessEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type HostProcessEdge {
  """
  The item at the end of the edge.
  """
  node: HostProcess
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for HostProcess connections
"""
input HostProcessOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order HostProcesses.
  """
  field: HostProcessOrderField!
}
"""
Properties by which HostProcess connections can be ordered.
"""
enum HostProcessOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  PROCESS_ID
  PARENT_PROCESS_ID
  NAME
}
"""
HostProcessStatus is enum for the field status
"""
enum HostProcessStatus @goModel(model: "realm.pub/tavern/internal/c2/epb.Process_Status") {
  STATUS_DEAD
  STATUS_IDLE
  STATUS_LOCK_BLOCKED
  STATUS_PARKED
  STATUS_RUN
  STATUS_SLEEP
  STATUS_STOP
  STATUS_TRACING
  STATUS_UNINTERUPTIBLE_DISK_SLEEP
  STATUS_UNKNOWN
  STATUS_UNSPECIFIED
  STATUS_WAKE_KILL
  STATUS_WAKING
  STATUS_ZOMBIE
}
"""
HostProcessWhereInput is used for filtering HostProcess objects.
Input was generated by ent.
"""
input HostProcessWhereInput {
  not: HostProcessWhereInput
  and: [HostProcessWhereInput!]
  or: [HostProcessWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  pid field predicates
  """
  pid: Uint64
  pidNEQ: Uint64
  pidIn: [Uint64!]
  pidNotIn: [Uint64!]
  pidGT: Uint64
  pidGTE: Uint64
  pidLT: Uint64
  pidLTE: Uint64
  """
  ppid field predicates
  """
  ppid: Uint64
  ppidNEQ: Uint64
  ppidIn: [Uint64!]
  ppidNotIn: [Uint64!]
  ppidGT: Uint64
  ppidGTE: Uint64
  ppidLT: Uint64
  ppidLTE: Uint64
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  principal field predicates
  """
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalEqualFold: String
  principalContainsFold: String
  """
  path field predicates
  """
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathIsNil: Boolean
  pathNotNil: Boolean
  pathEqualFold: String
  pathContainsFold: String
  """
  cmd field predicates
  """
  cmd: String
  cmdNEQ: String
  cmdIn: [String!]
  cmdNotIn: [String!]
  cmdGT: String
  cmdGTE: String
  cmdLT: String
  cmdLTE: String
  cmdContains: String
  cmdHasPrefix: String
  cmdHasSuffix: String
  cmdIsNil: Boolean
  cmdNotNil: Boolean
  cmdEqualFold: String
  cmdContainsFold: String
  """
  env field predicates
  """
  env: String
  envNEQ: String
  envIn: [String!]
  envNotIn: [String!]
  envGT: String
  envGTE: String
  envLT: String
  envLTE: String
  envContains: String
  envHasPrefix: String
  envHasSuffix: String
  envIsNil: Boolean
  envNotNil: Boolean
  envEqualFold: String
  envContainsFold: String
  """
  cwd field predicates
  """
  cwd: String
  cwdNEQ: String
  cwdIn: [String!]
  cwdNotIn: [String!]
  cwdGT: String
  cwdGTE: String
  cwdLT: String
  cwdLTE: String
  cwdContains: String
  cwdHasPrefix: String
  cwdHasSuffix: String
  cwdIsNil: Boolean
  cwdNotNil: Boolean
  cwdEqualFold: String
  cwdContainsFold: String
  """
  status field predicates
  """
  status: HostProcessStatus
  statusNEQ: HostProcessStatus
  statusIn: [HostProcessStatus!]
  statusNotIn: [HostProcessStatus!]
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
}
"""
HostWhereInput is used for filtering Host objects.
Input was generated by ent.
"""
input HostWhereInput {
  not: HostWhereInput
  and: [HostWhereInput!]
  or: [HostWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  identifier field predicates
  """
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """
  primary_ip field predicates
  """
  primaryIP: String
  primaryIPNEQ: String
  primaryIPIn: [String!]
  primaryIPNotIn: [String!]
  primaryIPGT: String
  primaryIPGTE: String
  primaryIPLT: String
  primaryIPLTE: String
  primaryIPContains: String
  primaryIPHasPrefix: String
  primaryIPHasSuffix: String
  primaryIPIsNil: Boolean
  primaryIPNotNil: Boolean
  primaryIPEqualFold: String
  primaryIPContainsFold: String
  """
  external_ip field predicates
  """
  externalIP: String
  externalIPNEQ: String
  externalIPIn: [String!]
  externalIPNotIn: [String!]
  externalIPGT: String
  externalIPGTE: String
  externalIPLT: String
  externalIPLTE: String
  externalIPContains: String
  externalIPHasPrefix: String
  externalIPHasSuffix: String
  externalIPIsNil: Boolean
  externalIPNotNil: Boolean
  externalIPEqualFold: String
  externalIPContainsFold: String
  """
  platform field predicates
  """
  platform: HostPlatform
  platformNEQ: HostPlatform
  platformIn: [HostPlatform!]
  platformNotIn: [HostPlatform!]
  """
  last_seen_at field predicates
  """
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """
  next_seen_at field predicates
  """
  nextSeenAt: Time
  nextSeenAtNEQ: Time
  nextSeenAtIn: [Time!]
  nextSeenAtNotIn: [Time!]
  nextSeenAtGT: Time
  nextSeenAtGTE: Time
  nextSeenAtLT: Time
  nextSeenAtLTE: Time
  nextSeenAtIsNil: Boolean
  nextSeenAtNotNil: Boolean
  """
  tags edge predicates
  """
  hasTags: Boolean
  hasTagsWith: [TagWhereInput!]
  """
  beacons edge predicates
  """
  hasBeacons: Boolean
  hasBeaconsWith: [BeaconWhereInput!]
  """
  files edge predicates
  """
  hasFiles: Boolean
  hasFilesWith: [HostFileWhereInput!]
  """
  processes edge predicates
  """
  hasProcesses: Boolean
  hasProcessesWith: [HostProcessWhereInput!]
  """
  credentials edge predicates
  """
  hasCredentials: Boolean
  hasCredentialsWith: [HostCredentialWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "realm.pub/tavern/internal/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
}
type Quest implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Name of the quest
  """
  name: String!
  """
  Value of parameters that were specified for the quest (as a JSON string).
  """
  parameters: String
  """
  JSON string describing what parameters are used with the tome at the time of this quest creation. Requires a list of JSON objects, one for each parameter.
  """
  paramDefsAtCreation: String
  """
  Eldritch script that was evaluated at the time of this quest creation.
  """
  eldritchAtCreation: String
  """
  Tome that this quest will be executing
  """
  tome: Tome!
  """
  Bundle file that the executing tome depends on (if any)
  """
  bundle: File
  tasks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tasks returned from the connection.
    """
    orderBy: [TaskOrder!]

    """
    Filtering options for Tasks returned from the connection.
    """
    where: TaskWhereInput
  ): TaskConnection!
  """
  User that created the quest if available.
  """
  creator: User
}
"""
A connection to a list of items.
"""
type QuestConnection {
  """
  A list of edges.
  """
  edges: [QuestEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type QuestEdge {
  """
  The item at the end of the edge.
  """
  node: Quest
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Quest connections
"""
input QuestOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Quests.
  """
  field: QuestOrderField!
}
"""
Properties by which Quest connections can be ordered.
"""
enum QuestOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
QuestWhereInput is used for filtering Quest objects.
Input was generated by ent.
"""
input QuestWhereInput {
  not: QuestWhereInput
  and: [QuestWhereInput!]
  or: [QuestWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  parameters field predicates
  """
  parameters: String
  parametersNEQ: String
  parametersIn: [String!]
  parametersNotIn: [String!]
  parametersGT: String
  parametersGTE: String
  parametersLT: String
  parametersLTE: String
  parametersContains: String
  parametersHasPrefix: String
  parametersHasSuffix: String
  parametersIsNil: Boolean
  parametersNotNil: Boolean
  parametersEqualFold: String
  parametersContainsFold: String
  """
  param_defs_at_creation field predicates
  """
  paramDefsAtCreation: String
  paramDefsAtCreationNEQ: String
  paramDefsAtCreationIn: [String!]
  paramDefsAtCreationNotIn: [String!]
  paramDefsAtCreationGT: String
  paramDefsAtCreationGTE: String
  paramDefsAtCreationLT: String
  paramDefsAtCreationLTE: String
  paramDefsAtCreationContains: String
  paramDefsAtCreationHasPrefix: String
  paramDefsAtCreationHasSuffix: String
  paramDefsAtCreationIsNil: Boolean
  paramDefsAtCreationNotNil: Boolean
  paramDefsAtCreationEqualFold: String
  paramDefsAtCreationContainsFold: String
  """
  eldritch_at_creation field predicates
  """
  eldritchAtCreation: String
  eldritchAtCreationNEQ: String
  eldritchAtCreationIn: [String!]
  eldritchAtCreationNotIn: [String!]
  eldritchAtCreationGT: String
  eldritchAtCreationGTE: String
  eldritchAtCreationLT: String
  eldritchAtCreationLTE: String
  eldritchAtCreationContains: String
  eldritchAtCreationHasPrefix: String
  eldritchAtCreationHasSuffix: String
  eldritchAtCreationIsNil: Boolean
  eldritchAtCreationNotNil: Boolean
  eldritchAtCreationEqualFold: String
  eldritchAtCreationContainsFold: String
  """
  tome edge predicates
  """
  hasTome: Boolean
  hasTomeWith: [TomeWhereInput!]
  """
  bundle edge predicates
  """
  hasBundle: Boolean
  hasBundleWith: [FileWhereInput!]
  """
  tasks edge predicates
  """
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
  """
  creator edge predicates
  """
  hasCreator: Boolean
  hasCreatorWith: [UserWhereInput!]
}
type Repository implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  URL of the repository
  """
  url: String!
  """
  Public key associated with this repositories private key
  """
  publicKey: String!
  """
  Timestamp of when this repo was last imported
  """
  lastImportedAt: Time
  tomes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tomes returned from the connection.
    """
    orderBy: [TomeOrder!]

    """
    Filtering options for Tomes returned from the connection.
    """
    where: TomeWhereInput
  ): TomeConnection!
  """
  User that created this repository.
  """
  owner: User
}
"""
A connection to a list of items.
"""
type RepositoryConnection {
  """
  A list of edges.
  """
  edges: [RepositoryEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type RepositoryEdge {
  """
  The item at the end of the edge.
  """
  node: Repository
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Repository connections
"""
input RepositoryOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Repositories.
  """
  field: RepositoryOrderField!
}
"""
Properties by which Repository connections can be ordered.
"""
enum RepositoryOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_IMPORTED_AT
}
"""
RepositoryWhereInput is used for filtering Repository objects.
Input was generated by ent.
"""
input RepositoryWhereInput {
  not: RepositoryWhereInput
  and: [RepositoryWhereInput!]
  or: [RepositoryWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  url field predicates
  """
  url: String
  urlNEQ: String
  urlIn: [String!]
  urlNotIn: [String!]
  urlGT: String
  urlGTE: String
  urlLT: String
  urlLTE: String
  urlContains: String
  urlHasPrefix: String
  urlHasSuffix: String
  urlEqualFold: String
  urlContainsFold: String
  """
  public_key field predicates
  """
  publicKey: String
  publicKeyNEQ: String
  publicKeyIn: [String!]
  publicKeyNotIn: [String!]
  publicKeyGT: String
  publicKeyGTE: String
  publicKeyLT: String
  publicKeyLTE: String
  publicKeyContains: String
  publicKeyHasPrefix: String
  publicKeyHasSuffix: String
  publicKeyEqualFold: String
  publicKeyContainsFold: String
  """
  last_imported_at field predicates
  """
  lastImportedAt: Time
  lastImportedAtNEQ: Time
  lastImportedAtIn: [Time!]
  lastImportedAtNotIn: [Time!]
  lastImportedAtGT: Time
  lastImportedAtGTE: Time
  lastImportedAtLT: Time
  lastImportedAtLTE: Time
  lastImportedAtIsNil: Boolean
  lastImportedAtNotNil: Boolean
  """
  tomes edge predicates
  """
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
  """
  owner edge predicates
  """
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
}
type Shell implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Timestamp of when this shell was closed
  """
  closedAt: Time
  """
  Task that created the shell
  """
  task: Task!
  """
  Beacon that created the shell
  """
  beacon: Beacon!
  """
  User that created the shell
  """
  owner: User!
  activeUsers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
}
"""
A connection to a list of items.
"""
type ShellConnection {
  """
  A list of edges.
  """
  edges: [ShellEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ShellEdge {
  """
  The item at the end of the edge.
  """
  node: Shell
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Shell connections
"""
input ShellOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Shells.
  """
  field: ShellOrderField!
}
"""
Properties by which Shell connections can be ordered.
"""
enum ShellOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLOSED_AT
}
"""
ShellWhereInput is used for filtering Shell objects.
Input was generated by ent.
"""
input ShellWhereInput {
  not: ShellWhereInput
  and: [ShellWhereInput!]
  or: [ShellWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  closed_at field predicates
  """
  closedAt: Time
  closedAtNEQ: Time
  closedAtIn: [Time!]
  closedAtNotIn: [Time!]
  closedAtGT: Time
  closedAtGTE: Time
  closedAtLT: Time
  closedAtLTE: Time
  closedAtIsNil: Boolean
  closedAtNotNil: Boolean
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
  """
  beacon edge predicates
  """
  hasBeacon: Boolean
  hasBeaconWith: [BeaconWhereInput!]
  """
  owner edge predicates
  """
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
  """
  active_users edge predicates
  """
  hasActiveUsers: Boolean
  hasActiveUsersWith: [UserWhereInput!]
}
type Tag implements Node {
  id: ID!
  """
  Name of the tag
  """
  name: String!
  """
  Describes the type of tag this is
  """
  kind: TagKind!
  hosts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Hosts returned from the connection.
    """
    orderBy: [HostOrder!]

    """
    Filtering options for Hosts returned from the connection.
    """
    where: HostWhereInput
  ): HostConnection!
}
"""
A connection to a list of items.
"""
type TagConnection {
  """
  A list of edges.
  """
  edges: [TagEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type TagEdge {
  """
  The item at the end of the edge.
  """
  node: Tag
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
TagKind is enum for the field kind
"""
enum TagKind @goModel(model: "realm.pub/tavern/internal/ent/tag.Kind") {
  group
  service
}
"""
Ordering options for Tag connections
"""
input TagOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Tags.
  """
  field: TagOrderField!
}
"""
Properties by which Tag connections can be ordered.
"""
enum TagOrderField {
  NAME
}
"""
TagWhereInput is used for filtering Tag objects.
Input was generated by ent.
"""
input TagWhereInput {
  not: TagWhereInput
  and: [TagWhereInput!]
  or: [TagWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  kind field predicates
  """
  kind: TagKind
  kindNEQ: TagKind
  kindIn: [TagKind!]
  kindNotIn: [TagKind!]
  """
  hosts edge predicates
  """
  hasHosts: Boolean
  hasHostsWith: [HostWhereInput!]
}
type Task implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Timestamp of when the task was claimed, null if not yet claimed
  """
  claimedAt: Time
  """
  Timestamp of when execution of the task started, null if not yet started
  """
  execStartedAt: Time
  """
  Timestamp of when execution of the task finished, null if not yet finished
  """
  execFinishedAt: Time
  """
  Output from executing the task
  """
  output: String
  """
  The size of the output in bytes
  """
  outputSize: Int!
  """
  Error, if any, produced while executing the Task
  """
  error: String
  quest: Quest!
  beacon: Beacon!
  reportedFiles(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostFiles returned from the connection.
    """
    orderBy: [HostFileOrder!]

    """
    Filtering options for HostFiles returned from the connection.
    """
    where: HostFileWhereInput
  ): HostFileConnection!
  reportedProcesses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostProcesses returned from the connection.
    """
    orderBy: [HostProcessOrder!]

    """
    Filtering options for HostProcesses returned from the connection.
    """
    where: HostProcessWhereInput
  ): HostProcessConnection!
  reportedCredentials(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostCredentials returned from the connection.
    """
    orderBy: [HostCredentialOrder!]

    """
    Filtering options for HostCredentials returned from the connection.
    """
    where: HostCredentialWhereInput
  ): HostCredentialConnection!
  shells(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Shells returned from the connection.
    """
    orderBy: [ShellOrder!]

    """
    Filtering options for Shells returned from the connection.
    """
    where: ShellWhereInput
  ): ShellConnection!
}
"""
A connection to a list of items.
"""
type TaskConnection {
  """
  A list of edges.
  """
  edges: [TaskEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type TaskEdge {
  """
  The item at the end of the edge.
  """
  node: Task
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Task connections
"""
input TaskOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Tasks.
  """
  field: TaskOrderField!
}
"""
Properties by which Task connections can be ordered.
"""
enum TaskOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLAIMED_AT
  EXEC_STARTED_AT
  EXEC_FINISHED_AT
  OUTPUT_SIZE
}
"""
TaskWhereInput is used for filtering Task objects.
Input was generated by ent.
"""
input TaskWhereInput {
  not: TaskWhereInput
  and: [TaskWhereInput!]
  or: [TaskWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  claimed_at field predicates
  """
  claimedAt: Time
  claimedAtNEQ: Time
  claimedAtIn: [Time!]
  claimedAtNotIn: [Time!]
  claimedAtGT: Time
  claimedAtGTE: Time
  claimedAtLT: Time
  claimedAtLTE: Time
  claimedAtIsNil: Boolean
  claimedAtNotNil: Boolean
  """
  exec_started_at field predicates
  """
  execStartedAt: Time
  execStartedAtNEQ: Time
  execStartedAtIn: [Time!]
  execStartedAtNotIn: [Time!]
  execStartedAtGT: Time
  execStartedAtGTE: Time
  execStartedAtLT: Time
  execStartedAtLTE: Time
  execStartedAtIsNil: Boolean
  execStartedAtNotNil: Boolean
  """
  exec_finished_at field predicates
  """
  execFinishedAt: Time
  execFinishedAtNEQ: Time
  execFinishedAtIn: [Time!]
  execFinishedAtNotIn: [Time!]
  execFinishedAtGT: Time
  execFinishedAtGTE: Time
  execFinishedAtLT: Time
  execFinishedAtLTE: Time
  execFinishedAtIsNil: Boolean
  execFinishedAtNotNil: Boolean
  """
  output field predicates
  """
  output: String
  outputNEQ: String
  outputIn: [String!]
  outputNotIn: [String!]
  outputGT: String
  outputGTE: String
  outputLT: String
  outputLTE: String
  outputContains: String
  outputHasPrefix: String
  outputHasSuffix: String
  outputIsNil: Boolean
  outputNotNil: Boolean
  outputEqualFold: String
  outputContainsFold: String
  """
  output_size field predicates
  """
  outputSize: Int
  outputSizeNEQ: Int
  outputSizeIn: [Int!]
  outputSizeNotIn: [Int!]
  outputSizeGT: Int
  outputSizeGTE: Int
  outputSizeLT: Int
  outputSizeLTE: Int
  """
  error field predicates
  """
  error: String
  errorNEQ: String
  errorIn: [String!]
  errorNotIn: [String!]
  errorGT: String
  errorGTE: String
  errorLT: String
  errorLTE: String
  errorContains: String
  errorHasPrefix: String
  errorHasSuffix: String
  errorIsNil: Boolean
  errorNotNil: Boolean
  errorEqualFold: String
  errorContainsFold: String
  """
  quest edge predicates
  """
  hasQuest: Boolean
  hasQuestWith: [QuestWhereInput!]
  """
  beacon edge predicates
  """
  hasBeacon: Boolean
  hasBeaconWith: [BeaconWhereInput!]
  """
  reported_files edge predicates
  """
  hasReportedFiles: Boolean
  hasReportedFilesWith: [HostFileWhereInput!]
  """
  reported_processes edge predicates
  """
  hasReportedProcesses: Boolean
  hasReportedProcessesWith: [HostProcessWhereInput!]
  """
  reported_credentials edge predicates
  """
  hasReportedCredentials: Boolean
  hasReportedCredentialsWith: [HostCredentialWhereInput!]
  """
  shells edge predicates
  """
  hasShells: Boolean
  hasShellsWith: [ShellWhereInput!]
}
type Tome implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Name of the tome
  """
  name: String!
  """
  Information about the tome
  """
  description: String!
  """
  Name of the author who created the tome.
  """
  author: String!
  """
  Information about the tomes support model.
  """
  supportModel: TomeSupportModel!
  """
  MITRE ATT&CK tactic provided by the tome.
  """
  tactic: TomeTactic!
  """
  JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter.
  """
  paramDefs: String
  """
  Eldritch script that will be executed when the tome is run
  """
  eldritch: String!
  files(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Files returned from the connection.
    """
    orderBy: [FileOrder!]

    """
    Filtering options for Files returned from the connection.
    """
    where: FileWhereInput
  ): FileConnection!
  """
  User who uploaded the tome (may be null).
  """
  uploader: User
  """
  Repository from which this Tome was imported (may be null).
  """
  repository: Repository
}
"""
A connection to a list of items.
"""
type TomeConnection {
  """
  A list of edges.
  """
  edges: [TomeEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type TomeEdge {
  """
  The item at the end of the edge.
  """
  node: Tome
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Tome connections
"""
input TomeOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Tomes.
  """
  field: TomeOrderField!
}
"""
Properties by which Tome connections can be ordered.
"""
enum TomeOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
TomeSupportModel is enum for the field support_model
"""
enum TomeSupportModel @goModel(model: "realm.pub/tavern/internal/ent/tome.SupportModel") {
  UNSPECIFIED
  FIRST_PARTY
  COMMUNITY
}
"""
TomeTactic is enum for the field tactic
"""
enum TomeTactic @goModel(model: "realm.pub/tavern/internal/ent/tome.Tactic") {
  UNSPECIFIED
  RECON
  RESOURCE_DEVELOPMENT
  INITIAL_ACCESS
  EXECUTION
  PERSISTENCE
  PRIVILEGE_ESCALATION
  DEFENSE_EVASION
  CREDENTIAL_ACCESS
  DISCOVERY
  LATERAL_MOVEMENT
  COLLECTION
  COMMAND_AND_CONTROL
  EXFILTRATION
  IMPACT
}
"""
TomeWhereInput is used for filtering Tome objects.
Input was generated by ent.
"""
input TomeWhereInput {
  not: TomeWhereInput
  and: [TomeWhereInput!]
  or: [TomeWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  description field predicates
  """
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionEqualFold: String
  descriptionContainsFold: String
  """
  author field predicates
  """
  author: String
  authorNEQ: String
  authorIn: [String!]
  authorNotIn: [String!]
  authorGT: String
  authorGTE: String
  authorLT: String
  authorLTE: String
  authorContains: String
  authorHasPrefix: String
  authorHasSuffix: String
  authorEqualFold: String
  authorContainsFold: String
  """
  support_model field predicates
  """
  supportModel: TomeSupportModel
  supportModelNEQ: TomeSupportModel
  supportModelIn: [TomeSupportModel!]
  supportModelNotIn: [TomeSupportModel!]
  """
  tactic field predicates
  """
  tactic: TomeTactic
  tacticNEQ: TomeTactic
  tacticIn: [TomeTactic!]
  tacticNotIn: [TomeTactic!]
  """
  param_defs field predicates
  """
  paramDefs: String
  paramDefsNEQ: String
  paramDefsIn: [String!]
  paramDefsNotIn: [String!]
  paramDefsGT: String
  paramDefsGTE: String
  paramDefsLT: String
  paramDefsLTE: String
  paramDefsContains: String
  paramDefsHasPrefix: String
  paramDefsHasSuffix: String
  paramDefsIsNil: Boolean
  paramDefsNotNil: Boolean
  paramDefsEqualFold: String
  paramDefsContainsFold: String
  """
  eldritch field predicates
  """
  eldritch: String
  eldritchNEQ: String
  eldritchIn: [String!]
  eldritchNotIn: [String!]
  eldritchGT: String
  eldritchGTE: String
  eldritchLT: String
  eldritchLTE: String
  eldritchContains: String
  eldritchHasPrefix: String
  eldritchHasSuffix: String
  eldritchEqualFold: String
  eldritchContainsFold: String
  """
  files edge predicates
  """
  hasFiles: Boolean
  hasFilesWith: [FileWhereInput!]
  """
  uploader edge predicates
  """
  hasUploader: Boolean
  hasUploaderWith: [UserWhereInput!]
  """
  repository edge predicates
  """
  hasRepository: Boolean
  hasRepositoryWith: [RepositoryWhereInput!]
}
"""
UpdateBeaconInput is used for update Beacon object.
Input was generated by ent.
"""
input UpdateBeaconInput {
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time
  """
  The transport the beacon is using.
  """
  transport: BeaconTransport
  hostID: ID
}
"""
UpdateHostInput is used for update Host object.
Input was generated by ent.
"""
input UpdateHostInput {
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time
  """
  A human readable identifier for the host.
  """
  name: String
  clearName: Boolean
  addTagIDs: [ID!]
  removeTagIDs: [ID!]
  clearTags: Boolean
  addBeaconIDs: [ID!]
  removeBeaconIDs: [ID!]
  clearBeacons: Boolean
  addFileIDs: [ID!]
  removeFileIDs: [ID!]
  clearFiles: Boolean
  addProcessIDs: [ID!]
  removeProcessIDs: [ID!]
  clearProcesses: Boolean
  addCredentialIDs: [ID!]
  removeCredentialIDs: [ID!]
  clearCredentials: Boolean
}
"""
UpdateTagInput is used for update Tag object.
Input was generated by ent.
"""
input UpdateTagInput {
  """
  Name of the tag
  """
  name: String
  """
  Describes the type of tag this is
  """
  kind: TagKind
  addHostIDs: [ID!]
  removeHostIDs: [ID!]
  clearHosts: Boolean
}
"""
UpdateTomeInput is used for update Tome object.
Input was generated by ent.
"""
input UpdateTomeInput {
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time
  """
  Name of the tome
  """
  name: String
  """
  Information about the tome
  """
  description: String
  """
  Name of the author who created the tome.
  """
  author: String
  """
  Information about the tomes support model.
  """
  supportModel: TomeSupportModel
  """
  MITRE ATT&CK tactic provided by the tome.
  """
  tactic: TomeTactic
  """
  JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter.
  """
  paramDefs: String
  clearParamDefs: Boolean
  """
  Eldritch script that will be executed when the tome is run
  """
  eldritch: String
  addFileIDs: [ID!]
  removeFileIDs: [ID!]
  clearFiles: Boolean
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  """
  The name displayed for the user
  """
  name: String
  """
  URL to the user's profile photo.
  """
  photoURL: String
  """
  True if the user is active and able to authenticate
  """
  isActivated: Boolean
  """
  True if the user is an Admin
  """
  isAdmin: Boolean
  addTomeIDs: [ID!]
  removeTomeIDs: [ID!]
  clearTomes: Boolean
  addActiveShellIDs: [ID!]
  removeActiveShellIDs: [ID!]
  clearActiveShells: Boolean
}
type User implements Node {
  id: ID!
  """
  The name displayed for the user
  """
  name: String!
  """
  URL to the user's profile photo.
  """
  photoURL: String!
  """
  True if the user is active and able to authenticate
  """
  isActivated: Boolean!
  """
  True if the user is an Admin
  """
  isAdmin: Boolean!
  tomes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tomes returned from the connection.
    """
    orderBy: [TomeOrder!]

    """
    Filtering options for Tomes returned from the connection.
    """
    where: TomeWhereInput
  ): TomeConnection!
  activeShells(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Shells returned from the connection.
    """
    orderBy: [ShellOrder!]

    """
    Filtering options for Shells returned from the connection.
    """
    where: ShellWhereInput
  ): ShellConnection!
}
"""
A connection to a list of items.
"""
type UserConnection {
  """
  A list of edges.
  """
  edges: [UserEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type UserEdge {
  """
  The item at the end of the edge.
  """
  node: User
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for User connections
"""
input UserOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Users.
  """
  field: UserOrderField!
}
"""
Properties by which User connections can be ordered.
"""
enum UserOrderField {
  NAME
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  photo_url field predicates
  """
  photoURL: String
  photoURLNEQ: String
  photoURLIn: [String!]
  photoURLNotIn: [String!]
  photoURLGT: String
  photoURLGTE: String
  photoURLLT: String
  photoURLLTE: String
  photoURLContains: String
  photoURLHasPrefix: String
  photoURLHasSuffix: String
  photoURLEqualFold: String
  photoURLContainsFold: String
  """
  is_activated field predicates
  """
  isActivated: Boolean
  isActivatedNEQ: Boolean
  """
  is_admin field predicates
  """
  isAdmin: Boolean
  isAdminNEQ: Boolean
  """
  tomes edge predicates
  """
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
  """
  active_shells edge predicates
  """
  hasActiveShells: Boolean
  hasActiveShellsWith: [ShellWhereInput!]
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphql", Input: `scalar Time
scalar Uint64
`, BuiltIn: false},
	{Name: "../schema/query.graphql", Input: `extend type Query {
  files(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Files returned from the connection."""
    orderBy: [FileOrder!]

    """Filtering options for Files returned from the connection."""
    where: FileWhereInput
  ): FileConnection! @requireRole(role: USER)
  quests(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Quests returned from the connection."""
    orderBy: [QuestOrder!]

    """Filtering options for Quests returned from the connection."""
    where: QuestWhereInput
  ): QuestConnection! @requireRole(role: USER)
  tasks(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tasks returned from the connection."""
    orderBy: [TaskOrder!]

    """Filtering options for Tasks returned from the connection."""
    where: TaskWhereInput
  ): TaskConnection! @requireRole(role: USER)
  repositories(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Repositories returned from the connection."""
    orderBy: [RepositoryOrder!]

    """Filtering options for Repositories returned from the connection."""
    where: RepositoryWhereInput
  ): RepositoryConnection! @requireRole(role: USER)
  beacons(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Beacons returned from the connection."""
    orderBy: [BeaconOrder!]

    """Filtering options for Beacons returned from the connection."""
    where: BeaconWhereInput
  ): BeaconConnection! @requireRole(role: USER)
  hosts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Hosts returned from the connection."""
    orderBy: [HostOrder!]

    """Filtering options for Hosts returned from the connection."""
    where: HostWhereInput
  ): HostConnection! @requireRole(role: USER)
  tags(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Repositories returned from the connection."""
    orderBy: [TagOrder!]

    """Filtering options for Repositories returned from the connection."""
    where: TagWhereInput
  ): TagConnection! @requireRole(role: USER)
  tomes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tomes returned from the connection."""
    orderBy: [TomeOrder!]

    """Filtering options for Tomes returned from the connection."""
    where: TomeWhereInput
  ): TomeConnection! @requireRole(role: USER)
  users(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Users returned from the connection."""
    orderBy: [UserOrder!]

    """Filtering options for Users returned from the connection."""
    where: UserWhereInput
  ): UserConnection! @requireRole(role: USER)
  shells(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Shells returned from the connection."""
    orderBy: [ShellOrder!]

    """Filtering options for Shells returned from the connection."""
    where: ShellWhereInput): ShellConnection! @requireRole(role: USER)
  me: User!
}
`, BuiltIn: false},
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
    ####
    # Admin
    ####
    dropAllData: Boolean! @requireRole(role: ADMIN)

    ###
    # Quest
    ###
    createQuest(beaconIDs: [ID!]!, input: CreateQuestInput!): Quest @requireRole(role: USER)

    ###
    # Beacon
    ###
    updateBeacon(beaconID: ID!, input: UpdateBeaconInput!): Beacon! @requireRole(role: USER)

    ###
    # Host
    ###
    updateHost(hostID: ID!, input: UpdateHostInput!): Host! @requireRole(role: USER)

    ###
    # Tag
    ###
    createTag(input: CreateTagInput!): Tag! @requireRole(role: ADMIN)
    updateTag(tagID: ID!, input: UpdateTagInput!): Tag! @requireRole(role: USER)

    ###
    # Tome
    ###
    createTome(input: CreateTomeInput!,): Tome! @requireRole(role: USER)
    updateTome(tomeID: ID!, input: UpdateTomeInput!,): Tome! @requireRole(role: ADMIN)
    deleteTome(tomeID: ID!): ID! @requireRole(role: ADMIN)

    ###
    # Repository
    ###
    createRepository(input: CreateRepositoryInput!): Repository! @requireRole(role: USER)
    importRepository(repoID: ID!, input: ImportRepositoryInput): Repository! @requireRole(role: USER)

    ###
    # User
    ###
    updateUser(userID: ID!, input: UpdateUserInput!): User @requireRole(role: ADMIN)

    ###
    # Credential
    ###
    createCredential(input: CreateHostCredentialInput!): HostCredential! @requireRole(role: USER)
}
`, BuiltIn: false},
	{Name: "../schema/inputs.graphql", Input: `input ClaimTasksInput {
  """The identity the beacon is authenticated as (e.g. 'root')"""
  principal: String!

  """The hostname of the system the beacon is running on."""
  hostname: String!

  """The platform the agent is operating on."""
  hostPlatform: HostPlatform!

  """The IP address of the hosts primary interface (if available)."""
  hostPrimaryIP: String

  """Unique identifier of the beacon, each running instance will be different."""
  beaconIdentifier: String!

  """Unique identifier of the underlying host system the beacon is running on."""
  hostIdentifier: String!

  """Name of the agent program the beacon is running as (e.g. 'imix')"""
  agentIdentifier: String!
}

input SubmitTaskResultInput {
  """ID of the task to submit results for."""
  taskID: ID!

  """Timestamp of when the task execution began. Format as RFC3339Nano."""
  execStartedAt: Time!

  """Timestamp of when the task execution finished (set only if it has completed). Format as RFC3339Nano."""
  execFinishedAt: Time

  """
  Output captured as the result of task execution.
  Submitting multiple outputs will result in appending new output to the previous output.
  """
  output: String!

  """Error message captured as the result of task execution failure."""
  error: String
}
input ImportRepositoryInput {
  """
  Optionally, specify directories to include.
  Only tomes that have a main.eldritch in one of these directory prefixes will be included.
  """
  includeDirs: [String!]
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
