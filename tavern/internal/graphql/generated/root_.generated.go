// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"realm.pub/tavern/internal/ent"
	"realm.pub/tavern/internal/graphql/models"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	HostProcess() HostProcessResolver
	Mutation() MutationResolver
	Query() QueryResolver
	HostProcessWhereInput() HostProcessWhereInputResolver
}

type DirectiveRoot struct {
	RequireRole func(ctx context.Context, obj interface{}, next graphql.Resolver, role models.Role) (res interface{}, err error)
}

type ComplexityRoot struct {
	Beacon struct {
		AgentIdentifier func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Host            func(childComplexity int) int
		ID              func(childComplexity int) int
		Identifier      func(childComplexity int) int
		Interval        func(childComplexity int) int
		LastModifiedAt  func(childComplexity int) int
		LastSeenAt      func(childComplexity int) int
		Name            func(childComplexity int) int
		Principal       func(childComplexity int) int
		Tasks           func(childComplexity int) int
	}

	File struct {
		CreatedAt      func(childComplexity int) int
		Hash           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Size           func(childComplexity int) int
		Tomes          func(childComplexity int) int
	}

	Host struct {
		Beacons        func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Files          func(childComplexity int) int
		ID             func(childComplexity int) int
		Identifier     func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		LastSeenAt     func(childComplexity int) int
		Name           func(childComplexity int) int
		Platform       func(childComplexity int) int
		PrimaryIP      func(childComplexity int) int
		Processes      func(childComplexity int) int
		Tags           func(childComplexity int) int
	}

	HostFile struct {
		CreatedAt      func(childComplexity int) int
		Group          func(childComplexity int) int
		Hash           func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Owner          func(childComplexity int) int
		Path           func(childComplexity int) int
		Permissions    func(childComplexity int) int
		Size           func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	HostProcess struct {
		Cmd            func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Cwd            func(childComplexity int) int
		Env            func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Pid            func(childComplexity int) int
		Ppid           func(childComplexity int) int
		Principal      func(childComplexity int) int
		Status         func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	Mutation struct {
		CreateQuest  func(childComplexity int, beaconIDs []int, input ent.CreateQuestInput) int
		CreateTag    func(childComplexity int, input ent.CreateTagInput) int
		CreateTome   func(childComplexity int, input ent.CreateTomeInput) int
		DeleteTome   func(childComplexity int, tomeID int) int
		UpdateBeacon func(childComplexity int, beaconID int, input ent.UpdateBeaconInput) int
		UpdateHost   func(childComplexity int, hostID int, input ent.UpdateHostInput) int
		UpdateTag    func(childComplexity int, tagID int, input ent.UpdateTagInput) int
		UpdateTome   func(childComplexity int, tomeID int, input ent.UpdateTomeInput) int
		UpdateUser   func(childComplexity int, userID int, input ent.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Beacons func(childComplexity int, where *ent.BeaconWhereInput) int
		Files   func(childComplexity int, where *ent.FileWhereInput) int
		Hosts   func(childComplexity int, where *ent.HostWhereInput) int
		Me      func(childComplexity int) int
		Node    func(childComplexity int, id int) int
		Nodes   func(childComplexity int, ids []int) int
		Quests  func(childComplexity int, where *ent.QuestWhereInput) int
		Tags    func(childComplexity int, where *ent.TagWhereInput) int
		Tasks   func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Tomes   func(childComplexity int, where *ent.TomeWhereInput) int
		Users   func(childComplexity int, where *ent.UserWhereInput) int
	}

	Quest struct {
		Bundle         func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Creator        func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Parameters     func(childComplexity int) int
		Tasks          func(childComplexity int) int
		Tome           func(childComplexity int) int
	}

	Tag struct {
		Hosts func(childComplexity int) int
		ID    func(childComplexity int) int
		Kind  func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	Task struct {
		Beacon            func(childComplexity int) int
		ClaimedAt         func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		Error             func(childComplexity int) int
		ExecFinishedAt    func(childComplexity int) int
		ExecStartedAt     func(childComplexity int) int
		ID                func(childComplexity int) int
		LastModifiedAt    func(childComplexity int) int
		Output            func(childComplexity int) int
		OutputSize        func(childComplexity int) int
		Quest             func(childComplexity int) int
		ReportedFiles     func(childComplexity int) int
		ReportedProcesses func(childComplexity int) int
	}

	TaskConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TaskEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Tome struct {
		Author         func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Description    func(childComplexity int) int
		Eldritch       func(childComplexity int) int
		Files          func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		ParamDefs      func(childComplexity int) int
		SupportModel   func(childComplexity int) int
		Tactic         func(childComplexity int) int
		Uploader       func(childComplexity int) int
	}

	User struct {
		ID          func(childComplexity int) int
		IsActivated func(childComplexity int) int
		IsAdmin     func(childComplexity int) int
		Name        func(childComplexity int) int
		PhotoURL    func(childComplexity int) int
		Tomes       func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Beacon.agentIdentifier":
		if e.complexity.Beacon.AgentIdentifier == nil {
			break
		}

		return e.complexity.Beacon.AgentIdentifier(childComplexity), true

	case "Beacon.createdAt":
		if e.complexity.Beacon.CreatedAt == nil {
			break
		}

		return e.complexity.Beacon.CreatedAt(childComplexity), true

	case "Beacon.host":
		if e.complexity.Beacon.Host == nil {
			break
		}

		return e.complexity.Beacon.Host(childComplexity), true

	case "Beacon.id":
		if e.complexity.Beacon.ID == nil {
			break
		}

		return e.complexity.Beacon.ID(childComplexity), true

	case "Beacon.identifier":
		if e.complexity.Beacon.Identifier == nil {
			break
		}

		return e.complexity.Beacon.Identifier(childComplexity), true

	case "Beacon.interval":
		if e.complexity.Beacon.Interval == nil {
			break
		}

		return e.complexity.Beacon.Interval(childComplexity), true

	case "Beacon.lastModifiedAt":
		if e.complexity.Beacon.LastModifiedAt == nil {
			break
		}

		return e.complexity.Beacon.LastModifiedAt(childComplexity), true

	case "Beacon.lastSeenAt":
		if e.complexity.Beacon.LastSeenAt == nil {
			break
		}

		return e.complexity.Beacon.LastSeenAt(childComplexity), true

	case "Beacon.name":
		if e.complexity.Beacon.Name == nil {
			break
		}

		return e.complexity.Beacon.Name(childComplexity), true

	case "Beacon.principal":
		if e.complexity.Beacon.Principal == nil {
			break
		}

		return e.complexity.Beacon.Principal(childComplexity), true

	case "Beacon.tasks":
		if e.complexity.Beacon.Tasks == nil {
			break
		}

		return e.complexity.Beacon.Tasks(childComplexity), true

	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.hash":
		if e.complexity.File.Hash == nil {
			break
		}

		return e.complexity.File.Hash(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.lastModifiedAt":
		if e.complexity.File.LastModifiedAt == nil {
			break
		}

		return e.complexity.File.LastModifiedAt(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "File.tomes":
		if e.complexity.File.Tomes == nil {
			break
		}

		return e.complexity.File.Tomes(childComplexity), true

	case "Host.beacons":
		if e.complexity.Host.Beacons == nil {
			break
		}

		return e.complexity.Host.Beacons(childComplexity), true

	case "Host.createdAt":
		if e.complexity.Host.CreatedAt == nil {
			break
		}

		return e.complexity.Host.CreatedAt(childComplexity), true

	case "Host.files":
		if e.complexity.Host.Files == nil {
			break
		}

		return e.complexity.Host.Files(childComplexity), true

	case "Host.id":
		if e.complexity.Host.ID == nil {
			break
		}

		return e.complexity.Host.ID(childComplexity), true

	case "Host.identifier":
		if e.complexity.Host.Identifier == nil {
			break
		}

		return e.complexity.Host.Identifier(childComplexity), true

	case "Host.lastModifiedAt":
		if e.complexity.Host.LastModifiedAt == nil {
			break
		}

		return e.complexity.Host.LastModifiedAt(childComplexity), true

	case "Host.lastSeenAt":
		if e.complexity.Host.LastSeenAt == nil {
			break
		}

		return e.complexity.Host.LastSeenAt(childComplexity), true

	case "Host.name":
		if e.complexity.Host.Name == nil {
			break
		}

		return e.complexity.Host.Name(childComplexity), true

	case "Host.platform":
		if e.complexity.Host.Platform == nil {
			break
		}

		return e.complexity.Host.Platform(childComplexity), true

	case "Host.primaryIP":
		if e.complexity.Host.PrimaryIP == nil {
			break
		}

		return e.complexity.Host.PrimaryIP(childComplexity), true

	case "Host.processes":
		if e.complexity.Host.Processes == nil {
			break
		}

		return e.complexity.Host.Processes(childComplexity), true

	case "Host.tags":
		if e.complexity.Host.Tags == nil {
			break
		}

		return e.complexity.Host.Tags(childComplexity), true

	case "HostFile.createdAt":
		if e.complexity.HostFile.CreatedAt == nil {
			break
		}

		return e.complexity.HostFile.CreatedAt(childComplexity), true

	case "HostFile.group":
		if e.complexity.HostFile.Group == nil {
			break
		}

		return e.complexity.HostFile.Group(childComplexity), true

	case "HostFile.hash":
		if e.complexity.HostFile.Hash == nil {
			break
		}

		return e.complexity.HostFile.Hash(childComplexity), true

	case "HostFile.host":
		if e.complexity.HostFile.Host == nil {
			break
		}

		return e.complexity.HostFile.Host(childComplexity), true

	case "HostFile.id":
		if e.complexity.HostFile.ID == nil {
			break
		}

		return e.complexity.HostFile.ID(childComplexity), true

	case "HostFile.lastModifiedAt":
		if e.complexity.HostFile.LastModifiedAt == nil {
			break
		}

		return e.complexity.HostFile.LastModifiedAt(childComplexity), true

	case "HostFile.owner":
		if e.complexity.HostFile.Owner == nil {
			break
		}

		return e.complexity.HostFile.Owner(childComplexity), true

	case "HostFile.path":
		if e.complexity.HostFile.Path == nil {
			break
		}

		return e.complexity.HostFile.Path(childComplexity), true

	case "HostFile.permissions":
		if e.complexity.HostFile.Permissions == nil {
			break
		}

		return e.complexity.HostFile.Permissions(childComplexity), true

	case "HostFile.size":
		if e.complexity.HostFile.Size == nil {
			break
		}

		return e.complexity.HostFile.Size(childComplexity), true

	case "HostFile.task":
		if e.complexity.HostFile.Task == nil {
			break
		}

		return e.complexity.HostFile.Task(childComplexity), true

	case "HostProcess.cmd":
		if e.complexity.HostProcess.Cmd == nil {
			break
		}

		return e.complexity.HostProcess.Cmd(childComplexity), true

	case "HostProcess.createdAt":
		if e.complexity.HostProcess.CreatedAt == nil {
			break
		}

		return e.complexity.HostProcess.CreatedAt(childComplexity), true

	case "HostProcess.cwd":
		if e.complexity.HostProcess.Cwd == nil {
			break
		}

		return e.complexity.HostProcess.Cwd(childComplexity), true

	case "HostProcess.env":
		if e.complexity.HostProcess.Env == nil {
			break
		}

		return e.complexity.HostProcess.Env(childComplexity), true

	case "HostProcess.host":
		if e.complexity.HostProcess.Host == nil {
			break
		}

		return e.complexity.HostProcess.Host(childComplexity), true

	case "HostProcess.id":
		if e.complexity.HostProcess.ID == nil {
			break
		}

		return e.complexity.HostProcess.ID(childComplexity), true

	case "HostProcess.lastModifiedAt":
		if e.complexity.HostProcess.LastModifiedAt == nil {
			break
		}

		return e.complexity.HostProcess.LastModifiedAt(childComplexity), true

	case "HostProcess.name":
		if e.complexity.HostProcess.Name == nil {
			break
		}

		return e.complexity.HostProcess.Name(childComplexity), true

	case "HostProcess.path":
		if e.complexity.HostProcess.Path == nil {
			break
		}

		return e.complexity.HostProcess.Path(childComplexity), true

	case "HostProcess.pid":
		if e.complexity.HostProcess.Pid == nil {
			break
		}

		return e.complexity.HostProcess.Pid(childComplexity), true

	case "HostProcess.ppid":
		if e.complexity.HostProcess.Ppid == nil {
			break
		}

		return e.complexity.HostProcess.Ppid(childComplexity), true

	case "HostProcess.principal":
		if e.complexity.HostProcess.Principal == nil {
			break
		}

		return e.complexity.HostProcess.Principal(childComplexity), true

	case "HostProcess.status":
		if e.complexity.HostProcess.Status == nil {
			break
		}

		return e.complexity.HostProcess.Status(childComplexity), true

	case "HostProcess.task":
		if e.complexity.HostProcess.Task == nil {
			break
		}

		return e.complexity.HostProcess.Task(childComplexity), true

	case "Mutation.createQuest":
		if e.complexity.Mutation.CreateQuest == nil {
			break
		}

		args, err := ec.field_Mutation_createQuest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateQuest(childComplexity, args["beaconIDs"].([]int), args["input"].(ent.CreateQuestInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(ent.CreateTagInput)), true

	case "Mutation.createTome":
		if e.complexity.Mutation.CreateTome == nil {
			break
		}

		args, err := ec.field_Mutation_createTome_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTome(childComplexity, args["input"].(ent.CreateTomeInput)), true

	case "Mutation.deleteTome":
		if e.complexity.Mutation.DeleteTome == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTome_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTome(childComplexity, args["tomeID"].(int)), true

	case "Mutation.updateBeacon":
		if e.complexity.Mutation.UpdateBeacon == nil {
			break
		}

		args, err := ec.field_Mutation_updateBeacon_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBeacon(childComplexity, args["beaconID"].(int), args["input"].(ent.UpdateBeaconInput)), true

	case "Mutation.updateHost":
		if e.complexity.Mutation.UpdateHost == nil {
			break
		}

		args, err := ec.field_Mutation_updateHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHost(childComplexity, args["hostID"].(int), args["input"].(ent.UpdateHostInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["tagID"].(int), args["input"].(ent.UpdateTagInput)), true

	case "Mutation.updateTome":
		if e.complexity.Mutation.UpdateTome == nil {
			break
		}

		args, err := ec.field_Mutation_updateTome_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTome(childComplexity, args["tomeID"].(int), args["input"].(ent.UpdateTomeInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["userID"].(int), args["input"].(ent.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.beacons":
		if e.complexity.Query.Beacons == nil {
			break
		}

		args, err := ec.field_Query_beacons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Beacons(childComplexity, args["where"].(*ent.BeaconWhereInput)), true

	case "Query.files":
		if e.complexity.Query.Files == nil {
			break
		}

		args, err := ec.field_Query_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Files(childComplexity, args["where"].(*ent.FileWhereInput)), true

	case "Query.hosts":
		if e.complexity.Query.Hosts == nil {
			break
		}

		args, err := ec.field_Query_hosts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hosts(childComplexity, args["where"].(*ent.HostWhereInput)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.quests":
		if e.complexity.Query.Quests == nil {
			break
		}

		args, err := ec.field_Query_quests_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Quests(childComplexity, args["where"].(*ent.QuestWhereInput)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		args, err := ec.field_Query_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tags(childComplexity, args["where"].(*ent.TagWhereInput)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		args, err := ec.field_Query_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Query.tomes":
		if e.complexity.Query.Tomes == nil {
			break
		}

		args, err := ec.field_Query_tomes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tomes(childComplexity, args["where"].(*ent.TomeWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["where"].(*ent.UserWhereInput)), true

	case "Quest.bundle":
		if e.complexity.Quest.Bundle == nil {
			break
		}

		return e.complexity.Quest.Bundle(childComplexity), true

	case "Quest.createdAt":
		if e.complexity.Quest.CreatedAt == nil {
			break
		}

		return e.complexity.Quest.CreatedAt(childComplexity), true

	case "Quest.creator":
		if e.complexity.Quest.Creator == nil {
			break
		}

		return e.complexity.Quest.Creator(childComplexity), true

	case "Quest.id":
		if e.complexity.Quest.ID == nil {
			break
		}

		return e.complexity.Quest.ID(childComplexity), true

	case "Quest.lastModifiedAt":
		if e.complexity.Quest.LastModifiedAt == nil {
			break
		}

		return e.complexity.Quest.LastModifiedAt(childComplexity), true

	case "Quest.name":
		if e.complexity.Quest.Name == nil {
			break
		}

		return e.complexity.Quest.Name(childComplexity), true

	case "Quest.parameters":
		if e.complexity.Quest.Parameters == nil {
			break
		}

		return e.complexity.Quest.Parameters(childComplexity), true

	case "Quest.tasks":
		if e.complexity.Quest.Tasks == nil {
			break
		}

		return e.complexity.Quest.Tasks(childComplexity), true

	case "Quest.tome":
		if e.complexity.Quest.Tome == nil {
			break
		}

		return e.complexity.Quest.Tome(childComplexity), true

	case "Tag.hosts":
		if e.complexity.Tag.Hosts == nil {
			break
		}

		return e.complexity.Tag.Hosts(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.kind":
		if e.complexity.Tag.Kind == nil {
			break
		}

		return e.complexity.Tag.Kind(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Task.beacon":
		if e.complexity.Task.Beacon == nil {
			break
		}

		return e.complexity.Task.Beacon(childComplexity), true

	case "Task.claimedAt":
		if e.complexity.Task.ClaimedAt == nil {
			break
		}

		return e.complexity.Task.ClaimedAt(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.error":
		if e.complexity.Task.Error == nil {
			break
		}

		return e.complexity.Task.Error(childComplexity), true

	case "Task.execFinishedAt":
		if e.complexity.Task.ExecFinishedAt == nil {
			break
		}

		return e.complexity.Task.ExecFinishedAt(childComplexity), true

	case "Task.execStartedAt":
		if e.complexity.Task.ExecStartedAt == nil {
			break
		}

		return e.complexity.Task.ExecStartedAt(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.lastModifiedAt":
		if e.complexity.Task.LastModifiedAt == nil {
			break
		}

		return e.complexity.Task.LastModifiedAt(childComplexity), true

	case "Task.output":
		if e.complexity.Task.Output == nil {
			break
		}

		return e.complexity.Task.Output(childComplexity), true

	case "Task.outputSize":
		if e.complexity.Task.OutputSize == nil {
			break
		}

		return e.complexity.Task.OutputSize(childComplexity), true

	case "Task.quest":
		if e.complexity.Task.Quest == nil {
			break
		}

		return e.complexity.Task.Quest(childComplexity), true

	case "Task.reportedFiles":
		if e.complexity.Task.ReportedFiles == nil {
			break
		}

		return e.complexity.Task.ReportedFiles(childComplexity), true

	case "Task.reportedProcesses":
		if e.complexity.Task.ReportedProcesses == nil {
			break
		}

		return e.complexity.Task.ReportedProcesses(childComplexity), true

	case "TaskConnection.edges":
		if e.complexity.TaskConnection.Edges == nil {
			break
		}

		return e.complexity.TaskConnection.Edges(childComplexity), true

	case "TaskConnection.pageInfo":
		if e.complexity.TaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.TaskConnection.PageInfo(childComplexity), true

	case "TaskConnection.totalCount":
		if e.complexity.TaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.TaskConnection.TotalCount(childComplexity), true

	case "TaskEdge.cursor":
		if e.complexity.TaskEdge.Cursor == nil {
			break
		}

		return e.complexity.TaskEdge.Cursor(childComplexity), true

	case "TaskEdge.node":
		if e.complexity.TaskEdge.Node == nil {
			break
		}

		return e.complexity.TaskEdge.Node(childComplexity), true

	case "Tome.author":
		if e.complexity.Tome.Author == nil {
			break
		}

		return e.complexity.Tome.Author(childComplexity), true

	case "Tome.createdAt":
		if e.complexity.Tome.CreatedAt == nil {
			break
		}

		return e.complexity.Tome.CreatedAt(childComplexity), true

	case "Tome.description":
		if e.complexity.Tome.Description == nil {
			break
		}

		return e.complexity.Tome.Description(childComplexity), true

	case "Tome.eldritch":
		if e.complexity.Tome.Eldritch == nil {
			break
		}

		return e.complexity.Tome.Eldritch(childComplexity), true

	case "Tome.files":
		if e.complexity.Tome.Files == nil {
			break
		}

		return e.complexity.Tome.Files(childComplexity), true

	case "Tome.id":
		if e.complexity.Tome.ID == nil {
			break
		}

		return e.complexity.Tome.ID(childComplexity), true

	case "Tome.lastModifiedAt":
		if e.complexity.Tome.LastModifiedAt == nil {
			break
		}

		return e.complexity.Tome.LastModifiedAt(childComplexity), true

	case "Tome.name":
		if e.complexity.Tome.Name == nil {
			break
		}

		return e.complexity.Tome.Name(childComplexity), true

	case "Tome.paramDefs":
		if e.complexity.Tome.ParamDefs == nil {
			break
		}

		return e.complexity.Tome.ParamDefs(childComplexity), true

	case "Tome.supportModel":
		if e.complexity.Tome.SupportModel == nil {
			break
		}

		return e.complexity.Tome.SupportModel(childComplexity), true

	case "Tome.tactic":
		if e.complexity.Tome.Tactic == nil {
			break
		}

		return e.complexity.Tome.Tactic(childComplexity), true

	case "Tome.uploader":
		if e.complexity.Tome.Uploader == nil {
			break
		}

		return e.complexity.Tome.Uploader(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isActivated":
		if e.complexity.User.IsActivated == nil {
			break
		}

		return e.complexity.User.IsActivated(childComplexity), true

	case "User.isAdmin":
		if e.complexity.User.IsAdmin == nil {
			break
		}

		return e.complexity.User.IsAdmin(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.photoURL":
		if e.complexity.User.PhotoURL == nil {
			break
		}

		return e.complexity.User.PhotoURL(childComplexity), true

	case "User.tomes":
		if e.complexity.User.Tomes == nil {
			break
		}

		return e.complexity.User.Tomes(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBeaconOrder,
		ec.unmarshalInputBeaconWhereInput,
		ec.unmarshalInputClaimTasksInput,
		ec.unmarshalInputCreateQuestInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputCreateTomeInput,
		ec.unmarshalInputFileOrder,
		ec.unmarshalInputFileWhereInput,
		ec.unmarshalInputHostFileOrder,
		ec.unmarshalInputHostFileWhereInput,
		ec.unmarshalInputHostOrder,
		ec.unmarshalInputHostProcessOrder,
		ec.unmarshalInputHostProcessWhereInput,
		ec.unmarshalInputHostWhereInput,
		ec.unmarshalInputQuestOrder,
		ec.unmarshalInputQuestWhereInput,
		ec.unmarshalInputSubmitTaskResultInput,
		ec.unmarshalInputTagOrder,
		ec.unmarshalInputTagWhereInput,
		ec.unmarshalInputTaskOrder,
		ec.unmarshalInputTaskWhereInput,
		ec.unmarshalInputTomeOrder,
		ec.unmarshalInputTomeWhereInput,
		ec.unmarshalInputUpdateBeaconInput,
		ec.unmarshalInputUpdateHostInput,
		ec.unmarshalInputUpdateTagInput,
		ec.unmarshalInputUpdateTomeInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/directives.graphql", Input: `directive @requireRole(role: Role!) on FIELD_DEFINITION

enum Role {
    ADMIN
    USER
}`, BuiltIn: false},
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Beacon implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """A human readable identifier for the beacon."""
  name: String!
  """The identity the beacon is authenticated as (e.g. 'root')"""
  principal: String
  """Unique identifier for the beacon. Unique to each instance of the beacon."""
  identifier: String!
  """Identifies the agent that the beacon is running as (e.g. 'imix')."""
  agentIdentifier: String
  """Timestamp of when a task was last claimed or updated for the beacon."""
  lastSeenAt: Time
  """Duration until next callback, in seconds."""
  interval: Uint64
  """Host this beacon is running on."""
  host: Host!
  """Tasks that have been assigned to the beacon."""
  tasks: [Task!]
}
"""Ordering options for Beacon connections"""
input BeaconOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Beacons."""
  field: BeaconOrderField!
}
"""Properties by which Beacon connections can be ordered."""
enum BeaconOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_SEEN_AT
  INTERVAL
}
"""
BeaconWhereInput is used for filtering Beacon objects.
Input was generated by ent.
"""
input BeaconWhereInput {
  not: BeaconWhereInput
  and: [BeaconWhereInput!]
  or: [BeaconWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """principal field predicates"""
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalIsNil: Boolean
  principalNotNil: Boolean
  principalEqualFold: String
  principalContainsFold: String
  """identifier field predicates"""
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """agent_identifier field predicates"""
  agentIdentifier: String
  agentIdentifierNEQ: String
  agentIdentifierIn: [String!]
  agentIdentifierNotIn: [String!]
  agentIdentifierGT: String
  agentIdentifierGTE: String
  agentIdentifierLT: String
  agentIdentifierLTE: String
  agentIdentifierContains: String
  agentIdentifierHasPrefix: String
  agentIdentifierHasSuffix: String
  agentIdentifierIsNil: Boolean
  agentIdentifierNotNil: Boolean
  agentIdentifierEqualFold: String
  agentIdentifierContainsFold: String
  """last_seen_at field predicates"""
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """interval field predicates"""
  interval: Uint64
  intervalNEQ: Uint64
  intervalIn: [Uint64!]
  intervalNotIn: [Uint64!]
  intervalGT: Uint64
  intervalGTE: Uint64
  intervalLT: Uint64
  intervalLTE: Uint64
  intervalIsNil: Boolean
  intervalNotNil: Boolean
  """host edge predicates"""
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """tasks edge predicates"""
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
}
"""
CreateQuestInput is used for create Quest object.
Input was generated by ent.
"""
input CreateQuestInput {
  """Name of the quest"""
  name: String!
  """Value of parameters that were specified for the quest (as a JSON string)."""
  parameters: String
  tomeID: ID!
}
"""
CreateTagInput is used for create Tag object.
Input was generated by ent.
"""
input CreateTagInput {
  """Name of the tag"""
  name: String!
  """Describes the type of tag this is"""
  kind: TagKind!
  hostIDs: [ID!]
}
"""
CreateTomeInput is used for create Tome object.
Input was generated by ent.
"""
input CreateTomeInput {
  """Name of the tome"""
  name: String!
  """Information about the tome"""
  description: String!
  """Name of the author who created the tome."""
  author: String!
  """Information about the tomes support model."""
  supportModel: TomeSupportModel
  """MITRE ATT&CK tactic provided by the tome."""
  tactic: TomeTactic
  """JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter."""
  paramDefs: String
  """Eldritch script that will be executed when the tome is run"""
  eldritch: String!
  fileIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type File implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """The name of the file, used to reference it for downloads"""
  name: String!
  """The size of the file in bytes"""
  size: Int!
  """A SHA3-256 digest of the content field"""
  hash: String!
  tomes: [Tome!]
}
"""Ordering options for File connections"""
input FileOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Files."""
  field: FileOrderField!
}
"""Properties by which File connections can be ordered."""
enum FileOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
FileWhereInput is used for filtering File objects.
Input was generated by ent.
"""
input FileWhereInput {
  not: FileWhereInput
  and: [FileWhereInput!]
  or: [FileWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """size field predicates"""
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """hash field predicates"""
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashEqualFold: String
  hashContainsFold: String
  """tomes edge predicates"""
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
}
type Host implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """Unique identifier for the host. Unique to each host."""
  identifier: String!
  """A human readable identifier for the host."""
  name: String
  """Primary interface IP address reported by the agent."""
  primaryIP: String
  """Platform the agent is operating on."""
  platform: HostPlatform!
  """Timestamp of when a task was last claimed or updated for the host."""
  lastSeenAt: Time
  """Tags used to group this host with other hosts."""
  tags: [Tag!]
  """Beacons that are present on this host system."""
  beacons: [Beacon!]
  """Files reported on this host system."""
  files: [HostFile!]
  """Processes reported as running on this host system."""
  processes: [HostProcess!]
}
type HostFile implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """Path to the file on the host system."""
  path: String!
  """User who owns the file on the host system."""
  owner: String
  """Group who owns the file on the host system."""
  group: String
  """Permissions for the file on the host system."""
  permissions: String
  """The size of the file in bytes"""
  size: Int!
  """A SHA3-256 digest of the content field"""
  hash: String
  """Host the file was reported on."""
  host: Host!
  """Task that reported this file."""
  task: Task!
}
"""Ordering options for HostFile connections"""
input HostFileOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order HostFiles."""
  field: HostFileOrderField!
}
"""Properties by which HostFile connections can be ordered."""
enum HostFileOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
HostFileWhereInput is used for filtering HostFile objects.
Input was generated by ent.
"""
input HostFileWhereInput {
  not: HostFileWhereInput
  and: [HostFileWhereInput!]
  or: [HostFileWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """path field predicates"""
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathEqualFold: String
  pathContainsFold: String
  """owner field predicates"""
  owner: String
  ownerNEQ: String
  ownerIn: [String!]
  ownerNotIn: [String!]
  ownerGT: String
  ownerGTE: String
  ownerLT: String
  ownerLTE: String
  ownerContains: String
  ownerHasPrefix: String
  ownerHasSuffix: String
  ownerIsNil: Boolean
  ownerNotNil: Boolean
  ownerEqualFold: String
  ownerContainsFold: String
  """group field predicates"""
  group: String
  groupNEQ: String
  groupIn: [String!]
  groupNotIn: [String!]
  groupGT: String
  groupGTE: String
  groupLT: String
  groupLTE: String
  groupContains: String
  groupHasPrefix: String
  groupHasSuffix: String
  groupIsNil: Boolean
  groupNotNil: Boolean
  groupEqualFold: String
  groupContainsFold: String
  """permissions field predicates"""
  permissions: String
  permissionsNEQ: String
  permissionsIn: [String!]
  permissionsNotIn: [String!]
  permissionsGT: String
  permissionsGTE: String
  permissionsLT: String
  permissionsLTE: String
  permissionsContains: String
  permissionsHasPrefix: String
  permissionsHasSuffix: String
  permissionsIsNil: Boolean
  permissionsNotNil: Boolean
  permissionsEqualFold: String
  permissionsContainsFold: String
  """size field predicates"""
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """hash field predicates"""
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashIsNil: Boolean
  hashNotNil: Boolean
  hashEqualFold: String
  hashContainsFold: String
  """host edge predicates"""
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """task edge predicates"""
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
}
"""Ordering options for Host connections"""
input HostOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Hosts."""
  field: HostOrderField!
}
"""Properties by which Host connections can be ordered."""
enum HostOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_SEEN_AT
}
"""HostPlatform is enum for the field platform"""
enum HostPlatform @goModel(model: "realm.pub/tavern/internal/c2/c2pb.Host_Platform") {
  PLATFORM_MACOS
  PLATFORM_BSD
  PLATFORM_UNSPECIFIED
  PLATFORM_WINDOWS
  PLATFORM_LINUX
}
type HostProcess implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """ID of the process."""
  pid: Int!
  """ID of the parent process."""
  ppid: Int!
  """The name of the process."""
  name: String!
  """The user the process is running as."""
  principal: String!
  """The path to the process executable."""
  path: String
  """The command used to execute the process."""
  cmd: String
  """The environment variables set for the process."""
  env: String
  """The current working directory for the process."""
  cwd: String
  """Current process status."""
  status: HostProcessStatus!
  """Host the process was reported on."""
  host: Host!
  """Task that reported this process."""
  task: Task!
}
"""Ordering options for HostProcess connections"""
input HostProcessOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order HostProcesses."""
  field: HostProcessOrderField!
}
"""Properties by which HostProcess connections can be ordered."""
enum HostProcessOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  PROCESS_ID
  PARENT_PROCESS_ID
  NAME
}
"""HostProcessStatus is enum for the field status"""
enum HostProcessStatus @goModel(model: "realm.pub/tavern/internal/c2/epb.Process_Status") {
  STATUS_ZOMBIE
  STATUS_WAKING
  STATUS_UNINTERUPTIBLE_DISK_SLEEP
  STATUS_UNKNOWN
  STATUS_WAKE_KILL
  STATUS_LOCK_BLOCKED
  STATUS_IDLE
  STATUS_RUN
  STATUS_SLEEP
  STATUS_TRACING
  STATUS_UNSPECIFIED
  STATUS_STOP
  STATUS_DEAD
  STATUS_PARKED
}
"""
HostProcessWhereInput is used for filtering HostProcess objects.
Input was generated by ent.
"""
input HostProcessWhereInput {
  not: HostProcessWhereInput
  and: [HostProcessWhereInput!]
  or: [HostProcessWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """pid field predicates"""
  pid: Int
  pidNEQ: Int
  pidIn: [Int!]
  pidNotIn: [Int!]
  pidGT: Int
  pidGTE: Int
  pidLT: Int
  pidLTE: Int
  """ppid field predicates"""
  ppid: Int
  ppidNEQ: Int
  ppidIn: [Int!]
  ppidNotIn: [Int!]
  ppidGT: Int
  ppidGTE: Int
  ppidLT: Int
  ppidLTE: Int
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """principal field predicates"""
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalEqualFold: String
  principalContainsFold: String
  """path field predicates"""
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathIsNil: Boolean
  pathNotNil: Boolean
  pathEqualFold: String
  pathContainsFold: String
  """cmd field predicates"""
  cmd: String
  cmdNEQ: String
  cmdIn: [String!]
  cmdNotIn: [String!]
  cmdGT: String
  cmdGTE: String
  cmdLT: String
  cmdLTE: String
  cmdContains: String
  cmdHasPrefix: String
  cmdHasSuffix: String
  cmdIsNil: Boolean
  cmdNotNil: Boolean
  cmdEqualFold: String
  cmdContainsFold: String
  """env field predicates"""
  env: String
  envNEQ: String
  envIn: [String!]
  envNotIn: [String!]
  envGT: String
  envGTE: String
  envLT: String
  envLTE: String
  envContains: String
  envHasPrefix: String
  envHasSuffix: String
  envIsNil: Boolean
  envNotNil: Boolean
  envEqualFold: String
  envContainsFold: String
  """cwd field predicates"""
  cwd: String
  cwdNEQ: String
  cwdIn: [String!]
  cwdNotIn: [String!]
  cwdGT: String
  cwdGTE: String
  cwdLT: String
  cwdLTE: String
  cwdContains: String
  cwdHasPrefix: String
  cwdHasSuffix: String
  cwdIsNil: Boolean
  cwdNotNil: Boolean
  cwdEqualFold: String
  cwdContainsFold: String
  """status field predicates"""
  status: HostProcessStatus
  statusNEQ: HostProcessStatus
  statusIn: [HostProcessStatus!]
  statusNotIn: [HostProcessStatus!]
  """host edge predicates"""
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """task edge predicates"""
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
}
"""
HostWhereInput is used for filtering Host objects.
Input was generated by ent.
"""
input HostWhereInput {
  not: HostWhereInput
  and: [HostWhereInput!]
  or: [HostWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """identifier field predicates"""
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """primary_ip field predicates"""
  primaryIP: String
  primaryIPNEQ: String
  primaryIPIn: [String!]
  primaryIPNotIn: [String!]
  primaryIPGT: String
  primaryIPGTE: String
  primaryIPLT: String
  primaryIPLTE: String
  primaryIPContains: String
  primaryIPHasPrefix: String
  primaryIPHasSuffix: String
  primaryIPIsNil: Boolean
  primaryIPNotNil: Boolean
  primaryIPEqualFold: String
  primaryIPContainsFold: String
  """platform field predicates"""
  platform: HostPlatform
  platformNEQ: HostPlatform
  platformIn: [HostPlatform!]
  platformNotIn: [HostPlatform!]
  """last_seen_at field predicates"""
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """tags edge predicates"""
  hasTags: Boolean
  hasTagsWith: [TagWhereInput!]
  """beacons edge predicates"""
  hasBeacons: Boolean
  hasBeaconsWith: [BeaconWhereInput!]
  """files edge predicates"""
  hasFiles: Boolean
  hasFilesWith: [HostFileWhereInput!]
  """processes edge predicates"""
  hasProcesses: Boolean
  hasProcessesWith: [HostProcessWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "realm.pub/tavern/internal/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
}
type Quest implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """Name of the quest"""
  name: String!
  """Value of parameters that were specified for the quest (as a JSON string)."""
  parameters: String
  """Tome that this quest will be executing"""
  tome: Tome!
  """Bundle file that the executing tome depends on (if any)"""
  bundle: File
  """Tasks tracking the status and output of individual tome execution on targets"""
  tasks: [Task!]
  """User that created the quest if available."""
  creator: User
}
"""Ordering options for Quest connections"""
input QuestOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Quests."""
  field: QuestOrderField!
}
"""Properties by which Quest connections can be ordered."""
enum QuestOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
QuestWhereInput is used for filtering Quest objects.
Input was generated by ent.
"""
input QuestWhereInput {
  not: QuestWhereInput
  and: [QuestWhereInput!]
  or: [QuestWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """parameters field predicates"""
  parameters: String
  parametersNEQ: String
  parametersIn: [String!]
  parametersNotIn: [String!]
  parametersGT: String
  parametersGTE: String
  parametersLT: String
  parametersLTE: String
  parametersContains: String
  parametersHasPrefix: String
  parametersHasSuffix: String
  parametersIsNil: Boolean
  parametersNotNil: Boolean
  parametersEqualFold: String
  parametersContainsFold: String
  """tome edge predicates"""
  hasTome: Boolean
  hasTomeWith: [TomeWhereInput!]
  """bundle edge predicates"""
  hasBundle: Boolean
  hasBundleWith: [FileWhereInput!]
  """tasks edge predicates"""
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
  """creator edge predicates"""
  hasCreator: Boolean
  hasCreatorWith: [UserWhereInput!]
}
type Tag implements Node {
  id: ID!
  """Name of the tag"""
  name: String!
  """Describes the type of tag this is"""
  kind: TagKind!
  hosts: [Host!]
}
"""TagKind is enum for the field kind"""
enum TagKind @goModel(model: "realm.pub/tavern/internal/ent/tag.Kind") {
  group
  service
}
"""Ordering options for Tag connections"""
input TagOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tags."""
  field: TagOrderField!
}
"""Properties by which Tag connections can be ordered."""
enum TagOrderField {
  NAME
}
"""
TagWhereInput is used for filtering Tag objects.
Input was generated by ent.
"""
input TagWhereInput {
  not: TagWhereInput
  and: [TagWhereInput!]
  or: [TagWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """kind field predicates"""
  kind: TagKind
  kindNEQ: TagKind
  kindIn: [TagKind!]
  kindNotIn: [TagKind!]
  """hosts edge predicates"""
  hasHosts: Boolean
  hasHostsWith: [HostWhereInput!]
}
type Task implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """Timestamp of when the task was claimed, null if not yet claimed"""
  claimedAt: Time
  """Timestamp of when execution of the task started, null if not yet started"""
  execStartedAt: Time
  """Timestamp of when execution of the task finished, null if not yet finished"""
  execFinishedAt: Time
  """Output from executing the task"""
  output: String
  """The size of the output in bytes"""
  outputSize: Int!
  """Error, if any, produced while executing the Task"""
  error: String
  quest: Quest!
  beacon: Beacon!
  """Files that have been reported by this task."""
  reportedFiles: [HostFile!]
  """Processes that have been reported by this task."""
  reportedProcesses: [HostProcess!]
}
"""A connection to a list of items."""
type TaskConnection {
  """A list of edges."""
  edges: [TaskEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type TaskEdge {
  """The item at the end of the edge."""
  node: Task
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Task connections"""
input TaskOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tasks."""
  field: TaskOrderField!
}
"""Properties by which Task connections can be ordered."""
enum TaskOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLAIMED_AT
  EXEC_STARTED_AT
  EXEC_FINISHED_AT
  OUTPUT_SIZE
}
"""
TaskWhereInput is used for filtering Task objects.
Input was generated by ent.
"""
input TaskWhereInput {
  not: TaskWhereInput
  and: [TaskWhereInput!]
  or: [TaskWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """claimed_at field predicates"""
  claimedAt: Time
  claimedAtNEQ: Time
  claimedAtIn: [Time!]
  claimedAtNotIn: [Time!]
  claimedAtGT: Time
  claimedAtGTE: Time
  claimedAtLT: Time
  claimedAtLTE: Time
  claimedAtIsNil: Boolean
  claimedAtNotNil: Boolean
  """exec_started_at field predicates"""
  execStartedAt: Time
  execStartedAtNEQ: Time
  execStartedAtIn: [Time!]
  execStartedAtNotIn: [Time!]
  execStartedAtGT: Time
  execStartedAtGTE: Time
  execStartedAtLT: Time
  execStartedAtLTE: Time
  execStartedAtIsNil: Boolean
  execStartedAtNotNil: Boolean
  """exec_finished_at field predicates"""
  execFinishedAt: Time
  execFinishedAtNEQ: Time
  execFinishedAtIn: [Time!]
  execFinishedAtNotIn: [Time!]
  execFinishedAtGT: Time
  execFinishedAtGTE: Time
  execFinishedAtLT: Time
  execFinishedAtLTE: Time
  execFinishedAtIsNil: Boolean
  execFinishedAtNotNil: Boolean
  """output field predicates"""
  output: String
  outputNEQ: String
  outputIn: [String!]
  outputNotIn: [String!]
  outputGT: String
  outputGTE: String
  outputLT: String
  outputLTE: String
  outputContains: String
  outputHasPrefix: String
  outputHasSuffix: String
  outputIsNil: Boolean
  outputNotNil: Boolean
  outputEqualFold: String
  outputContainsFold: String
  """output_size field predicates"""
  outputSize: Int
  outputSizeNEQ: Int
  outputSizeIn: [Int!]
  outputSizeNotIn: [Int!]
  outputSizeGT: Int
  outputSizeGTE: Int
  outputSizeLT: Int
  outputSizeLTE: Int
  """error field predicates"""
  error: String
  errorNEQ: String
  errorIn: [String!]
  errorNotIn: [String!]
  errorGT: String
  errorGTE: String
  errorLT: String
  errorLTE: String
  errorContains: String
  errorHasPrefix: String
  errorHasSuffix: String
  errorIsNil: Boolean
  errorNotNil: Boolean
  errorEqualFold: String
  errorContainsFold: String
  """quest edge predicates"""
  hasQuest: Boolean
  hasQuestWith: [QuestWhereInput!]
  """beacon edge predicates"""
  hasBeacon: Boolean
  hasBeaconWith: [BeaconWhereInput!]
  """reported_files edge predicates"""
  hasReportedFiles: Boolean
  hasReportedFilesWith: [HostFileWhereInput!]
  """reported_processes edge predicates"""
  hasReportedProcesses: Boolean
  hasReportedProcessesWith: [HostProcessWhereInput!]
}
type Tome implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """Name of the tome"""
  name: String!
  """Information about the tome"""
  description: String!
  """Name of the author who created the tome."""
  author: String!
  """Information about the tomes support model."""
  supportModel: TomeSupportModel!
  """MITRE ATT&CK tactic provided by the tome."""
  tactic: TomeTactic!
  """JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter."""
  paramDefs: String
  """Eldritch script that will be executed when the tome is run"""
  eldritch: String!
  """Any files required for tome execution that will be bundled and provided to the agent for download"""
  files: [File!]
  """User who uploaded the tome (may be null)."""
  uploader: User
}
"""Ordering options for Tome connections"""
input TomeOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tomes."""
  field: TomeOrderField!
}
"""Properties by which Tome connections can be ordered."""
enum TomeOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""TomeSupportModel is enum for the field support_model"""
enum TomeSupportModel @goModel(model: "realm.pub/tavern/internal/ent/tome.SupportModel") {
  UNSPECIFIED
  FIRST_PARTY
  COMMUNITY
}
"""TomeTactic is enum for the field tactic"""
enum TomeTactic @goModel(model: "realm.pub/tavern/internal/ent/tome.Tactic") {
  UNSPECIFIED
  RECON
  RESOURCE_DEVELOPMENT
  INITIAL_ACCESS
  EXECUTION
  PERSISTENCE
  PRIVILEGE_ESCALATION
  DEFENSE_EVASION
  CREDENTIAL_ACCESS
  DISCOVERY
  LATERAL_MOVEMENT
  COLLECTION
  COMMAND_AND_CONTROL
  EXFILTRATION
  IMPACT
}
"""
TomeWhereInput is used for filtering Tome objects.
Input was generated by ent.
"""
input TomeWhereInput {
  not: TomeWhereInput
  and: [TomeWhereInput!]
  or: [TomeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionEqualFold: String
  descriptionContainsFold: String
  """author field predicates"""
  author: String
  authorNEQ: String
  authorIn: [String!]
  authorNotIn: [String!]
  authorGT: String
  authorGTE: String
  authorLT: String
  authorLTE: String
  authorContains: String
  authorHasPrefix: String
  authorHasSuffix: String
  authorEqualFold: String
  authorContainsFold: String
  """support_model field predicates"""
  supportModel: TomeSupportModel
  supportModelNEQ: TomeSupportModel
  supportModelIn: [TomeSupportModel!]
  supportModelNotIn: [TomeSupportModel!]
  """tactic field predicates"""
  tactic: TomeTactic
  tacticNEQ: TomeTactic
  tacticIn: [TomeTactic!]
  tacticNotIn: [TomeTactic!]
  """param_defs field predicates"""
  paramDefs: String
  paramDefsNEQ: String
  paramDefsIn: [String!]
  paramDefsNotIn: [String!]
  paramDefsGT: String
  paramDefsGTE: String
  paramDefsLT: String
  paramDefsLTE: String
  paramDefsContains: String
  paramDefsHasPrefix: String
  paramDefsHasSuffix: String
  paramDefsIsNil: Boolean
  paramDefsNotNil: Boolean
  paramDefsEqualFold: String
  paramDefsContainsFold: String
  """eldritch field predicates"""
  eldritch: String
  eldritchNEQ: String
  eldritchIn: [String!]
  eldritchNotIn: [String!]
  eldritchGT: String
  eldritchGTE: String
  eldritchLT: String
  eldritchLTE: String
  eldritchContains: String
  eldritchHasPrefix: String
  eldritchHasSuffix: String
  eldritchEqualFold: String
  eldritchContainsFold: String
  """files edge predicates"""
  hasFiles: Boolean
  hasFilesWith: [FileWhereInput!]
  """uploader edge predicates"""
  hasUploader: Boolean
  hasUploaderWith: [UserWhereInput!]
}
"""
UpdateBeaconInput is used for update Beacon object.
Input was generated by ent.
"""
input UpdateBeaconInput {
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time
  hostID: ID
}
"""
UpdateHostInput is used for update Host object.
Input was generated by ent.
"""
input UpdateHostInput {
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time
  """A human readable identifier for the host."""
  name: String
  clearName: Boolean
  addTagIDs: [ID!]
  removeTagIDs: [ID!]
  clearTags: Boolean
  addBeaconIDs: [ID!]
  removeBeaconIDs: [ID!]
  clearBeacons: Boolean
  addFileIDs: [ID!]
  removeFileIDs: [ID!]
  clearFiles: Boolean
  addProcessIDs: [ID!]
  removeProcessIDs: [ID!]
  clearProcesses: Boolean
}
"""
UpdateTagInput is used for update Tag object.
Input was generated by ent.
"""
input UpdateTagInput {
  """Name of the tag"""
  name: String
  """Describes the type of tag this is"""
  kind: TagKind
  addHostIDs: [ID!]
  removeHostIDs: [ID!]
  clearHosts: Boolean
}
"""
UpdateTomeInput is used for update Tome object.
Input was generated by ent.
"""
input UpdateTomeInput {
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time
  """Name of the tome"""
  name: String
  """Information about the tome"""
  description: String
  """Name of the author who created the tome."""
  author: String
  """Information about the tomes support model."""
  supportModel: TomeSupportModel
  """MITRE ATT&CK tactic provided by the tome."""
  tactic: TomeTactic
  """JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter."""
  paramDefs: String
  clearParamDefs: Boolean
  """Eldritch script that will be executed when the tome is run"""
  eldritch: String
  addFileIDs: [ID!]
  removeFileIDs: [ID!]
  clearFiles: Boolean
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  """The name displayed for the user"""
  name: String
  """URL to the user's profile photo."""
  photoURL: String
  """True if the user is active and able to authenticate"""
  isActivated: Boolean
  """True if the user is an Admin"""
  isAdmin: Boolean
  addTomeIDs: [ID!]
  removeTomeIDs: [ID!]
  clearTomes: Boolean
}
type User implements Node {
  id: ID!
  """The name displayed for the user"""
  name: String!
  """URL to the user's profile photo."""
  photoURL: String!
  """True if the user is active and able to authenticate"""
  isActivated: Boolean!
  """True if the user is an Admin"""
  isAdmin: Boolean!
  """Tomes uploaded by the user."""
  tomes: [Tome!]
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """photo_url field predicates"""
  photoURL: String
  photoURLNEQ: String
  photoURLIn: [String!]
  photoURLNotIn: [String!]
  photoURLGT: String
  photoURLGTE: String
  photoURLLT: String
  photoURLLTE: String
  photoURLContains: String
  photoURLHasPrefix: String
  photoURLHasSuffix: String
  photoURLEqualFold: String
  photoURLContainsFold: String
  """is_activated field predicates"""
  isActivated: Boolean
  isActivatedNEQ: Boolean
  """is_admin field predicates"""
  isAdmin: Boolean
  isAdminNEQ: Boolean
  """tomes edge predicates"""
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphql", Input: `scalar Time
scalar Uint64
`, BuiltIn: false},
	{Name: "../schema/query.graphql", Input: `extend type Query {
  files(where: FileWhereInput): [File!]! @requireRole(role: USER)
  quests(where: QuestWhereInput): [Quest!]! @requireRole(role: USER)
  tasks(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tasks returned from the connection."""
    orderBy: [TaskOrder!]

    """Filtering options for Tasks returned from the connection."""
    where: TaskWhereInput
  ): TaskConnection! @requireRole(role: USER)
  beacons(where: BeaconWhereInput): [Beacon!]! @requireRole(role: USER)
  hosts(where: HostWhereInput): [Host!]! @requireRole(role: USER)
  tags(where: TagWhereInput): [Tag!]! @requireRole(role: USER)
  tomes(where: TomeWhereInput): [Tome!]! @requireRole(role: USER)
  users(where: UserWhereInput): [User!]! @requireRole(role: USER)
  me: User!
}
`, BuiltIn: false},
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
    ###
    # Quest
    ###
    createQuest(beaconIDs: [ID!]!, input: CreateQuestInput!): Quest @requireRole(role: USER)

    ###
    # Beacon
    ###
    updateBeacon(beaconID: ID!, input: UpdateBeaconInput!): Beacon! @requireRole(role: USER)

    ###
    # Host
    ###
    updateHost(hostID: ID!, input: UpdateHostInput!): Host! @requireRole(role: USER)

    ###
    # Tag
    ###
    createTag(input: CreateTagInput!): Tag! @requireRole(role: ADMIN)
    updateTag(tagID: ID!, input: UpdateTagInput!): Tag! @requireRole(role: USER)

    ###
    # Tome
    ###
    createTome(input: CreateTomeInput!,): Tome! @requireRole(role: USER)
    updateTome(tomeID: ID!, input: UpdateTomeInput!,): Tome! @requireRole(role: ADMIN)
    deleteTome(tomeID: ID!): ID! @requireRole(role: ADMIN)

    ###
    # User
    ###
    updateUser(userID: ID!, input: UpdateUserInput!): User @requireRole(role: ADMIN)
}
`, BuiltIn: false},
	{Name: "../schema/inputs.graphql", Input: `input ClaimTasksInput {
  """The identity the beacon is authenticated as (e.g. 'root')"""
  principal: String!

  """The hostname of the system the beacon is running on."""
  hostname: String!

  """The platform the agent is operating on."""
  hostPlatform: HostPlatform!

  """The IP address of the hosts primary interface (if available)."""
  hostPrimaryIP: String

  """Unique identifier of the beacon, each running instance will be different."""
  beaconIdentifier: String!

  """Unique identifier of the underlying host system the beacon is running on."""
  hostIdentifier: String!

  """Name of the agent program the beacon is running as (e.g. 'imix')"""
  agentIdentifier: String!
}

input SubmitTaskResultInput {
  """ID of the task to submit results for."""
  taskID: ID!

  """Timestamp of when the task execution began. Format as RFC3339Nano."""
  execStartedAt: Time!

  """Timestamp of when the task execution finished (set only if it has completed). Format as RFC3339Nano."""
  execFinishedAt: Time

  """
  Output captured as the result of task execution.
  Submitting multiple outputs will result in appending new output to the previous output.
  """
  output: String!

  """Error message captured as the result of task execution failure."""
  error: String
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
