// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"realm.pub/tavern/internal/ent"
	"realm.pub/tavern/internal/graphql/models"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	HostFile() HostFileResolver
	Mutation() MutationResolver
	Query() QueryResolver
	ShellTask() ShellTaskResolver
	ShellTaskWhereInput() ShellTaskWhereInputResolver
}

type DirectiveRoot struct {
	RequireRole func(ctx context.Context, obj any, next graphql.Resolver, role models.Role) (res any, err error)
}

type ComplexityRoot struct {
	Asset struct {
		CreatedAt      func(childComplexity int) int
		Creator        func(childComplexity int) int
		Hash           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Links          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.LinkOrder, where *ent.LinkWhereInput) int
		Name           func(childComplexity int) int
		Size           func(childComplexity int) int
		Tomes          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TomeOrder, where *ent.TomeWhereInput) int
	}

	AssetConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AssetEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Beacon struct {
		AgentIdentifier func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Host            func(childComplexity int) int
		ID              func(childComplexity int) int
		Identifier      func(childComplexity int) int
		Interval        func(childComplexity int) int
		LastModifiedAt  func(childComplexity int) int
		LastSeenAt      func(childComplexity int) int
		Name            func(childComplexity int) int
		NextSeenAt      func(childComplexity int) int
		Principal       func(childComplexity int) int
		Shells          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellOrder, where *ent.ShellWhereInput) int
		Tasks           func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Transport       func(childComplexity int) int
	}

	BeaconConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BeaconEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BuildTask struct {
		Artifact       func(childComplexity int) int
		ArtifactPath   func(childComplexity int) int
		BuildImage     func(childComplexity int) int
		BuildScript    func(childComplexity int) int
		Builder        func(childComplexity int) int
		ClaimedAt      func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Error          func(childComplexity int) int
		ErrorSize      func(childComplexity int) int
		ExitCode       func(childComplexity int) int
		FinishedAt     func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Output         func(childComplexity int) int
		OutputSize     func(childComplexity int) int
		StartedAt      func(childComplexity int) int
		TargetFormat   func(childComplexity int) int
		TargetOs       func(childComplexity int) int
		Transports     func(childComplexity int) int
	}

	BuildTaskConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BuildTaskEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BuildTaskTransport struct {
		Extra    func(childComplexity int) int
		Interval func(childComplexity int) int
		Type     func(childComplexity int) int
		URI      func(childComplexity int) int
	}

	Builder struct {
		BuildTasks       func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.BuildTaskOrder, where *ent.BuildTaskWhereInput) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		Identifier       func(childComplexity int) int
		LastModifiedAt   func(childComplexity int) int
		LastSeenAt       func(childComplexity int) int
		SupportedTargets func(childComplexity int) int
		Upstream         func(childComplexity int) int
	}

	BuilderConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BuilderEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Host struct {
		Beacons        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.BeaconOrder, where *ent.BeaconWhereInput) int
		CreatedAt      func(childComplexity int) int
		Credentials    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostCredentialOrder, where *ent.HostCredentialWhereInput) int
		ExternalIP     func(childComplexity int) int
		Files          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostFileOrder, where *ent.HostFileWhereInput) int
		ID             func(childComplexity int) int
		Identifier     func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		LastSeenAt     func(childComplexity int) int
		Name           func(childComplexity int) int
		NextSeenAt     func(childComplexity int) int
		Platform       func(childComplexity int) int
		PrimaryIP      func(childComplexity int) int
		Processes      func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostProcessOrder, where *ent.HostProcessWhereInput) int
		Screenshots    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ScreenshotOrder, where *ent.ScreenshotWhereInput) int
		Tags           func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TagOrder, where *ent.TagWhereInput) int
	}

	HostConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HostCredential struct {
		CreatedAt      func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		Kind           func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Principal      func(childComplexity int) int
		Secret         func(childComplexity int) int
		ShellTask      func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	HostCredentialConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HostCredentialEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	HostEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	HostFile struct {
		CreatedAt      func(childComplexity int) int
		Group          func(childComplexity int) int
		Hash           func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Owner          func(childComplexity int) int
		Path           func(childComplexity int) int
		Permissions    func(childComplexity int) int
		Preview        func(childComplexity int) int
		PreviewType    func(childComplexity int) int
		ShellTask      func(childComplexity int) int
		Size           func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	HostFileConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HostFileEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	HostProcess struct {
		Cmd            func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Cwd            func(childComplexity int) int
		Env            func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Pid            func(childComplexity int) int
		Ppid           func(childComplexity int) int
		Principal      func(childComplexity int) int
		ShellTask      func(childComplexity int) int
		Status         func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	HostProcessConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HostProcessEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Link struct {
		Asset          func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Creator        func(childComplexity int) int
		DownloadLimit  func(childComplexity int) int
		Downloads      func(childComplexity int) int
		ExpiresAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Path           func(childComplexity int) int
	}

	LinkConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LinkEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		CreateBuildTask  func(childComplexity int, input models.CreateBuildTaskInput) int
		CreateCredential func(childComplexity int, input ent.CreateHostCredentialInput) int
		CreateLink       func(childComplexity int, input ent.CreateLinkInput) int
		CreateQuest      func(childComplexity int, beaconIDs []int, input ent.CreateQuestInput) int
		CreateRepository func(childComplexity int, input ent.CreateRepositoryInput) int
		CreateShell      func(childComplexity int, input ent.CreateShellInput) int
		CreateTag        func(childComplexity int, input ent.CreateTagInput) int
		CreateTome       func(childComplexity int, input ent.CreateTomeInput) int
		DeleteBuilder    func(childComplexity int, builderID int) int
		DeleteTome       func(childComplexity int, tomeID int) int
		DisableLink      func(childComplexity int, linkID int) int
		DropAllData      func(childComplexity int) int
		ImportRepository func(childComplexity int, repoID int, input *models.ImportRepositoryInput) int
		RegisterBuilder  func(childComplexity int, input ent.CreateBuilderInput) int
		UpdateBeacon     func(childComplexity int, beaconID int, input ent.UpdateBeaconInput) int
		UpdateHost       func(childComplexity int, hostID int, input ent.UpdateHostInput) int
		UpdateLink       func(childComplexity int, linkID int, input ent.UpdateLinkInput) int
		UpdateTag        func(childComplexity int, tagID int, input ent.UpdateTagInput) int
		UpdateTome       func(childComplexity int, tomeID int, input ent.UpdateTomeInput) int
		UpdateUser       func(childComplexity int, userID int, input ent.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Portal struct {
		ActiveUsers    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
		Beacon         func(childComplexity int) int
		ClosedAt       func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Owner          func(childComplexity int) int
		ShellTask      func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	PortalConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PortalEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		Assets       func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.AssetOrder, where *ent.AssetWhereInput) int
		Beacons      func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.BeaconOrder, where *ent.BeaconWhereInput) int
		BuildTasks   func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.BuildTaskOrder, where *ent.BuildTaskWhereInput) int
		Builders     func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.BuilderOrder, where *ent.BuilderWhereInput) int
		Hosts        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostOrder, where *ent.HostWhereInput) int
		Me           func(childComplexity int) int
		Node         func(childComplexity int, id int) int
		Nodes        func(childComplexity int, ids []int) int
		Portals      func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.PortalOrder, where *ent.PortalWhereInput) int
		Quests       func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.QuestOrder, where *ent.QuestWhereInput) int
		Repositories func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.RepositoryOrder, where *ent.RepositoryWhereInput) int
		Shells       func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellOrder, where *ent.ShellWhereInput) int
		Tags         func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TagOrder, where *ent.TagWhereInput) int
		Tasks        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Tomes        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TomeOrder, where *ent.TomeWhereInput) int
		Users        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
	}

	Quest struct {
		Bundle              func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		Creator             func(childComplexity int) int
		EldritchAtCreation  func(childComplexity int) int
		ID                  func(childComplexity int) int
		LastModifiedAt      func(childComplexity int) int
		Name                func(childComplexity int) int
		ParamDefsAtCreation func(childComplexity int) int
		Parameters          func(childComplexity int) int
		Tasks               func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Tome                func(childComplexity int) int
	}

	QuestConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	QuestEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RegisterBuilderOutput struct {
		Builder  func(childComplexity int) int
		Config   func(childComplexity int) int
		MtlsCert func(childComplexity int) int
	}

	Repository struct {
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastImportedAt func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Owner          func(childComplexity int) int
		PublicKey      func(childComplexity int) int
		Tomes          func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TomeOrder, where *ent.TomeWhereInput) int
		URL            func(childComplexity int) int
	}

	RepositoryConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	RepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Screenshot struct {
		CreatedAt      func(childComplexity int) int
		Hash           func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		ShellTask      func(childComplexity int) int
		Size           func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	ScreenshotConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ScreenshotEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Shell struct {
		ActiveUsers    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
		Beacon         func(childComplexity int) int
		ClosedAt       func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Owner          func(childComplexity int) int
		Portals        func(childComplexity int) int
		ShellTasks     func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellTaskOrder, where *ent.ShellTaskWhereInput) int
		Task           func(childComplexity int) int
	}

	ShellConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ShellEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ShellTask struct {
		ClaimedAt           func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		Creator             func(childComplexity int) int
		Error               func(childComplexity int) int
		ExecFinishedAt      func(childComplexity int) int
		ExecStartedAt       func(childComplexity int) int
		ID                  func(childComplexity int) int
		Input               func(childComplexity int) int
		LastModifiedAt      func(childComplexity int) int
		Output              func(childComplexity int) int
		ReportedCredentials func(childComplexity int) int
		ReportedFiles       func(childComplexity int) int
		ReportedProcesses   func(childComplexity int) int
		Screenshots         func(childComplexity int) int
		SequenceID          func(childComplexity int) int
		Shell               func(childComplexity int) int
		StreamID            func(childComplexity int) int
	}

	ShellTaskConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ShellTaskEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Tag struct {
		Hosts func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostOrder, where *ent.HostWhereInput) int
		ID    func(childComplexity int) int
		Kind  func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	TagConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TagEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Task struct {
		Beacon              func(childComplexity int) int
		ClaimedAt           func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		Error               func(childComplexity int) int
		ExecFinishedAt      func(childComplexity int) int
		ExecStartedAt       func(childComplexity int) int
		ID                  func(childComplexity int) int
		LastModifiedAt      func(childComplexity int) int
		Output              func(childComplexity int) int
		OutputSize          func(childComplexity int) int
		Quest               func(childComplexity int) int
		ReportedCredentials func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostCredentialOrder, where *ent.HostCredentialWhereInput) int
		ReportedFiles       func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostFileOrder, where *ent.HostFileWhereInput) int
		ReportedProcesses   func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostProcessOrder, where *ent.HostProcessWhereInput) int
		Screenshots         func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ScreenshotOrder, where *ent.ScreenshotWhereInput) int
		Shells              func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellOrder, where *ent.ShellWhereInput) int
	}

	TaskConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TaskEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Tome struct {
		Assets                 func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.AssetOrder, where *ent.AssetWhereInput) int
		Author                 func(childComplexity int) int
		CreatedAt              func(childComplexity int) int
		Description            func(childComplexity int) int
		Eldritch               func(childComplexity int) int
		ID                     func(childComplexity int) int
		LastModifiedAt         func(childComplexity int) int
		Name                   func(childComplexity int) int
		ParamDefs              func(childComplexity int) int
		Repository             func(childComplexity int) int
		RunOnFirstHostCallback func(childComplexity int) int
		RunOnNewBeaconCallback func(childComplexity int) int
		RunOnSchedule          func(childComplexity int) int
		ScheduledHosts         func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.HostOrder, where *ent.HostWhereInput) int
		SupportModel           func(childComplexity int) int
		Tactic                 func(childComplexity int) int
		Uploader               func(childComplexity int) int
	}

	TomeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TomeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	User struct {
		ActiveShells func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.ShellOrder, where *ent.ShellWhereInput) int
		ID           func(childComplexity int) int
		IsActivated  func(childComplexity int) int
		IsAdmin      func(childComplexity int) int
		Name         func(childComplexity int) int
		PhotoURL     func(childComplexity int) int
		Tomes        func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TomeOrder, where *ent.TomeWhereInput) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Asset.createdAt":
		if e.complexity.Asset.CreatedAt == nil {
			break
		}

		return e.complexity.Asset.CreatedAt(childComplexity), true

	case "Asset.creator":
		if e.complexity.Asset.Creator == nil {
			break
		}

		return e.complexity.Asset.Creator(childComplexity), true

	case "Asset.hash":
		if e.complexity.Asset.Hash == nil {
			break
		}

		return e.complexity.Asset.Hash(childComplexity), true

	case "Asset.id":
		if e.complexity.Asset.ID == nil {
			break
		}

		return e.complexity.Asset.ID(childComplexity), true

	case "Asset.lastModifiedAt":
		if e.complexity.Asset.LastModifiedAt == nil {
			break
		}

		return e.complexity.Asset.LastModifiedAt(childComplexity), true

	case "Asset.links":
		if e.complexity.Asset.Links == nil {
			break
		}

		args, err := ec.field_Asset_links_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.Links(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.LinkOrder), args["where"].(*ent.LinkWhereInput)), true

	case "Asset.name":
		if e.complexity.Asset.Name == nil {
			break
		}

		return e.complexity.Asset.Name(childComplexity), true

	case "Asset.size":
		if e.complexity.Asset.Size == nil {
			break
		}

		return e.complexity.Asset.Size(childComplexity), true

	case "Asset.tomes":
		if e.complexity.Asset.Tomes == nil {
			break
		}

		args, err := ec.field_Asset_tomes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.Tomes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TomeOrder), args["where"].(*ent.TomeWhereInput)), true

	case "AssetConnection.edges":
		if e.complexity.AssetConnection.Edges == nil {
			break
		}

		return e.complexity.AssetConnection.Edges(childComplexity), true

	case "AssetConnection.pageInfo":
		if e.complexity.AssetConnection.PageInfo == nil {
			break
		}

		return e.complexity.AssetConnection.PageInfo(childComplexity), true

	case "AssetConnection.totalCount":
		if e.complexity.AssetConnection.TotalCount == nil {
			break
		}

		return e.complexity.AssetConnection.TotalCount(childComplexity), true

	case "AssetEdge.cursor":
		if e.complexity.AssetEdge.Cursor == nil {
			break
		}

		return e.complexity.AssetEdge.Cursor(childComplexity), true

	case "AssetEdge.node":
		if e.complexity.AssetEdge.Node == nil {
			break
		}

		return e.complexity.AssetEdge.Node(childComplexity), true

	case "Beacon.agentIdentifier":
		if e.complexity.Beacon.AgentIdentifier == nil {
			break
		}

		return e.complexity.Beacon.AgentIdentifier(childComplexity), true

	case "Beacon.createdAt":
		if e.complexity.Beacon.CreatedAt == nil {
			break
		}

		return e.complexity.Beacon.CreatedAt(childComplexity), true

	case "Beacon.host":
		if e.complexity.Beacon.Host == nil {
			break
		}

		return e.complexity.Beacon.Host(childComplexity), true

	case "Beacon.id":
		if e.complexity.Beacon.ID == nil {
			break
		}

		return e.complexity.Beacon.ID(childComplexity), true

	case "Beacon.identifier":
		if e.complexity.Beacon.Identifier == nil {
			break
		}

		return e.complexity.Beacon.Identifier(childComplexity), true

	case "Beacon.interval":
		if e.complexity.Beacon.Interval == nil {
			break
		}

		return e.complexity.Beacon.Interval(childComplexity), true

	case "Beacon.lastModifiedAt":
		if e.complexity.Beacon.LastModifiedAt == nil {
			break
		}

		return e.complexity.Beacon.LastModifiedAt(childComplexity), true

	case "Beacon.lastSeenAt":
		if e.complexity.Beacon.LastSeenAt == nil {
			break
		}

		return e.complexity.Beacon.LastSeenAt(childComplexity), true

	case "Beacon.name":
		if e.complexity.Beacon.Name == nil {
			break
		}

		return e.complexity.Beacon.Name(childComplexity), true

	case "Beacon.nextSeenAt":
		if e.complexity.Beacon.NextSeenAt == nil {
			break
		}

		return e.complexity.Beacon.NextSeenAt(childComplexity), true

	case "Beacon.principal":
		if e.complexity.Beacon.Principal == nil {
			break
		}

		return e.complexity.Beacon.Principal(childComplexity), true

	case "Beacon.shells":
		if e.complexity.Beacon.Shells == nil {
			break
		}

		args, err := ec.field_Beacon_shells_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Beacon.Shells(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellOrder), args["where"].(*ent.ShellWhereInput)), true

	case "Beacon.tasks":
		if e.complexity.Beacon.Tasks == nil {
			break
		}

		args, err := ec.field_Beacon_tasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Beacon.Tasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Beacon.transport":
		if e.complexity.Beacon.Transport == nil {
			break
		}

		return e.complexity.Beacon.Transport(childComplexity), true

	case "BeaconConnection.edges":
		if e.complexity.BeaconConnection.Edges == nil {
			break
		}

		return e.complexity.BeaconConnection.Edges(childComplexity), true

	case "BeaconConnection.pageInfo":
		if e.complexity.BeaconConnection.PageInfo == nil {
			break
		}

		return e.complexity.BeaconConnection.PageInfo(childComplexity), true

	case "BeaconConnection.totalCount":
		if e.complexity.BeaconConnection.TotalCount == nil {
			break
		}

		return e.complexity.BeaconConnection.TotalCount(childComplexity), true

	case "BeaconEdge.cursor":
		if e.complexity.BeaconEdge.Cursor == nil {
			break
		}

		return e.complexity.BeaconEdge.Cursor(childComplexity), true

	case "BeaconEdge.node":
		if e.complexity.BeaconEdge.Node == nil {
			break
		}

		return e.complexity.BeaconEdge.Node(childComplexity), true

	case "BuildTask.artifact":
		if e.complexity.BuildTask.Artifact == nil {
			break
		}

		return e.complexity.BuildTask.Artifact(childComplexity), true

	case "BuildTask.artifactPath":
		if e.complexity.BuildTask.ArtifactPath == nil {
			break
		}

		return e.complexity.BuildTask.ArtifactPath(childComplexity), true

	case "BuildTask.buildImage":
		if e.complexity.BuildTask.BuildImage == nil {
			break
		}

		return e.complexity.BuildTask.BuildImage(childComplexity), true

	case "BuildTask.buildScript":
		if e.complexity.BuildTask.BuildScript == nil {
			break
		}

		return e.complexity.BuildTask.BuildScript(childComplexity), true

	case "BuildTask.builder":
		if e.complexity.BuildTask.Builder == nil {
			break
		}

		return e.complexity.BuildTask.Builder(childComplexity), true

	case "BuildTask.claimedAt":
		if e.complexity.BuildTask.ClaimedAt == nil {
			break
		}

		return e.complexity.BuildTask.ClaimedAt(childComplexity), true

	case "BuildTask.createdAt":
		if e.complexity.BuildTask.CreatedAt == nil {
			break
		}

		return e.complexity.BuildTask.CreatedAt(childComplexity), true

	case "BuildTask.error":
		if e.complexity.BuildTask.Error == nil {
			break
		}

		return e.complexity.BuildTask.Error(childComplexity), true

	case "BuildTask.errorSize":
		if e.complexity.BuildTask.ErrorSize == nil {
			break
		}

		return e.complexity.BuildTask.ErrorSize(childComplexity), true

	case "BuildTask.exitCode":
		if e.complexity.BuildTask.ExitCode == nil {
			break
		}

		return e.complexity.BuildTask.ExitCode(childComplexity), true

	case "BuildTask.finishedAt":
		if e.complexity.BuildTask.FinishedAt == nil {
			break
		}

		return e.complexity.BuildTask.FinishedAt(childComplexity), true

	case "BuildTask.id":
		if e.complexity.BuildTask.ID == nil {
			break
		}

		return e.complexity.BuildTask.ID(childComplexity), true

	case "BuildTask.lastModifiedAt":
		if e.complexity.BuildTask.LastModifiedAt == nil {
			break
		}

		return e.complexity.BuildTask.LastModifiedAt(childComplexity), true

	case "BuildTask.output":
		if e.complexity.BuildTask.Output == nil {
			break
		}

		return e.complexity.BuildTask.Output(childComplexity), true

	case "BuildTask.outputSize":
		if e.complexity.BuildTask.OutputSize == nil {
			break
		}

		return e.complexity.BuildTask.OutputSize(childComplexity), true

	case "BuildTask.startedAt":
		if e.complexity.BuildTask.StartedAt == nil {
			break
		}

		return e.complexity.BuildTask.StartedAt(childComplexity), true

	case "BuildTask.targetFormat":
		if e.complexity.BuildTask.TargetFormat == nil {
			break
		}

		return e.complexity.BuildTask.TargetFormat(childComplexity), true

	case "BuildTask.targetOs":
		if e.complexity.BuildTask.TargetOs == nil {
			break
		}

		return e.complexity.BuildTask.TargetOs(childComplexity), true

	case "BuildTask.transports":
		if e.complexity.BuildTask.Transports == nil {
			break
		}

		return e.complexity.BuildTask.Transports(childComplexity), true

	case "BuildTaskConnection.edges":
		if e.complexity.BuildTaskConnection.Edges == nil {
			break
		}

		return e.complexity.BuildTaskConnection.Edges(childComplexity), true

	case "BuildTaskConnection.pageInfo":
		if e.complexity.BuildTaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.BuildTaskConnection.PageInfo(childComplexity), true

	case "BuildTaskConnection.totalCount":
		if e.complexity.BuildTaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.BuildTaskConnection.TotalCount(childComplexity), true

	case "BuildTaskEdge.cursor":
		if e.complexity.BuildTaskEdge.Cursor == nil {
			break
		}

		return e.complexity.BuildTaskEdge.Cursor(childComplexity), true

	case "BuildTaskEdge.node":
		if e.complexity.BuildTaskEdge.Node == nil {
			break
		}

		return e.complexity.BuildTaskEdge.Node(childComplexity), true

	case "BuildTaskTransport.extra":
		if e.complexity.BuildTaskTransport.Extra == nil {
			break
		}

		return e.complexity.BuildTaskTransport.Extra(childComplexity), true

	case "BuildTaskTransport.interval":
		if e.complexity.BuildTaskTransport.Interval == nil {
			break
		}

		return e.complexity.BuildTaskTransport.Interval(childComplexity), true

	case "BuildTaskTransport.type":
		if e.complexity.BuildTaskTransport.Type == nil {
			break
		}

		return e.complexity.BuildTaskTransport.Type(childComplexity), true

	case "BuildTaskTransport.uri":
		if e.complexity.BuildTaskTransport.URI == nil {
			break
		}

		return e.complexity.BuildTaskTransport.URI(childComplexity), true

	case "Builder.buildTasks":
		if e.complexity.Builder.BuildTasks == nil {
			break
		}

		args, err := ec.field_Builder_buildTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Builder.BuildTasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.BuildTaskOrder), args["where"].(*ent.BuildTaskWhereInput)), true

	case "Builder.createdAt":
		if e.complexity.Builder.CreatedAt == nil {
			break
		}

		return e.complexity.Builder.CreatedAt(childComplexity), true

	case "Builder.id":
		if e.complexity.Builder.ID == nil {
			break
		}

		return e.complexity.Builder.ID(childComplexity), true

	case "Builder.identifier":
		if e.complexity.Builder.Identifier == nil {
			break
		}

		return e.complexity.Builder.Identifier(childComplexity), true

	case "Builder.lastModifiedAt":
		if e.complexity.Builder.LastModifiedAt == nil {
			break
		}

		return e.complexity.Builder.LastModifiedAt(childComplexity), true

	case "Builder.lastSeenAt":
		if e.complexity.Builder.LastSeenAt == nil {
			break
		}

		return e.complexity.Builder.LastSeenAt(childComplexity), true

	case "Builder.supportedTargets":
		if e.complexity.Builder.SupportedTargets == nil {
			break
		}

		return e.complexity.Builder.SupportedTargets(childComplexity), true

	case "Builder.upstream":
		if e.complexity.Builder.Upstream == nil {
			break
		}

		return e.complexity.Builder.Upstream(childComplexity), true

	case "BuilderConnection.edges":
		if e.complexity.BuilderConnection.Edges == nil {
			break
		}

		return e.complexity.BuilderConnection.Edges(childComplexity), true

	case "BuilderConnection.pageInfo":
		if e.complexity.BuilderConnection.PageInfo == nil {
			break
		}

		return e.complexity.BuilderConnection.PageInfo(childComplexity), true

	case "BuilderConnection.totalCount":
		if e.complexity.BuilderConnection.TotalCount == nil {
			break
		}

		return e.complexity.BuilderConnection.TotalCount(childComplexity), true

	case "BuilderEdge.cursor":
		if e.complexity.BuilderEdge.Cursor == nil {
			break
		}

		return e.complexity.BuilderEdge.Cursor(childComplexity), true

	case "BuilderEdge.node":
		if e.complexity.BuilderEdge.Node == nil {
			break
		}

		return e.complexity.BuilderEdge.Node(childComplexity), true

	case "Host.beacons":
		if e.complexity.Host.Beacons == nil {
			break
		}

		args, err := ec.field_Host_beacons_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Beacons(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.BeaconOrder), args["where"].(*ent.BeaconWhereInput)), true

	case "Host.createdAt":
		if e.complexity.Host.CreatedAt == nil {
			break
		}

		return e.complexity.Host.CreatedAt(childComplexity), true

	case "Host.credentials":
		if e.complexity.Host.Credentials == nil {
			break
		}

		args, err := ec.field_Host_credentials_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Credentials(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostCredentialOrder), args["where"].(*ent.HostCredentialWhereInput)), true

	case "Host.externalIP":
		if e.complexity.Host.ExternalIP == nil {
			break
		}

		return e.complexity.Host.ExternalIP(childComplexity), true

	case "Host.files":
		if e.complexity.Host.Files == nil {
			break
		}

		args, err := ec.field_Host_files_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Files(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostFileOrder), args["where"].(*ent.HostFileWhereInput)), true

	case "Host.id":
		if e.complexity.Host.ID == nil {
			break
		}

		return e.complexity.Host.ID(childComplexity), true

	case "Host.identifier":
		if e.complexity.Host.Identifier == nil {
			break
		}

		return e.complexity.Host.Identifier(childComplexity), true

	case "Host.lastModifiedAt":
		if e.complexity.Host.LastModifiedAt == nil {
			break
		}

		return e.complexity.Host.LastModifiedAt(childComplexity), true

	case "Host.lastSeenAt":
		if e.complexity.Host.LastSeenAt == nil {
			break
		}

		return e.complexity.Host.LastSeenAt(childComplexity), true

	case "Host.name":
		if e.complexity.Host.Name == nil {
			break
		}

		return e.complexity.Host.Name(childComplexity), true

	case "Host.nextSeenAt":
		if e.complexity.Host.NextSeenAt == nil {
			break
		}

		return e.complexity.Host.NextSeenAt(childComplexity), true

	case "Host.platform":
		if e.complexity.Host.Platform == nil {
			break
		}

		return e.complexity.Host.Platform(childComplexity), true

	case "Host.primaryIP":
		if e.complexity.Host.PrimaryIP == nil {
			break
		}

		return e.complexity.Host.PrimaryIP(childComplexity), true

	case "Host.processes":
		if e.complexity.Host.Processes == nil {
			break
		}

		args, err := ec.field_Host_processes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Processes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostProcessOrder), args["where"].(*ent.HostProcessWhereInput)), true

	case "Host.screenshots":
		if e.complexity.Host.Screenshots == nil {
			break
		}

		args, err := ec.field_Host_screenshots_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Screenshots(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ScreenshotOrder), args["where"].(*ent.ScreenshotWhereInput)), true

	case "Host.tags":
		if e.complexity.Host.Tags == nil {
			break
		}

		args, err := ec.field_Host_tags_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Tags(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TagOrder), args["where"].(*ent.TagWhereInput)), true

	case "HostConnection.edges":
		if e.complexity.HostConnection.Edges == nil {
			break
		}

		return e.complexity.HostConnection.Edges(childComplexity), true

	case "HostConnection.pageInfo":
		if e.complexity.HostConnection.PageInfo == nil {
			break
		}

		return e.complexity.HostConnection.PageInfo(childComplexity), true

	case "HostConnection.totalCount":
		if e.complexity.HostConnection.TotalCount == nil {
			break
		}

		return e.complexity.HostConnection.TotalCount(childComplexity), true

	case "HostCredential.createdAt":
		if e.complexity.HostCredential.CreatedAt == nil {
			break
		}

		return e.complexity.HostCredential.CreatedAt(childComplexity), true

	case "HostCredential.host":
		if e.complexity.HostCredential.Host == nil {
			break
		}

		return e.complexity.HostCredential.Host(childComplexity), true

	case "HostCredential.id":
		if e.complexity.HostCredential.ID == nil {
			break
		}

		return e.complexity.HostCredential.ID(childComplexity), true

	case "HostCredential.kind":
		if e.complexity.HostCredential.Kind == nil {
			break
		}

		return e.complexity.HostCredential.Kind(childComplexity), true

	case "HostCredential.lastModifiedAt":
		if e.complexity.HostCredential.LastModifiedAt == nil {
			break
		}

		return e.complexity.HostCredential.LastModifiedAt(childComplexity), true

	case "HostCredential.principal":
		if e.complexity.HostCredential.Principal == nil {
			break
		}

		return e.complexity.HostCredential.Principal(childComplexity), true

	case "HostCredential.secret":
		if e.complexity.HostCredential.Secret == nil {
			break
		}

		return e.complexity.HostCredential.Secret(childComplexity), true

	case "HostCredential.shellTask":
		if e.complexity.HostCredential.ShellTask == nil {
			break
		}

		return e.complexity.HostCredential.ShellTask(childComplexity), true

	case "HostCredential.task":
		if e.complexity.HostCredential.Task == nil {
			break
		}

		return e.complexity.HostCredential.Task(childComplexity), true

	case "HostCredentialConnection.edges":
		if e.complexity.HostCredentialConnection.Edges == nil {
			break
		}

		return e.complexity.HostCredentialConnection.Edges(childComplexity), true

	case "HostCredentialConnection.pageInfo":
		if e.complexity.HostCredentialConnection.PageInfo == nil {
			break
		}

		return e.complexity.HostCredentialConnection.PageInfo(childComplexity), true

	case "HostCredentialConnection.totalCount":
		if e.complexity.HostCredentialConnection.TotalCount == nil {
			break
		}

		return e.complexity.HostCredentialConnection.TotalCount(childComplexity), true

	case "HostCredentialEdge.cursor":
		if e.complexity.HostCredentialEdge.Cursor == nil {
			break
		}

		return e.complexity.HostCredentialEdge.Cursor(childComplexity), true

	case "HostCredentialEdge.node":
		if e.complexity.HostCredentialEdge.Node == nil {
			break
		}

		return e.complexity.HostCredentialEdge.Node(childComplexity), true

	case "HostEdge.cursor":
		if e.complexity.HostEdge.Cursor == nil {
			break
		}

		return e.complexity.HostEdge.Cursor(childComplexity), true

	case "HostEdge.node":
		if e.complexity.HostEdge.Node == nil {
			break
		}

		return e.complexity.HostEdge.Node(childComplexity), true

	case "HostFile.createdAt":
		if e.complexity.HostFile.CreatedAt == nil {
			break
		}

		return e.complexity.HostFile.CreatedAt(childComplexity), true

	case "HostFile.group":
		if e.complexity.HostFile.Group == nil {
			break
		}

		return e.complexity.HostFile.Group(childComplexity), true

	case "HostFile.hash":
		if e.complexity.HostFile.Hash == nil {
			break
		}

		return e.complexity.HostFile.Hash(childComplexity), true

	case "HostFile.host":
		if e.complexity.HostFile.Host == nil {
			break
		}

		return e.complexity.HostFile.Host(childComplexity), true

	case "HostFile.id":
		if e.complexity.HostFile.ID == nil {
			break
		}

		return e.complexity.HostFile.ID(childComplexity), true

	case "HostFile.lastModifiedAt":
		if e.complexity.HostFile.LastModifiedAt == nil {
			break
		}

		return e.complexity.HostFile.LastModifiedAt(childComplexity), true

	case "HostFile.owner":
		if e.complexity.HostFile.Owner == nil {
			break
		}

		return e.complexity.HostFile.Owner(childComplexity), true

	case "HostFile.path":
		if e.complexity.HostFile.Path == nil {
			break
		}

		return e.complexity.HostFile.Path(childComplexity), true

	case "HostFile.permissions":
		if e.complexity.HostFile.Permissions == nil {
			break
		}

		return e.complexity.HostFile.Permissions(childComplexity), true

	case "HostFile.preview":
		if e.complexity.HostFile.Preview == nil {
			break
		}

		return e.complexity.HostFile.Preview(childComplexity), true

	case "HostFile.previewType":
		if e.complexity.HostFile.PreviewType == nil {
			break
		}

		return e.complexity.HostFile.PreviewType(childComplexity), true

	case "HostFile.shellTask":
		if e.complexity.HostFile.ShellTask == nil {
			break
		}

		return e.complexity.HostFile.ShellTask(childComplexity), true

	case "HostFile.size":
		if e.complexity.HostFile.Size == nil {
			break
		}

		return e.complexity.HostFile.Size(childComplexity), true

	case "HostFile.task":
		if e.complexity.HostFile.Task == nil {
			break
		}

		return e.complexity.HostFile.Task(childComplexity), true

	case "HostFileConnection.edges":
		if e.complexity.HostFileConnection.Edges == nil {
			break
		}

		return e.complexity.HostFileConnection.Edges(childComplexity), true

	case "HostFileConnection.pageInfo":
		if e.complexity.HostFileConnection.PageInfo == nil {
			break
		}

		return e.complexity.HostFileConnection.PageInfo(childComplexity), true

	case "HostFileConnection.totalCount":
		if e.complexity.HostFileConnection.TotalCount == nil {
			break
		}

		return e.complexity.HostFileConnection.TotalCount(childComplexity), true

	case "HostFileEdge.cursor":
		if e.complexity.HostFileEdge.Cursor == nil {
			break
		}

		return e.complexity.HostFileEdge.Cursor(childComplexity), true

	case "HostFileEdge.node":
		if e.complexity.HostFileEdge.Node == nil {
			break
		}

		return e.complexity.HostFileEdge.Node(childComplexity), true

	case "HostProcess.cmd":
		if e.complexity.HostProcess.Cmd == nil {
			break
		}

		return e.complexity.HostProcess.Cmd(childComplexity), true

	case "HostProcess.createdAt":
		if e.complexity.HostProcess.CreatedAt == nil {
			break
		}

		return e.complexity.HostProcess.CreatedAt(childComplexity), true

	case "HostProcess.cwd":
		if e.complexity.HostProcess.Cwd == nil {
			break
		}

		return e.complexity.HostProcess.Cwd(childComplexity), true

	case "HostProcess.env":
		if e.complexity.HostProcess.Env == nil {
			break
		}

		return e.complexity.HostProcess.Env(childComplexity), true

	case "HostProcess.host":
		if e.complexity.HostProcess.Host == nil {
			break
		}

		return e.complexity.HostProcess.Host(childComplexity), true

	case "HostProcess.id":
		if e.complexity.HostProcess.ID == nil {
			break
		}

		return e.complexity.HostProcess.ID(childComplexity), true

	case "HostProcess.lastModifiedAt":
		if e.complexity.HostProcess.LastModifiedAt == nil {
			break
		}

		return e.complexity.HostProcess.LastModifiedAt(childComplexity), true

	case "HostProcess.name":
		if e.complexity.HostProcess.Name == nil {
			break
		}

		return e.complexity.HostProcess.Name(childComplexity), true

	case "HostProcess.path":
		if e.complexity.HostProcess.Path == nil {
			break
		}

		return e.complexity.HostProcess.Path(childComplexity), true

	case "HostProcess.pid":
		if e.complexity.HostProcess.Pid == nil {
			break
		}

		return e.complexity.HostProcess.Pid(childComplexity), true

	case "HostProcess.ppid":
		if e.complexity.HostProcess.Ppid == nil {
			break
		}

		return e.complexity.HostProcess.Ppid(childComplexity), true

	case "HostProcess.principal":
		if e.complexity.HostProcess.Principal == nil {
			break
		}

		return e.complexity.HostProcess.Principal(childComplexity), true

	case "HostProcess.shellTask":
		if e.complexity.HostProcess.ShellTask == nil {
			break
		}

		return e.complexity.HostProcess.ShellTask(childComplexity), true

	case "HostProcess.status":
		if e.complexity.HostProcess.Status == nil {
			break
		}

		return e.complexity.HostProcess.Status(childComplexity), true

	case "HostProcess.task":
		if e.complexity.HostProcess.Task == nil {
			break
		}

		return e.complexity.HostProcess.Task(childComplexity), true

	case "HostProcessConnection.edges":
		if e.complexity.HostProcessConnection.Edges == nil {
			break
		}

		return e.complexity.HostProcessConnection.Edges(childComplexity), true

	case "HostProcessConnection.pageInfo":
		if e.complexity.HostProcessConnection.PageInfo == nil {
			break
		}

		return e.complexity.HostProcessConnection.PageInfo(childComplexity), true

	case "HostProcessConnection.totalCount":
		if e.complexity.HostProcessConnection.TotalCount == nil {
			break
		}

		return e.complexity.HostProcessConnection.TotalCount(childComplexity), true

	case "HostProcessEdge.cursor":
		if e.complexity.HostProcessEdge.Cursor == nil {
			break
		}

		return e.complexity.HostProcessEdge.Cursor(childComplexity), true

	case "HostProcessEdge.node":
		if e.complexity.HostProcessEdge.Node == nil {
			break
		}

		return e.complexity.HostProcessEdge.Node(childComplexity), true

	case "Link.asset":
		if e.complexity.Link.Asset == nil {
			break
		}

		return e.complexity.Link.Asset(childComplexity), true

	case "Link.createdAt":
		if e.complexity.Link.CreatedAt == nil {
			break
		}

		return e.complexity.Link.CreatedAt(childComplexity), true

	case "Link.creator":
		if e.complexity.Link.Creator == nil {
			break
		}

		return e.complexity.Link.Creator(childComplexity), true

	case "Link.downloadLimit":
		if e.complexity.Link.DownloadLimit == nil {
			break
		}

		return e.complexity.Link.DownloadLimit(childComplexity), true

	case "Link.downloads":
		if e.complexity.Link.Downloads == nil {
			break
		}

		return e.complexity.Link.Downloads(childComplexity), true

	case "Link.expiresAt":
		if e.complexity.Link.ExpiresAt == nil {
			break
		}

		return e.complexity.Link.ExpiresAt(childComplexity), true

	case "Link.id":
		if e.complexity.Link.ID == nil {
			break
		}

		return e.complexity.Link.ID(childComplexity), true

	case "Link.lastModifiedAt":
		if e.complexity.Link.LastModifiedAt == nil {
			break
		}

		return e.complexity.Link.LastModifiedAt(childComplexity), true

	case "Link.path":
		if e.complexity.Link.Path == nil {
			break
		}

		return e.complexity.Link.Path(childComplexity), true

	case "LinkConnection.edges":
		if e.complexity.LinkConnection.Edges == nil {
			break
		}

		return e.complexity.LinkConnection.Edges(childComplexity), true

	case "LinkConnection.pageInfo":
		if e.complexity.LinkConnection.PageInfo == nil {
			break
		}

		return e.complexity.LinkConnection.PageInfo(childComplexity), true

	case "LinkConnection.totalCount":
		if e.complexity.LinkConnection.TotalCount == nil {
			break
		}

		return e.complexity.LinkConnection.TotalCount(childComplexity), true

	case "LinkEdge.cursor":
		if e.complexity.LinkEdge.Cursor == nil {
			break
		}

		return e.complexity.LinkEdge.Cursor(childComplexity), true

	case "LinkEdge.node":
		if e.complexity.LinkEdge.Node == nil {
			break
		}

		return e.complexity.LinkEdge.Node(childComplexity), true

	case "Mutation.createBuildTask":
		if e.complexity.Mutation.CreateBuildTask == nil {
			break
		}

		args, err := ec.field_Mutation_createBuildTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBuildTask(childComplexity, args["input"].(models.CreateBuildTaskInput)), true

	case "Mutation.createCredential":
		if e.complexity.Mutation.CreateCredential == nil {
			break
		}

		args, err := ec.field_Mutation_createCredential_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCredential(childComplexity, args["input"].(ent.CreateHostCredentialInput)), true

	case "Mutation.createLink":
		if e.complexity.Mutation.CreateLink == nil {
			break
		}

		args, err := ec.field_Mutation_createLink_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLink(childComplexity, args["input"].(ent.CreateLinkInput)), true

	case "Mutation.createQuest":
		if e.complexity.Mutation.CreateQuest == nil {
			break
		}

		args, err := ec.field_Mutation_createQuest_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateQuest(childComplexity, args["beaconIDs"].([]int), args["input"].(ent.CreateQuestInput)), true

	case "Mutation.createRepository":
		if e.complexity.Mutation.CreateRepository == nil {
			break
		}

		args, err := ec.field_Mutation_createRepository_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRepository(childComplexity, args["input"].(ent.CreateRepositoryInput)), true

	case "Mutation.createShell":
		if e.complexity.Mutation.CreateShell == nil {
			break
		}

		args, err := ec.field_Mutation_createShell_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateShell(childComplexity, args["input"].(ent.CreateShellInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(ent.CreateTagInput)), true

	case "Mutation.createTome":
		if e.complexity.Mutation.CreateTome == nil {
			break
		}

		args, err := ec.field_Mutation_createTome_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTome(childComplexity, args["input"].(ent.CreateTomeInput)), true

	case "Mutation.deleteBuilder":
		if e.complexity.Mutation.DeleteBuilder == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBuilder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBuilder(childComplexity, args["builderID"].(int)), true

	case "Mutation.deleteTome":
		if e.complexity.Mutation.DeleteTome == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTome_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTome(childComplexity, args["tomeID"].(int)), true

	case "Mutation.disableLink":
		if e.complexity.Mutation.DisableLink == nil {
			break
		}

		args, err := ec.field_Mutation_disableLink_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableLink(childComplexity, args["linkID"].(int)), true

	case "Mutation.dropAllData":
		if e.complexity.Mutation.DropAllData == nil {
			break
		}

		return e.complexity.Mutation.DropAllData(childComplexity), true

	case "Mutation.importRepository":
		if e.complexity.Mutation.ImportRepository == nil {
			break
		}

		args, err := ec.field_Mutation_importRepository_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ImportRepository(childComplexity, args["repoID"].(int), args["input"].(*models.ImportRepositoryInput)), true

	case "Mutation.registerBuilder":
		if e.complexity.Mutation.RegisterBuilder == nil {
			break
		}

		args, err := ec.field_Mutation_registerBuilder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterBuilder(childComplexity, args["input"].(ent.CreateBuilderInput)), true

	case "Mutation.updateBeacon":
		if e.complexity.Mutation.UpdateBeacon == nil {
			break
		}

		args, err := ec.field_Mutation_updateBeacon_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBeacon(childComplexity, args["beaconID"].(int), args["input"].(ent.UpdateBeaconInput)), true

	case "Mutation.updateHost":
		if e.complexity.Mutation.UpdateHost == nil {
			break
		}

		args, err := ec.field_Mutation_updateHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHost(childComplexity, args["hostID"].(int), args["input"].(ent.UpdateHostInput)), true

	case "Mutation.updateLink":
		if e.complexity.Mutation.UpdateLink == nil {
			break
		}

		args, err := ec.field_Mutation_updateLink_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLink(childComplexity, args["linkID"].(int), args["input"].(ent.UpdateLinkInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["tagID"].(int), args["input"].(ent.UpdateTagInput)), true

	case "Mutation.updateTome":
		if e.complexity.Mutation.UpdateTome == nil {
			break
		}

		args, err := ec.field_Mutation_updateTome_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTome(childComplexity, args["tomeID"].(int), args["input"].(ent.UpdateTomeInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["userID"].(int), args["input"].(ent.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Portal.activeUsers":
		if e.complexity.Portal.ActiveUsers == nil {
			break
		}

		args, err := ec.field_Portal_activeUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Portal.ActiveUsers(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Portal.beacon":
		if e.complexity.Portal.Beacon == nil {
			break
		}

		return e.complexity.Portal.Beacon(childComplexity), true

	case "Portal.closedAt":
		if e.complexity.Portal.ClosedAt == nil {
			break
		}

		return e.complexity.Portal.ClosedAt(childComplexity), true

	case "Portal.createdAt":
		if e.complexity.Portal.CreatedAt == nil {
			break
		}

		return e.complexity.Portal.CreatedAt(childComplexity), true

	case "Portal.id":
		if e.complexity.Portal.ID == nil {
			break
		}

		return e.complexity.Portal.ID(childComplexity), true

	case "Portal.lastModifiedAt":
		if e.complexity.Portal.LastModifiedAt == nil {
			break
		}

		return e.complexity.Portal.LastModifiedAt(childComplexity), true

	case "Portal.owner":
		if e.complexity.Portal.Owner == nil {
			break
		}

		return e.complexity.Portal.Owner(childComplexity), true

	case "Portal.shellTask":
		if e.complexity.Portal.ShellTask == nil {
			break
		}

		return e.complexity.Portal.ShellTask(childComplexity), true

	case "Portal.task":
		if e.complexity.Portal.Task == nil {
			break
		}

		return e.complexity.Portal.Task(childComplexity), true

	case "PortalConnection.edges":
		if e.complexity.PortalConnection.Edges == nil {
			break
		}

		return e.complexity.PortalConnection.Edges(childComplexity), true

	case "PortalConnection.pageInfo":
		if e.complexity.PortalConnection.PageInfo == nil {
			break
		}

		return e.complexity.PortalConnection.PageInfo(childComplexity), true

	case "PortalConnection.totalCount":
		if e.complexity.PortalConnection.TotalCount == nil {
			break
		}

		return e.complexity.PortalConnection.TotalCount(childComplexity), true

	case "PortalEdge.cursor":
		if e.complexity.PortalEdge.Cursor == nil {
			break
		}

		return e.complexity.PortalEdge.Cursor(childComplexity), true

	case "PortalEdge.node":
		if e.complexity.PortalEdge.Node == nil {
			break
		}

		return e.complexity.PortalEdge.Node(childComplexity), true

	case "Query.assets":
		if e.complexity.Query.Assets == nil {
			break
		}

		args, err := ec.field_Query_assets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Assets(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.AssetOrder), args["where"].(*ent.AssetWhereInput)), true

	case "Query.beacons":
		if e.complexity.Query.Beacons == nil {
			break
		}

		args, err := ec.field_Query_beacons_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Beacons(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.BeaconOrder), args["where"].(*ent.BeaconWhereInput)), true

	case "Query.buildTasks":
		if e.complexity.Query.BuildTasks == nil {
			break
		}

		args, err := ec.field_Query_buildTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildTasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.BuildTaskOrder), args["where"].(*ent.BuildTaskWhereInput)), true

	case "Query.builders":
		if e.complexity.Query.Builders == nil {
			break
		}

		args, err := ec.field_Query_builders_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Builders(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.BuilderOrder), args["where"].(*ent.BuilderWhereInput)), true

	case "Query.hosts":
		if e.complexity.Query.Hosts == nil {
			break
		}

		args, err := ec.field_Query_hosts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hosts(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostOrder), args["where"].(*ent.HostWhereInput)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.portals":
		if e.complexity.Query.Portals == nil {
			break
		}

		args, err := ec.field_Query_portals_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Portals(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.PortalOrder), args["where"].(*ent.PortalWhereInput)), true

	case "Query.quests":
		if e.complexity.Query.Quests == nil {
			break
		}

		args, err := ec.field_Query_quests_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Quests(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.QuestOrder), args["where"].(*ent.QuestWhereInput)), true

	case "Query.repositories":
		if e.complexity.Query.Repositories == nil {
			break
		}

		args, err := ec.field_Query_repositories_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Repositories(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.RepositoryOrder), args["where"].(*ent.RepositoryWhereInput)), true

	case "Query.shells":
		if e.complexity.Query.Shells == nil {
			break
		}

		args, err := ec.field_Query_shells_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Shells(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellOrder), args["where"].(*ent.ShellWhereInput)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		args, err := ec.field_Query_tags_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tags(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TagOrder), args["where"].(*ent.TagWhereInput)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		args, err := ec.field_Query_tasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Query.tomes":
		if e.complexity.Query.Tomes == nil {
			break
		}

		args, err := ec.field_Query_tomes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tomes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TomeOrder), args["where"].(*ent.TomeWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Quest.bundle":
		if e.complexity.Quest.Bundle == nil {
			break
		}

		return e.complexity.Quest.Bundle(childComplexity), true

	case "Quest.createdAt":
		if e.complexity.Quest.CreatedAt == nil {
			break
		}

		return e.complexity.Quest.CreatedAt(childComplexity), true

	case "Quest.creator":
		if e.complexity.Quest.Creator == nil {
			break
		}

		return e.complexity.Quest.Creator(childComplexity), true

	case "Quest.eldritchAtCreation":
		if e.complexity.Quest.EldritchAtCreation == nil {
			break
		}

		return e.complexity.Quest.EldritchAtCreation(childComplexity), true

	case "Quest.id":
		if e.complexity.Quest.ID == nil {
			break
		}

		return e.complexity.Quest.ID(childComplexity), true

	case "Quest.lastModifiedAt":
		if e.complexity.Quest.LastModifiedAt == nil {
			break
		}

		return e.complexity.Quest.LastModifiedAt(childComplexity), true

	case "Quest.name":
		if e.complexity.Quest.Name == nil {
			break
		}

		return e.complexity.Quest.Name(childComplexity), true

	case "Quest.paramDefsAtCreation":
		if e.complexity.Quest.ParamDefsAtCreation == nil {
			break
		}

		return e.complexity.Quest.ParamDefsAtCreation(childComplexity), true

	case "Quest.parameters":
		if e.complexity.Quest.Parameters == nil {
			break
		}

		return e.complexity.Quest.Parameters(childComplexity), true

	case "Quest.tasks":
		if e.complexity.Quest.Tasks == nil {
			break
		}

		args, err := ec.field_Quest_tasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Quest.Tasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Quest.tome":
		if e.complexity.Quest.Tome == nil {
			break
		}

		return e.complexity.Quest.Tome(childComplexity), true

	case "QuestConnection.edges":
		if e.complexity.QuestConnection.Edges == nil {
			break
		}

		return e.complexity.QuestConnection.Edges(childComplexity), true

	case "QuestConnection.pageInfo":
		if e.complexity.QuestConnection.PageInfo == nil {
			break
		}

		return e.complexity.QuestConnection.PageInfo(childComplexity), true

	case "QuestConnection.totalCount":
		if e.complexity.QuestConnection.TotalCount == nil {
			break
		}

		return e.complexity.QuestConnection.TotalCount(childComplexity), true

	case "QuestEdge.cursor":
		if e.complexity.QuestEdge.Cursor == nil {
			break
		}

		return e.complexity.QuestEdge.Cursor(childComplexity), true

	case "QuestEdge.node":
		if e.complexity.QuestEdge.Node == nil {
			break
		}

		return e.complexity.QuestEdge.Node(childComplexity), true

	case "RegisterBuilderOutput.builder":
		if e.complexity.RegisterBuilderOutput.Builder == nil {
			break
		}

		return e.complexity.RegisterBuilderOutput.Builder(childComplexity), true

	case "RegisterBuilderOutput.config":
		if e.complexity.RegisterBuilderOutput.Config == nil {
			break
		}

		return e.complexity.RegisterBuilderOutput.Config(childComplexity), true

	case "RegisterBuilderOutput.mtlsCert":
		if e.complexity.RegisterBuilderOutput.MtlsCert == nil {
			break
		}

		return e.complexity.RegisterBuilderOutput.MtlsCert(childComplexity), true

	case "Repository.createdAt":
		if e.complexity.Repository.CreatedAt == nil {
			break
		}

		return e.complexity.Repository.CreatedAt(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.lastImportedAt":
		if e.complexity.Repository.LastImportedAt == nil {
			break
		}

		return e.complexity.Repository.LastImportedAt(childComplexity), true

	case "Repository.lastModifiedAt":
		if e.complexity.Repository.LastModifiedAt == nil {
			break
		}

		return e.complexity.Repository.LastModifiedAt(childComplexity), true

	case "Repository.owner":
		if e.complexity.Repository.Owner == nil {
			break
		}

		return e.complexity.Repository.Owner(childComplexity), true

	case "Repository.publicKey":
		if e.complexity.Repository.PublicKey == nil {
			break
		}

		return e.complexity.Repository.PublicKey(childComplexity), true

	case "Repository.tomes":
		if e.complexity.Repository.Tomes == nil {
			break
		}

		args, err := ec.field_Repository_tomes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Tomes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TomeOrder), args["where"].(*ent.TomeWhereInput)), true

	case "Repository.url":
		if e.complexity.Repository.URL == nil {
			break
		}

		return e.complexity.Repository.URL(childComplexity), true

	case "RepositoryConnection.edges":
		if e.complexity.RepositoryConnection.Edges == nil {
			break
		}

		return e.complexity.RepositoryConnection.Edges(childComplexity), true

	case "RepositoryConnection.pageInfo":
		if e.complexity.RepositoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.RepositoryConnection.PageInfo(childComplexity), true

	case "RepositoryConnection.totalCount":
		if e.complexity.RepositoryConnection.TotalCount == nil {
			break
		}

		return e.complexity.RepositoryConnection.TotalCount(childComplexity), true

	case "RepositoryEdge.cursor":
		if e.complexity.RepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryEdge.Cursor(childComplexity), true

	case "RepositoryEdge.node":
		if e.complexity.RepositoryEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryEdge.Node(childComplexity), true

	case "Screenshot.createdAt":
		if e.complexity.Screenshot.CreatedAt == nil {
			break
		}

		return e.complexity.Screenshot.CreatedAt(childComplexity), true

	case "Screenshot.hash":
		if e.complexity.Screenshot.Hash == nil {
			break
		}

		return e.complexity.Screenshot.Hash(childComplexity), true

	case "Screenshot.host":
		if e.complexity.Screenshot.Host == nil {
			break
		}

		return e.complexity.Screenshot.Host(childComplexity), true

	case "Screenshot.id":
		if e.complexity.Screenshot.ID == nil {
			break
		}

		return e.complexity.Screenshot.ID(childComplexity), true

	case "Screenshot.lastModifiedAt":
		if e.complexity.Screenshot.LastModifiedAt == nil {
			break
		}

		return e.complexity.Screenshot.LastModifiedAt(childComplexity), true

	case "Screenshot.name":
		if e.complexity.Screenshot.Name == nil {
			break
		}

		return e.complexity.Screenshot.Name(childComplexity), true

	case "Screenshot.shellTask":
		if e.complexity.Screenshot.ShellTask == nil {
			break
		}

		return e.complexity.Screenshot.ShellTask(childComplexity), true

	case "Screenshot.size":
		if e.complexity.Screenshot.Size == nil {
			break
		}

		return e.complexity.Screenshot.Size(childComplexity), true

	case "Screenshot.task":
		if e.complexity.Screenshot.Task == nil {
			break
		}

		return e.complexity.Screenshot.Task(childComplexity), true

	case "ScreenshotConnection.edges":
		if e.complexity.ScreenshotConnection.Edges == nil {
			break
		}

		return e.complexity.ScreenshotConnection.Edges(childComplexity), true

	case "ScreenshotConnection.pageInfo":
		if e.complexity.ScreenshotConnection.PageInfo == nil {
			break
		}

		return e.complexity.ScreenshotConnection.PageInfo(childComplexity), true

	case "ScreenshotConnection.totalCount":
		if e.complexity.ScreenshotConnection.TotalCount == nil {
			break
		}

		return e.complexity.ScreenshotConnection.TotalCount(childComplexity), true

	case "ScreenshotEdge.cursor":
		if e.complexity.ScreenshotEdge.Cursor == nil {
			break
		}

		return e.complexity.ScreenshotEdge.Cursor(childComplexity), true

	case "ScreenshotEdge.node":
		if e.complexity.ScreenshotEdge.Node == nil {
			break
		}

		return e.complexity.ScreenshotEdge.Node(childComplexity), true

	case "Shell.activeUsers":
		if e.complexity.Shell.ActiveUsers == nil {
			break
		}

		args, err := ec.field_Shell_activeUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Shell.ActiveUsers(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Shell.beacon":
		if e.complexity.Shell.Beacon == nil {
			break
		}

		return e.complexity.Shell.Beacon(childComplexity), true

	case "Shell.closedAt":
		if e.complexity.Shell.ClosedAt == nil {
			break
		}

		return e.complexity.Shell.ClosedAt(childComplexity), true

	case "Shell.createdAt":
		if e.complexity.Shell.CreatedAt == nil {
			break
		}

		return e.complexity.Shell.CreatedAt(childComplexity), true

	case "Shell.id":
		if e.complexity.Shell.ID == nil {
			break
		}

		return e.complexity.Shell.ID(childComplexity), true

	case "Shell.lastModifiedAt":
		if e.complexity.Shell.LastModifiedAt == nil {
			break
		}

		return e.complexity.Shell.LastModifiedAt(childComplexity), true

	case "Shell.owner":
		if e.complexity.Shell.Owner == nil {
			break
		}

		return e.complexity.Shell.Owner(childComplexity), true

	case "Shell.portals":
		if e.complexity.Shell.Portals == nil {
			break
		}

		return e.complexity.Shell.Portals(childComplexity), true

	case "Shell.shellTasks":
		if e.complexity.Shell.ShellTasks == nil {
			break
		}

		args, err := ec.field_Shell_shellTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Shell.ShellTasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellTaskOrder), args["where"].(*ent.ShellTaskWhereInput)), true

	case "Shell.task":
		if e.complexity.Shell.Task == nil {
			break
		}

		return e.complexity.Shell.Task(childComplexity), true

	case "ShellConnection.edges":
		if e.complexity.ShellConnection.Edges == nil {
			break
		}

		return e.complexity.ShellConnection.Edges(childComplexity), true

	case "ShellConnection.pageInfo":
		if e.complexity.ShellConnection.PageInfo == nil {
			break
		}

		return e.complexity.ShellConnection.PageInfo(childComplexity), true

	case "ShellConnection.totalCount":
		if e.complexity.ShellConnection.TotalCount == nil {
			break
		}

		return e.complexity.ShellConnection.TotalCount(childComplexity), true

	case "ShellEdge.cursor":
		if e.complexity.ShellEdge.Cursor == nil {
			break
		}

		return e.complexity.ShellEdge.Cursor(childComplexity), true

	case "ShellEdge.node":
		if e.complexity.ShellEdge.Node == nil {
			break
		}

		return e.complexity.ShellEdge.Node(childComplexity), true

	case "ShellTask.claimedAt":
		if e.complexity.ShellTask.ClaimedAt == nil {
			break
		}

		return e.complexity.ShellTask.ClaimedAt(childComplexity), true

	case "ShellTask.createdAt":
		if e.complexity.ShellTask.CreatedAt == nil {
			break
		}

		return e.complexity.ShellTask.CreatedAt(childComplexity), true

	case "ShellTask.creator":
		if e.complexity.ShellTask.Creator == nil {
			break
		}

		return e.complexity.ShellTask.Creator(childComplexity), true

	case "ShellTask.error":
		if e.complexity.ShellTask.Error == nil {
			break
		}

		return e.complexity.ShellTask.Error(childComplexity), true

	case "ShellTask.execFinishedAt":
		if e.complexity.ShellTask.ExecFinishedAt == nil {
			break
		}

		return e.complexity.ShellTask.ExecFinishedAt(childComplexity), true

	case "ShellTask.execStartedAt":
		if e.complexity.ShellTask.ExecStartedAt == nil {
			break
		}

		return e.complexity.ShellTask.ExecStartedAt(childComplexity), true

	case "ShellTask.id":
		if e.complexity.ShellTask.ID == nil {
			break
		}

		return e.complexity.ShellTask.ID(childComplexity), true

	case "ShellTask.input":
		if e.complexity.ShellTask.Input == nil {
			break
		}

		return e.complexity.ShellTask.Input(childComplexity), true

	case "ShellTask.lastModifiedAt":
		if e.complexity.ShellTask.LastModifiedAt == nil {
			break
		}

		return e.complexity.ShellTask.LastModifiedAt(childComplexity), true

	case "ShellTask.output":
		if e.complexity.ShellTask.Output == nil {
			break
		}

		return e.complexity.ShellTask.Output(childComplexity), true

	case "ShellTask.reportedCredentials":
		if e.complexity.ShellTask.ReportedCredentials == nil {
			break
		}

		return e.complexity.ShellTask.ReportedCredentials(childComplexity), true

	case "ShellTask.reportedFiles":
		if e.complexity.ShellTask.ReportedFiles == nil {
			break
		}

		return e.complexity.ShellTask.ReportedFiles(childComplexity), true

	case "ShellTask.reportedProcesses":
		if e.complexity.ShellTask.ReportedProcesses == nil {
			break
		}

		return e.complexity.ShellTask.ReportedProcesses(childComplexity), true

	case "ShellTask.screenshots":
		if e.complexity.ShellTask.Screenshots == nil {
			break
		}

		return e.complexity.ShellTask.Screenshots(childComplexity), true

	case "ShellTask.sequenceID":
		if e.complexity.ShellTask.SequenceID == nil {
			break
		}

		return e.complexity.ShellTask.SequenceID(childComplexity), true

	case "ShellTask.shell":
		if e.complexity.ShellTask.Shell == nil {
			break
		}

		return e.complexity.ShellTask.Shell(childComplexity), true

	case "ShellTask.streamID":
		if e.complexity.ShellTask.StreamID == nil {
			break
		}

		return e.complexity.ShellTask.StreamID(childComplexity), true

	case "ShellTaskConnection.edges":
		if e.complexity.ShellTaskConnection.Edges == nil {
			break
		}

		return e.complexity.ShellTaskConnection.Edges(childComplexity), true

	case "ShellTaskConnection.pageInfo":
		if e.complexity.ShellTaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.ShellTaskConnection.PageInfo(childComplexity), true

	case "ShellTaskConnection.totalCount":
		if e.complexity.ShellTaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.ShellTaskConnection.TotalCount(childComplexity), true

	case "ShellTaskEdge.cursor":
		if e.complexity.ShellTaskEdge.Cursor == nil {
			break
		}

		return e.complexity.ShellTaskEdge.Cursor(childComplexity), true

	case "ShellTaskEdge.node":
		if e.complexity.ShellTaskEdge.Node == nil {
			break
		}

		return e.complexity.ShellTaskEdge.Node(childComplexity), true

	case "Tag.hosts":
		if e.complexity.Tag.Hosts == nil {
			break
		}

		args, err := ec.field_Tag_hosts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tag.Hosts(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostOrder), args["where"].(*ent.HostWhereInput)), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.kind":
		if e.complexity.Tag.Kind == nil {
			break
		}

		return e.complexity.Tag.Kind(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "TagConnection.edges":
		if e.complexity.TagConnection.Edges == nil {
			break
		}

		return e.complexity.TagConnection.Edges(childComplexity), true

	case "TagConnection.pageInfo":
		if e.complexity.TagConnection.PageInfo == nil {
			break
		}

		return e.complexity.TagConnection.PageInfo(childComplexity), true

	case "TagConnection.totalCount":
		if e.complexity.TagConnection.TotalCount == nil {
			break
		}

		return e.complexity.TagConnection.TotalCount(childComplexity), true

	case "TagEdge.cursor":
		if e.complexity.TagEdge.Cursor == nil {
			break
		}

		return e.complexity.TagEdge.Cursor(childComplexity), true

	case "TagEdge.node":
		if e.complexity.TagEdge.Node == nil {
			break
		}

		return e.complexity.TagEdge.Node(childComplexity), true

	case "Task.beacon":
		if e.complexity.Task.Beacon == nil {
			break
		}

		return e.complexity.Task.Beacon(childComplexity), true

	case "Task.claimedAt":
		if e.complexity.Task.ClaimedAt == nil {
			break
		}

		return e.complexity.Task.ClaimedAt(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.error":
		if e.complexity.Task.Error == nil {
			break
		}

		return e.complexity.Task.Error(childComplexity), true

	case "Task.execFinishedAt":
		if e.complexity.Task.ExecFinishedAt == nil {
			break
		}

		return e.complexity.Task.ExecFinishedAt(childComplexity), true

	case "Task.execStartedAt":
		if e.complexity.Task.ExecStartedAt == nil {
			break
		}

		return e.complexity.Task.ExecStartedAt(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.lastModifiedAt":
		if e.complexity.Task.LastModifiedAt == nil {
			break
		}

		return e.complexity.Task.LastModifiedAt(childComplexity), true

	case "Task.output":
		if e.complexity.Task.Output == nil {
			break
		}

		return e.complexity.Task.Output(childComplexity), true

	case "Task.outputSize":
		if e.complexity.Task.OutputSize == nil {
			break
		}

		return e.complexity.Task.OutputSize(childComplexity), true

	case "Task.quest":
		if e.complexity.Task.Quest == nil {
			break
		}

		return e.complexity.Task.Quest(childComplexity), true

	case "Task.reportedCredentials":
		if e.complexity.Task.ReportedCredentials == nil {
			break
		}

		args, err := ec.field_Task_reportedCredentials_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.ReportedCredentials(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostCredentialOrder), args["where"].(*ent.HostCredentialWhereInput)), true

	case "Task.reportedFiles":
		if e.complexity.Task.ReportedFiles == nil {
			break
		}

		args, err := ec.field_Task_reportedFiles_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.ReportedFiles(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostFileOrder), args["where"].(*ent.HostFileWhereInput)), true

	case "Task.reportedProcesses":
		if e.complexity.Task.ReportedProcesses == nil {
			break
		}

		args, err := ec.field_Task_reportedProcesses_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.ReportedProcesses(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostProcessOrder), args["where"].(*ent.HostProcessWhereInput)), true

	case "Task.screenshots":
		if e.complexity.Task.Screenshots == nil {
			break
		}

		args, err := ec.field_Task_screenshots_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.Screenshots(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ScreenshotOrder), args["where"].(*ent.ScreenshotWhereInput)), true

	case "Task.shells":
		if e.complexity.Task.Shells == nil {
			break
		}

		args, err := ec.field_Task_shells_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.Shells(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellOrder), args["where"].(*ent.ShellWhereInput)), true

	case "TaskConnection.edges":
		if e.complexity.TaskConnection.Edges == nil {
			break
		}

		return e.complexity.TaskConnection.Edges(childComplexity), true

	case "TaskConnection.pageInfo":
		if e.complexity.TaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.TaskConnection.PageInfo(childComplexity), true

	case "TaskConnection.totalCount":
		if e.complexity.TaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.TaskConnection.TotalCount(childComplexity), true

	case "TaskEdge.cursor":
		if e.complexity.TaskEdge.Cursor == nil {
			break
		}

		return e.complexity.TaskEdge.Cursor(childComplexity), true

	case "TaskEdge.node":
		if e.complexity.TaskEdge.Node == nil {
			break
		}

		return e.complexity.TaskEdge.Node(childComplexity), true

	case "Tome.assets":
		if e.complexity.Tome.Assets == nil {
			break
		}

		args, err := ec.field_Tome_assets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tome.Assets(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.AssetOrder), args["where"].(*ent.AssetWhereInput)), true

	case "Tome.author":
		if e.complexity.Tome.Author == nil {
			break
		}

		return e.complexity.Tome.Author(childComplexity), true

	case "Tome.createdAt":
		if e.complexity.Tome.CreatedAt == nil {
			break
		}

		return e.complexity.Tome.CreatedAt(childComplexity), true

	case "Tome.description":
		if e.complexity.Tome.Description == nil {
			break
		}

		return e.complexity.Tome.Description(childComplexity), true

	case "Tome.eldritch":
		if e.complexity.Tome.Eldritch == nil {
			break
		}

		return e.complexity.Tome.Eldritch(childComplexity), true

	case "Tome.id":
		if e.complexity.Tome.ID == nil {
			break
		}

		return e.complexity.Tome.ID(childComplexity), true

	case "Tome.lastModifiedAt":
		if e.complexity.Tome.LastModifiedAt == nil {
			break
		}

		return e.complexity.Tome.LastModifiedAt(childComplexity), true

	case "Tome.name":
		if e.complexity.Tome.Name == nil {
			break
		}

		return e.complexity.Tome.Name(childComplexity), true

	case "Tome.paramDefs":
		if e.complexity.Tome.ParamDefs == nil {
			break
		}

		return e.complexity.Tome.ParamDefs(childComplexity), true

	case "Tome.repository":
		if e.complexity.Tome.Repository == nil {
			break
		}

		return e.complexity.Tome.Repository(childComplexity), true

	case "Tome.runOnFirstHostCallback":
		if e.complexity.Tome.RunOnFirstHostCallback == nil {
			break
		}

		return e.complexity.Tome.RunOnFirstHostCallback(childComplexity), true

	case "Tome.runOnNewBeaconCallback":
		if e.complexity.Tome.RunOnNewBeaconCallback == nil {
			break
		}

		return e.complexity.Tome.RunOnNewBeaconCallback(childComplexity), true

	case "Tome.runOnSchedule":
		if e.complexity.Tome.RunOnSchedule == nil {
			break
		}

		return e.complexity.Tome.RunOnSchedule(childComplexity), true

	case "Tome.scheduledHosts":
		if e.complexity.Tome.ScheduledHosts == nil {
			break
		}

		args, err := ec.field_Tome_scheduledHosts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tome.ScheduledHosts(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.HostOrder), args["where"].(*ent.HostWhereInput)), true

	case "Tome.supportModel":
		if e.complexity.Tome.SupportModel == nil {
			break
		}

		return e.complexity.Tome.SupportModel(childComplexity), true

	case "Tome.tactic":
		if e.complexity.Tome.Tactic == nil {
			break
		}

		return e.complexity.Tome.Tactic(childComplexity), true

	case "Tome.uploader":
		if e.complexity.Tome.Uploader == nil {
			break
		}

		return e.complexity.Tome.Uploader(childComplexity), true

	case "TomeConnection.edges":
		if e.complexity.TomeConnection.Edges == nil {
			break
		}

		return e.complexity.TomeConnection.Edges(childComplexity), true

	case "TomeConnection.pageInfo":
		if e.complexity.TomeConnection.PageInfo == nil {
			break
		}

		return e.complexity.TomeConnection.PageInfo(childComplexity), true

	case "TomeConnection.totalCount":
		if e.complexity.TomeConnection.TotalCount == nil {
			break
		}

		return e.complexity.TomeConnection.TotalCount(childComplexity), true

	case "TomeEdge.cursor":
		if e.complexity.TomeEdge.Cursor == nil {
			break
		}

		return e.complexity.TomeEdge.Cursor(childComplexity), true

	case "TomeEdge.node":
		if e.complexity.TomeEdge.Node == nil {
			break
		}

		return e.complexity.TomeEdge.Node(childComplexity), true

	case "User.activeShells":
		if e.complexity.User.ActiveShells == nil {
			break
		}

		args, err := ec.field_User_activeShells_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.ActiveShells(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.ShellOrder), args["where"].(*ent.ShellWhereInput)), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isActivated":
		if e.complexity.User.IsActivated == nil {
			break
		}

		return e.complexity.User.IsActivated(childComplexity), true

	case "User.isAdmin":
		if e.complexity.User.IsAdmin == nil {
			break
		}

		return e.complexity.User.IsAdmin(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.photoURL":
		if e.complexity.User.PhotoURL == nil {
			break
		}

		return e.complexity.User.PhotoURL(childComplexity), true

	case "User.tomes":
		if e.complexity.User.Tomes == nil {
			break
		}

		args, err := ec.field_User_tomes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Tomes(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TomeOrder), args["where"].(*ent.TomeWhereInput)), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAssetOrder,
		ec.unmarshalInputAssetWhereInput,
		ec.unmarshalInputBeaconOrder,
		ec.unmarshalInputBeaconWhereInput,
		ec.unmarshalInputBuildTaskOrder,
		ec.unmarshalInputBuildTaskTransportInput,
		ec.unmarshalInputBuildTaskWhereInput,
		ec.unmarshalInputBuilderOrder,
		ec.unmarshalInputBuilderWhereInput,
		ec.unmarshalInputClaimTasksInput,
		ec.unmarshalInputCreateBuildTaskInput,
		ec.unmarshalInputCreateBuilderInput,
		ec.unmarshalInputCreateHostCredentialInput,
		ec.unmarshalInputCreateLinkInput,
		ec.unmarshalInputCreateQuestInput,
		ec.unmarshalInputCreateRepositoryInput,
		ec.unmarshalInputCreateShellInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputCreateTomeInput,
		ec.unmarshalInputHostCredentialOrder,
		ec.unmarshalInputHostCredentialWhereInput,
		ec.unmarshalInputHostFileOrder,
		ec.unmarshalInputHostFileWhereInput,
		ec.unmarshalInputHostOrder,
		ec.unmarshalInputHostProcessOrder,
		ec.unmarshalInputHostProcessWhereInput,
		ec.unmarshalInputHostWhereInput,
		ec.unmarshalInputImportRepositoryInput,
		ec.unmarshalInputLinkOrder,
		ec.unmarshalInputLinkWhereInput,
		ec.unmarshalInputPortalOrder,
		ec.unmarshalInputPortalWhereInput,
		ec.unmarshalInputQuestOrder,
		ec.unmarshalInputQuestWhereInput,
		ec.unmarshalInputRepositoryOrder,
		ec.unmarshalInputRepositoryWhereInput,
		ec.unmarshalInputScreenshotOrder,
		ec.unmarshalInputScreenshotWhereInput,
		ec.unmarshalInputShellOrder,
		ec.unmarshalInputShellTaskOrder,
		ec.unmarshalInputShellTaskWhereInput,
		ec.unmarshalInputShellWhereInput,
		ec.unmarshalInputSubmitTaskResultInput,
		ec.unmarshalInputTagOrder,
		ec.unmarshalInputTagWhereInput,
		ec.unmarshalInputTaskOrder,
		ec.unmarshalInputTaskWhereInput,
		ec.unmarshalInputTomeOrder,
		ec.unmarshalInputTomeWhereInput,
		ec.unmarshalInputUpdateBeaconInput,
		ec.unmarshalInputUpdateHostInput,
		ec.unmarshalInputUpdateLinkInput,
		ec.unmarshalInputUpdateTagInput,
		ec.unmarshalInputUpdateTomeInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/directives.graphql", Input: `directive @requireRole(role: Role!) on FIELD_DEFINITION

enum Role {
    ADMIN
    USER
}`, BuiltIn: false},
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Asset implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  The name of the asset, used to reference it for downloads
  """
  name: String!
  """
  The size of the asset in bytes
  """
  size: Int!
  """
  A SHA3-256 digest of the content field
  """
  hash: String!
  tomes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tomes returned from the connection.
    """
    orderBy: [TomeOrder!]

    """
    Filtering options for Tomes returned from the connection.
    """
    where: TomeWhereInput
  ): TomeConnection!
  links(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Links returned from the connection.
    """
    orderBy: [LinkOrder!]

    """
    Filtering options for Links returned from the connection.
    """
    where: LinkWhereInput
  ): LinkConnection!
  """
  User that created the asset if available.
  """
  creator: User
}
"""
A connection to a list of items.
"""
type AssetConnection {
  """
  A list of edges.
  """
  edges: [AssetEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type AssetEdge {
  """
  The item at the end of the edge.
  """
  node: Asset
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Asset connections
"""
input AssetOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Assets.
  """
  field: AssetOrderField!
}
"""
Properties by which Asset connections can be ordered.
"""
enum AssetOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
AssetWhereInput is used for filtering Asset objects.
Input was generated by ent.
"""
input AssetWhereInput {
  not: AssetWhereInput
  and: [AssetWhereInput!]
  or: [AssetWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  size field predicates
  """
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """
  hash field predicates
  """
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashEqualFold: String
  hashContainsFold: String
  """
  tomes edge predicates
  """
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
  """
  links edge predicates
  """
  hasLinks: Boolean
  hasLinksWith: [LinkWhereInput!]
  """
  creator edge predicates
  """
  hasCreator: Boolean
  hasCreatorWith: [UserWhereInput!]
}
type Beacon implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  A human readable identifier for the beacon.
  """
  name: String!
  """
  The identity the beacon is authenticated as (e.g. 'root')
  """
  principal: String
  """
  Unique identifier for the beacon. Unique to each instance of the beacon.
  """
  identifier: String!
  """
  Identifies the agent that the beacon is running as (e.g. 'imix').
  """
  agentIdentifier: String
  """
  Timestamp of when a task was last claimed or updated for the beacon.
  """
  lastSeenAt: Time
  """
  Timestamp of when a beacon is expected to check for tasks next.
  """
  nextSeenAt: Time
  """
  Duration until next callback, in seconds.
  """
  interval: Uint64
  """
  Beacon's current transport.
  """
  transport: BeaconTransport_Type!
  """
  Host this beacon is running on.
  """
  host: Host!
  tasks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tasks returned from the connection.
    """
    orderBy: [TaskOrder!]

    """
    Filtering options for Tasks returned from the connection.
    """
    where: TaskWhereInput
  ): TaskConnection!
  shells(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Shells returned from the connection.
    """
    orderBy: [ShellOrder!]

    """
    Filtering options for Shells returned from the connection.
    """
    where: ShellWhereInput
  ): ShellConnection!
}
"""
A connection to a list of items.
"""
type BeaconConnection {
  """
  A list of edges.
  """
  edges: [BeaconEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type BeaconEdge {
  """
  The item at the end of the edge.
  """
  node: Beacon
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Beacon connections
"""
input BeaconOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Beacons.
  """
  field: BeaconOrderField!
}
"""
Properties by which Beacon connections can be ordered.
"""
enum BeaconOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_SEEN_AT
  NEXT_SEEN_AT
  INTERVAL
}
"""
BeaconTransport_Type is enum for the field transport
"""
enum BeaconTransport_Type @goModel(model: "realm.pub/tavern/internal/c2/c2pb.Transport_Type") {
  TRANSPORT_DNS
  TRANSPORT_GRPC
  TRANSPORT_HTTP1
  TRANSPORT_UNSPECIFIED
}
"""
BeaconWhereInput is used for filtering Beacon objects.
Input was generated by ent.
"""
input BeaconWhereInput {
  not: BeaconWhereInput
  and: [BeaconWhereInput!]
  or: [BeaconWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  principal field predicates
  """
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalIsNil: Boolean
  principalNotNil: Boolean
  principalEqualFold: String
  principalContainsFold: String
  """
  identifier field predicates
  """
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """
  agent_identifier field predicates
  """
  agentIdentifier: String
  agentIdentifierNEQ: String
  agentIdentifierIn: [String!]
  agentIdentifierNotIn: [String!]
  agentIdentifierGT: String
  agentIdentifierGTE: String
  agentIdentifierLT: String
  agentIdentifierLTE: String
  agentIdentifierContains: String
  agentIdentifierHasPrefix: String
  agentIdentifierHasSuffix: String
  agentIdentifierIsNil: Boolean
  agentIdentifierNotNil: Boolean
  agentIdentifierEqualFold: String
  agentIdentifierContainsFold: String
  """
  last_seen_at field predicates
  """
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """
  next_seen_at field predicates
  """
  nextSeenAt: Time
  nextSeenAtNEQ: Time
  nextSeenAtIn: [Time!]
  nextSeenAtNotIn: [Time!]
  nextSeenAtGT: Time
  nextSeenAtGTE: Time
  nextSeenAtLT: Time
  nextSeenAtLTE: Time
  nextSeenAtIsNil: Boolean
  nextSeenAtNotNil: Boolean
  """
  interval field predicates
  """
  interval: Uint64
  intervalNEQ: Uint64
  intervalIn: [Uint64!]
  intervalNotIn: [Uint64!]
  intervalGT: Uint64
  intervalGTE: Uint64
  intervalLT: Uint64
  intervalLTE: Uint64
  intervalIsNil: Boolean
  intervalNotNil: Boolean
  """
  transport field predicates
  """
  transport: BeaconTransport_Type
  transportNEQ: BeaconTransport_Type
  transportIn: [BeaconTransport_Type!]
  transportNotIn: [BeaconTransport_Type!]
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  tasks edge predicates
  """
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
  """
  shells edge predicates
  """
  hasShells: Boolean
  hasShellsWith: [ShellWhereInput!]
}
type BuildTask implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  The target operating system platform for this build.
  """
  targetOs: HostPlatform!
  """
  The output format for the build (BIN, CDYLIB, WINDOWS_SERVICE).
  """
  targetFormat: BuildTaskTargetFormat!
  """
  Docker container image name to use for the build.
  """
  buildImage: String!
  """
  The derived script to execute inside the build container.
  """
  buildScript: String!
  """
  List of transport configurations for the IMIX agent.
  """
  transports: [BuildTaskTransport!]!
  """
  Timestamp of when a builder claimed this task, null if unclaimed.
  """
  claimedAt: Time
  """
  Timestamp of when the build execution started, null if not yet started.
  """
  startedAt: Time
  """
  Timestamp of when the build finished, null if not yet finished.
  """
  finishedAt: Time
  """
  Output from the build execution.
  """
  output: String
  """
  The size of the output in bytes
  """
  outputSize: Int!
  """
  Error message if the build failed.
  """
  error: String
  """
  The size of the error in bytes
  """
  errorSize: Int!
  """
  Exit code from the build container process. Null if the build has not finished.
  """
  exitCode: Int
  """
  Path inside the container where the build artifact is located. Derived from target_os if not set.
  """
  artifactPath: String
  """
  The builder assigned to execute this build task.
  """
  builder: Builder!
  """
  The compiled artifact produced by this build task, stored as an Asset.
  """
  artifact: Asset
}
"""
A connection to a list of items.
"""
type BuildTaskConnection {
  """
  A list of edges.
  """
  edges: [BuildTaskEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type BuildTaskEdge {
  """
  The item at the end of the edge.
  """
  node: BuildTask
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for BuildTask connections
"""
input BuildTaskOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order BuildTasks.
  """
  field: BuildTaskOrderField!
}
"""
Properties by which BuildTask connections can be ordered.
"""
enum BuildTaskOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  TARGET_OS
  CLAIMED_AT
  STARTED_AT
  FINISHED_AT
  OUTPUT_SIZE
  ERROR_SIZE
  EXIT_CODE
}
"""
BuildTaskTargetFormat is enum for the field target_format
"""
enum BuildTaskTargetFormat @goModel(model: "realm.pub/tavern/internal/builder/builderpb.TargetFormat") {
  TARGET_FORMAT_BIN
  TARGET_FORMAT_CDYLIB
  TARGET_FORMAT_UNSPECIFIED
  TARGET_FORMAT_WINDOWS_SERVICE
}
"""
BuildTaskWhereInput is used for filtering BuildTask objects.
Input was generated by ent.
"""
input BuildTaskWhereInput {
  not: BuildTaskWhereInput
  and: [BuildTaskWhereInput!]
  or: [BuildTaskWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  target_os field predicates
  """
  targetOs: HostPlatform
  targetOsNEQ: HostPlatform
  targetOsIn: [HostPlatform!]
  targetOsNotIn: [HostPlatform!]
  """
  target_format field predicates
  """
  targetFormat: BuildTaskTargetFormat
  targetFormatNEQ: BuildTaskTargetFormat
  targetFormatIn: [BuildTaskTargetFormat!]
  targetFormatNotIn: [BuildTaskTargetFormat!]
  """
  build_image field predicates
  """
  buildImage: String
  buildImageNEQ: String
  buildImageIn: [String!]
  buildImageNotIn: [String!]
  buildImageGT: String
  buildImageGTE: String
  buildImageLT: String
  buildImageLTE: String
  buildImageContains: String
  buildImageHasPrefix: String
  buildImageHasSuffix: String
  buildImageEqualFold: String
  buildImageContainsFold: String
  """
  build_script field predicates
  """
  buildScript: String
  buildScriptNEQ: String
  buildScriptIn: [String!]
  buildScriptNotIn: [String!]
  buildScriptGT: String
  buildScriptGTE: String
  buildScriptLT: String
  buildScriptLTE: String
  buildScriptContains: String
  buildScriptHasPrefix: String
  buildScriptHasSuffix: String
  buildScriptEqualFold: String
  buildScriptContainsFold: String
  """
  claimed_at field predicates
  """
  claimedAt: Time
  claimedAtNEQ: Time
  claimedAtIn: [Time!]
  claimedAtNotIn: [Time!]
  claimedAtGT: Time
  claimedAtGTE: Time
  claimedAtLT: Time
  claimedAtLTE: Time
  claimedAtIsNil: Boolean
  claimedAtNotNil: Boolean
  """
  started_at field predicates
  """
  startedAt: Time
  startedAtNEQ: Time
  startedAtIn: [Time!]
  startedAtNotIn: [Time!]
  startedAtGT: Time
  startedAtGTE: Time
  startedAtLT: Time
  startedAtLTE: Time
  startedAtIsNil: Boolean
  startedAtNotNil: Boolean
  """
  finished_at field predicates
  """
  finishedAt: Time
  finishedAtNEQ: Time
  finishedAtIn: [Time!]
  finishedAtNotIn: [Time!]
  finishedAtGT: Time
  finishedAtGTE: Time
  finishedAtLT: Time
  finishedAtLTE: Time
  finishedAtIsNil: Boolean
  finishedAtNotNil: Boolean
  """
  output field predicates
  """
  output: String
  outputNEQ: String
  outputIn: [String!]
  outputNotIn: [String!]
  outputGT: String
  outputGTE: String
  outputLT: String
  outputLTE: String
  outputContains: String
  outputHasPrefix: String
  outputHasSuffix: String
  outputIsNil: Boolean
  outputNotNil: Boolean
  outputEqualFold: String
  outputContainsFold: String
  """
  output_size field predicates
  """
  outputSize: Int
  outputSizeNEQ: Int
  outputSizeIn: [Int!]
  outputSizeNotIn: [Int!]
  outputSizeGT: Int
  outputSizeGTE: Int
  outputSizeLT: Int
  outputSizeLTE: Int
  """
  error field predicates
  """
  error: String
  errorNEQ: String
  errorIn: [String!]
  errorNotIn: [String!]
  errorGT: String
  errorGTE: String
  errorLT: String
  errorLTE: String
  errorContains: String
  errorHasPrefix: String
  errorHasSuffix: String
  errorIsNil: Boolean
  errorNotNil: Boolean
  errorEqualFold: String
  errorContainsFold: String
  """
  error_size field predicates
  """
  errorSize: Int
  errorSizeNEQ: Int
  errorSizeIn: [Int!]
  errorSizeNotIn: [Int!]
  errorSizeGT: Int
  errorSizeGTE: Int
  errorSizeLT: Int
  errorSizeLTE: Int
  """
  exit_code field predicates
  """
  exitCode: Int
  exitCodeNEQ: Int
  exitCodeIn: [Int!]
  exitCodeNotIn: [Int!]
  exitCodeGT: Int
  exitCodeGTE: Int
  exitCodeLT: Int
  exitCodeLTE: Int
  exitCodeIsNil: Boolean
  exitCodeNotNil: Boolean
  """
  artifact_path field predicates
  """
  artifactPath: String
  artifactPathNEQ: String
  artifactPathIn: [String!]
  artifactPathNotIn: [String!]
  artifactPathGT: String
  artifactPathGTE: String
  artifactPathLT: String
  artifactPathLTE: String
  artifactPathContains: String
  artifactPathHasPrefix: String
  artifactPathHasSuffix: String
  artifactPathIsNil: Boolean
  artifactPathNotNil: Boolean
  artifactPathEqualFold: String
  artifactPathContainsFold: String
  """
  builder edge predicates
  """
  hasBuilder: Boolean
  hasBuilderWith: [BuilderWhereInput!]
  """
  artifact edge predicates
  """
  hasArtifact: Boolean
  hasArtifactWith: [AssetWhereInput!]
}
type Builder implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Unique identifier for the builder, embedded in its mTLS certificate CN.
  """
  identifier: String!
  """
  The platforms this builder can build agents for.
  """
  supportedTargets: [HostPlatform!]!
  """
  The server address that the builder should connect to.
  """
  upstream: String!
  """
  Timestamp of the builder's last ClaimBuildTasks call. Null if never seen.
  """
  lastSeenAt: Time
  buildTasks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for BuildTasks returned from the connection.
    """
    orderBy: [BuildTaskOrder!]

    """
    Filtering options for BuildTasks returned from the connection.
    """
    where: BuildTaskWhereInput
  ): BuildTaskConnection!
}
"""
A connection to a list of items.
"""
type BuilderConnection {
  """
  A list of edges.
  """
  edges: [BuilderEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type BuilderEdge {
  """
  The item at the end of the edge.
  """
  node: Builder
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Builder connections
"""
input BuilderOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Builders.
  """
  field: BuilderOrderField!
}
"""
Properties by which Builder connections can be ordered.
"""
enum BuilderOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_SEEN_AT
}
"""
BuilderWhereInput is used for filtering Builder objects.
Input was generated by ent.
"""
input BuilderWhereInput {
  not: BuilderWhereInput
  and: [BuilderWhereInput!]
  or: [BuilderWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  identifier field predicates
  """
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """
  upstream field predicates
  """
  upstream: String
  upstreamNEQ: String
  upstreamIn: [String!]
  upstreamNotIn: [String!]
  upstreamGT: String
  upstreamGTE: String
  upstreamLT: String
  upstreamLTE: String
  upstreamContains: String
  upstreamHasPrefix: String
  upstreamHasSuffix: String
  upstreamEqualFold: String
  upstreamContainsFold: String
  """
  last_seen_at field predicates
  """
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """
  build_tasks edge predicates
  """
  hasBuildTasks: Boolean
  hasBuildTasksWith: [BuildTaskWhereInput!]
}
"""
CreateBuilderInput is used for create Builder object.
Input was generated by ent.
"""
input CreateBuilderInput {
  """
  The platforms this builder can build agents for.
  """
  supportedTargets: [HostPlatform!]!
  """
  The server address that the builder should connect to.
  """
  upstream: String
}
"""
CreateHostCredentialInput is used for create HostCredential object.
Input was generated by ent.
"""
input CreateHostCredentialInput {
  """
  Identity associated with this credential (e.g. username).
  """
  principal: String!
  """
  Secret for this credential (e.g. password).
  """
  secret: String!
  """
  Kind of credential.
  """
  kind: HostCredentialKind!
  hostID: ID!
  taskID: ID
  shellTaskID: ID
}
"""
CreateLinkInput is used for create Link object.
Input was generated by ent.
"""
input CreateLinkInput {
  """
  Unique path for accessing the asset via the CDN
  """
  path: String
  """
  Timestamp before which the link is active. Default is MySQL minimum datetime (1000-01-01)
  """
  expiresAt: Time
  """
  Maximum number of times this link can be clicked before it becomes inactive (if set)
  """
  downloadLimit: Int
  """
  Number of times the asset has been downloaded using this Link.
  """
  downloads: Int
  assetID: ID!
}
"""
CreateQuestInput is used for create Quest object.
Input was generated by ent.
"""
input CreateQuestInput {
  """
  Name of the quest
  """
  name: String!
  """
  Value of parameters that were specified for the quest (as a JSON string).
  """
  parameters: String
  tomeID: ID!
}
"""
CreateRepositoryInput is used for create Repository object.
Input was generated by ent.
"""
input CreateRepositoryInput {
  """
  URL of the repository
  """
  url: String!
}
"""
CreateShellInput is used for create Shell object.
Input was generated by ent.
"""
input CreateShellInput {
  beaconID: ID!
}
"""
CreateTagInput is used for create Tag object.
Input was generated by ent.
"""
input CreateTagInput {
  """
  Name of the tag
  """
  name: String!
  """
  Describes the type of tag this is
  """
  kind: TagKind!
  hostIDs: [ID!]
}
"""
CreateTomeInput is used for create Tome object.
Input was generated by ent.
"""
input CreateTomeInput {
  """
  Name of the tome
  """
  name: String!
  """
  Information about the tome
  """
  description: String!
  """
  Name of the author who created the tome.
  """
  author: String!
  """
  Information about the tomes support model.
  """
  supportModel: TomeSupportModel
  """
  MITRE ATT&CK tactic provided by the tome.
  """
  tactic: TomeTactic
  """
  If true, this tome will automatically be queued for all new Beacon callbacks.
  """
  runOnNewBeaconCallback: Boolean
  """
  If true, this tome will automatically be queued for the first new callback on a Host.
  """
  runOnFirstHostCallback: Boolean
  """
  Cron-like schedule for this tome to be automatically queued.
  """
  runOnSchedule: String
  """
  JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter.
  """
  paramDefs: String
  """
  Eldritch script that will be executed when the tome is run
  """
  eldritch: String!
  assetIDs: [ID!]
  scheduledHostIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Host implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Unique identifier for the host. Unique to each host.
  """
  identifier: String!
  """
  A human readable identifier for the host.
  """
  name: String
  """
  Primary interface IP address reported by the agent.
  """
  primaryIP: String
  """
  Incoming IP from Proxy. Will return first proxy IP if multiple.
  """
  externalIP: String
  """
  Platform the agent is operating on.
  """
  platform: HostPlatform!
  """
  Timestamp of when a task was last claimed or updated for the host.
  """
  lastSeenAt: Time
  """
  Timestamp of when a task is next expected to be claimed or updated for the host.
  """
  nextSeenAt: Time
  tags(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tags returned from the connection.
    """
    orderBy: [TagOrder!]

    """
    Filtering options for Tags returned from the connection.
    """
    where: TagWhereInput
  ): TagConnection!
  beacons(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Beacons returned from the connection.
    """
    orderBy: [BeaconOrder!]

    """
    Filtering options for Beacons returned from the connection.
    """
    where: BeaconWhereInput
  ): BeaconConnection!
  files(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostFiles returned from the connection.
    """
    orderBy: [HostFileOrder!]

    """
    Filtering options for HostFiles returned from the connection.
    """
    where: HostFileWhereInput
  ): HostFileConnection!
  processes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostProcesses returned from the connection.
    """
    orderBy: [HostProcessOrder!]

    """
    Filtering options for HostProcesses returned from the connection.
    """
    where: HostProcessWhereInput
  ): HostProcessConnection!
  credentials(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostCredentials returned from the connection.
    """
    orderBy: [HostCredentialOrder!]

    """
    Filtering options for HostCredentials returned from the connection.
    """
    where: HostCredentialWhereInput
  ): HostCredentialConnection!
  screenshots(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Screenshots returned from the connection.
    """
    orderBy: [ScreenshotOrder!]

    """
    Filtering options for Screenshots returned from the connection.
    """
    where: ScreenshotWhereInput
  ): ScreenshotConnection!
}
"""
A connection to a list of items.
"""
type HostConnection {
  """
  A list of edges.
  """
  edges: [HostEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
type HostCredential implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Identity associated with this credential (e.g. username).
  """
  principal: String!
  """
  Secret for this credential (e.g. password).
  """
  secret: String!
  """
  Kind of credential.
  """
  kind: HostCredentialKind!
  """
  Host the credential was reported on.
  """
  host: Host!
  """
  Task that reported this credential.
  """
  task: Task
  """
  Shell Task that reported this credential.
  """
  shellTask: ShellTask
}
"""
A connection to a list of items.
"""
type HostCredentialConnection {
  """
  A list of edges.
  """
  edges: [HostCredentialEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type HostCredentialEdge {
  """
  The item at the end of the edge.
  """
  node: HostCredential
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
HostCredentialKind is enum for the field kind
"""
enum HostCredentialKind @goModel(model: "realm.pub/tavern/internal/c2/epb.Credential_Kind") {
  KIND_NTLM_HASH
  KIND_PASSWORD
  KIND_SSH_KEY
  KIND_UNSPECIFIED
}
"""
Ordering options for HostCredential connections
"""
input HostCredentialOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order HostCredentials.
  """
  field: HostCredentialOrderField!
}
"""
Properties by which HostCredential connections can be ordered.
"""
enum HostCredentialOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  PRINCIPAL
}
"""
HostCredentialWhereInput is used for filtering HostCredential objects.
Input was generated by ent.
"""
input HostCredentialWhereInput {
  not: HostCredentialWhereInput
  and: [HostCredentialWhereInput!]
  or: [HostCredentialWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  principal field predicates
  """
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalEqualFold: String
  principalContainsFold: String
  """
  secret field predicates
  """
  secret: String
  secretNEQ: String
  secretIn: [String!]
  secretNotIn: [String!]
  secretGT: String
  secretGTE: String
  secretLT: String
  secretLTE: String
  secretContains: String
  secretHasPrefix: String
  secretHasSuffix: String
  secretEqualFold: String
  secretContainsFold: String
  """
  kind field predicates
  """
  kind: HostCredentialKind
  kindNEQ: HostCredentialKind
  kindIn: [HostCredentialKind!]
  kindNotIn: [HostCredentialKind!]
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
  """
  shell_task edge predicates
  """
  hasShellTask: Boolean
  hasShellTaskWith: [ShellTaskWhereInput!]
}
"""
An edge in a connection.
"""
type HostEdge {
  """
  The item at the end of the edge.
  """
  node: Host
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
type HostFile implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Path to the file on the host system.
  """
  path: String!
  """
  User who owns the file on the host system.
  """
  owner: String
  """
  Group who owns the file on the host system.
  """
  group: String
  """
  Permissions for the file on the host system.
  """
  permissions: String
  """
  The size of the file in bytes
  """
  size: Uint64!
  """
  A SHA3-256 digest of the content field
  """
  hash: String
  """
  The type of preview available for the file
  """
  previewType: HostFilePreviewType!
  """
  A preview of the file content (max 512kb)
  """
  preview: String
  """
  Host the file was reported on.
  """
  host: Host!
  """
  Task that reported this file.
  """
  task: Task
  """
  Shell Task that reported this file.
  """
  shellTask: ShellTask
}
"""
A connection to a list of items.
"""
type HostFileConnection {
  """
  A list of edges.
  """
  edges: [HostFileEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type HostFileEdge {
  """
  The item at the end of the edge.
  """
  node: HostFile
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for HostFile connections
"""
input HostFileOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order HostFiles.
  """
  field: HostFileOrderField!
}
"""
Properties by which HostFile connections can be ordered.
"""
enum HostFileOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
HostFilePreviewType is enum for the field preview_type
"""
enum HostFilePreviewType @goModel(model: "realm.pub/tavern/internal/ent/hostfile.PreviewType") {
  TEXT
  NONE
}
"""
HostFileWhereInput is used for filtering HostFile objects.
Input was generated by ent.
"""
input HostFileWhereInput {
  not: HostFileWhereInput
  and: [HostFileWhereInput!]
  or: [HostFileWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  path field predicates
  """
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathEqualFold: String
  pathContainsFold: String
  """
  owner field predicates
  """
  owner: String
  ownerNEQ: String
  ownerIn: [String!]
  ownerNotIn: [String!]
  ownerGT: String
  ownerGTE: String
  ownerLT: String
  ownerLTE: String
  ownerContains: String
  ownerHasPrefix: String
  ownerHasSuffix: String
  ownerIsNil: Boolean
  ownerNotNil: Boolean
  ownerEqualFold: String
  ownerContainsFold: String
  """
  group field predicates
  """
  group: String
  groupNEQ: String
  groupIn: [String!]
  groupNotIn: [String!]
  groupGT: String
  groupGTE: String
  groupLT: String
  groupLTE: String
  groupContains: String
  groupHasPrefix: String
  groupHasSuffix: String
  groupIsNil: Boolean
  groupNotNil: Boolean
  groupEqualFold: String
  groupContainsFold: String
  """
  permissions field predicates
  """
  permissions: String
  permissionsNEQ: String
  permissionsIn: [String!]
  permissionsNotIn: [String!]
  permissionsGT: String
  permissionsGTE: String
  permissionsLT: String
  permissionsLTE: String
  permissionsContains: String
  permissionsHasPrefix: String
  permissionsHasSuffix: String
  permissionsIsNil: Boolean
  permissionsNotNil: Boolean
  permissionsEqualFold: String
  permissionsContainsFold: String
  """
  size field predicates
  """
  size: Uint64
  sizeNEQ: Uint64
  sizeIn: [Uint64!]
  sizeNotIn: [Uint64!]
  sizeGT: Uint64
  sizeGTE: Uint64
  sizeLT: Uint64
  sizeLTE: Uint64
  """
  hash field predicates
  """
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashIsNil: Boolean
  hashNotNil: Boolean
  hashEqualFold: String
  hashContainsFold: String
  """
  preview_type field predicates
  """
  previewType: HostFilePreviewType
  previewTypeNEQ: HostFilePreviewType
  previewTypeIn: [HostFilePreviewType!]
  previewTypeNotIn: [HostFilePreviewType!]
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
  """
  shell_task edge predicates
  """
  hasShellTask: Boolean
  hasShellTaskWith: [ShellTaskWhereInput!]
}
"""
Ordering options for Host connections
"""
input HostOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Hosts.
  """
  field: HostOrderField!
}
"""
Properties by which Host connections can be ordered.
"""
enum HostOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_SEEN_AT
  NEXT_SEEN_AT
}
"""
HostPlatform is enum for the field target_os
"""
enum HostPlatform @goModel(model: "realm.pub/tavern/internal/c2/c2pb.Host_Platform") {
  PLATFORM_BSD
  PLATFORM_LINUX
  PLATFORM_MACOS
  PLATFORM_UNSPECIFIED
  PLATFORM_WINDOWS
}
type HostProcess implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  ID of the process.
  """
  pid: Uint64!
  """
  ID of the parent process.
  """
  ppid: Uint64!
  """
  The name of the process.
  """
  name: String!
  """
  The user the process is running as.
  """
  principal: String!
  """
  The path to the process executable.
  """
  path: String
  """
  The command used to execute the process.
  """
  cmd: String
  """
  The environment variables set for the process.
  """
  env: String
  """
  The current working directory for the process.
  """
  cwd: String
  """
  Current process status.
  """
  status: HostProcessStatus!
  """
  Host the process was reported on.
  """
  host: Host!
  """
  Task that reported this process.
  """
  task: Task
  """
  Shell Task that reported this process.
  """
  shellTask: ShellTask
}
"""
A connection to a list of items.
"""
type HostProcessConnection {
  """
  A list of edges.
  """
  edges: [HostProcessEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type HostProcessEdge {
  """
  The item at the end of the edge.
  """
  node: HostProcess
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for HostProcess connections
"""
input HostProcessOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order HostProcesses.
  """
  field: HostProcessOrderField!
}
"""
Properties by which HostProcess connections can be ordered.
"""
enum HostProcessOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  PROCESS_ID
  PARENT_PROCESS_ID
  NAME
}
"""
HostProcessStatus is enum for the field status
"""
enum HostProcessStatus @goModel(model: "realm.pub/tavern/internal/c2/epb.Process_Status") {
  STATUS_DEAD
  STATUS_IDLE
  STATUS_LOCK_BLOCKED
  STATUS_PARKED
  STATUS_RUN
  STATUS_SLEEP
  STATUS_STOP
  STATUS_TRACING
  STATUS_UNINTERRUPTIBLE_DISK_SLEEP
  STATUS_UNKNOWN
  STATUS_UNSPECIFIED
  STATUS_WAKE_KILL
  STATUS_WAKING
  STATUS_ZOMBIE
}
"""
HostProcessWhereInput is used for filtering HostProcess objects.
Input was generated by ent.
"""
input HostProcessWhereInput {
  not: HostProcessWhereInput
  and: [HostProcessWhereInput!]
  or: [HostProcessWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  pid field predicates
  """
  pid: Uint64
  pidNEQ: Uint64
  pidIn: [Uint64!]
  pidNotIn: [Uint64!]
  pidGT: Uint64
  pidGTE: Uint64
  pidLT: Uint64
  pidLTE: Uint64
  """
  ppid field predicates
  """
  ppid: Uint64
  ppidNEQ: Uint64
  ppidIn: [Uint64!]
  ppidNotIn: [Uint64!]
  ppidGT: Uint64
  ppidGTE: Uint64
  ppidLT: Uint64
  ppidLTE: Uint64
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  principal field predicates
  """
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalEqualFold: String
  principalContainsFold: String
  """
  path field predicates
  """
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathIsNil: Boolean
  pathNotNil: Boolean
  pathEqualFold: String
  pathContainsFold: String
  """
  cmd field predicates
  """
  cmd: String
  cmdNEQ: String
  cmdIn: [String!]
  cmdNotIn: [String!]
  cmdGT: String
  cmdGTE: String
  cmdLT: String
  cmdLTE: String
  cmdContains: String
  cmdHasPrefix: String
  cmdHasSuffix: String
  cmdIsNil: Boolean
  cmdNotNil: Boolean
  cmdEqualFold: String
  cmdContainsFold: String
  """
  env field predicates
  """
  env: String
  envNEQ: String
  envIn: [String!]
  envNotIn: [String!]
  envGT: String
  envGTE: String
  envLT: String
  envLTE: String
  envContains: String
  envHasPrefix: String
  envHasSuffix: String
  envIsNil: Boolean
  envNotNil: Boolean
  envEqualFold: String
  envContainsFold: String
  """
  cwd field predicates
  """
  cwd: String
  cwdNEQ: String
  cwdIn: [String!]
  cwdNotIn: [String!]
  cwdGT: String
  cwdGTE: String
  cwdLT: String
  cwdLTE: String
  cwdContains: String
  cwdHasPrefix: String
  cwdHasSuffix: String
  cwdIsNil: Boolean
  cwdNotNil: Boolean
  cwdEqualFold: String
  cwdContainsFold: String
  """
  status field predicates
  """
  status: HostProcessStatus
  statusNEQ: HostProcessStatus
  statusIn: [HostProcessStatus!]
  statusNotIn: [HostProcessStatus!]
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
  """
  shell_task edge predicates
  """
  hasShellTask: Boolean
  hasShellTaskWith: [ShellTaskWhereInput!]
}
"""
HostWhereInput is used for filtering Host objects.
Input was generated by ent.
"""
input HostWhereInput {
  not: HostWhereInput
  and: [HostWhereInput!]
  or: [HostWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  identifier field predicates
  """
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """
  primary_ip field predicates
  """
  primaryIP: String
  primaryIPNEQ: String
  primaryIPIn: [String!]
  primaryIPNotIn: [String!]
  primaryIPGT: String
  primaryIPGTE: String
  primaryIPLT: String
  primaryIPLTE: String
  primaryIPContains: String
  primaryIPHasPrefix: String
  primaryIPHasSuffix: String
  primaryIPIsNil: Boolean
  primaryIPNotNil: Boolean
  primaryIPEqualFold: String
  primaryIPContainsFold: String
  """
  external_ip field predicates
  """
  externalIP: String
  externalIPNEQ: String
  externalIPIn: [String!]
  externalIPNotIn: [String!]
  externalIPGT: String
  externalIPGTE: String
  externalIPLT: String
  externalIPLTE: String
  externalIPContains: String
  externalIPHasPrefix: String
  externalIPHasSuffix: String
  externalIPIsNil: Boolean
  externalIPNotNil: Boolean
  externalIPEqualFold: String
  externalIPContainsFold: String
  """
  platform field predicates
  """
  platform: HostPlatform
  platformNEQ: HostPlatform
  platformIn: [HostPlatform!]
  platformNotIn: [HostPlatform!]
  """
  last_seen_at field predicates
  """
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """
  next_seen_at field predicates
  """
  nextSeenAt: Time
  nextSeenAtNEQ: Time
  nextSeenAtIn: [Time!]
  nextSeenAtNotIn: [Time!]
  nextSeenAtGT: Time
  nextSeenAtGTE: Time
  nextSeenAtLT: Time
  nextSeenAtLTE: Time
  nextSeenAtIsNil: Boolean
  nextSeenAtNotNil: Boolean
  """
  tags edge predicates
  """
  hasTags: Boolean
  hasTagsWith: [TagWhereInput!]
  """
  beacons edge predicates
  """
  hasBeacons: Boolean
  hasBeaconsWith: [BeaconWhereInput!]
  """
  files edge predicates
  """
  hasFiles: Boolean
  hasFilesWith: [HostFileWhereInput!]
  """
  processes edge predicates
  """
  hasProcesses: Boolean
  hasProcessesWith: [HostProcessWhereInput!]
  """
  credentials edge predicates
  """
  hasCredentials: Boolean
  hasCredentialsWith: [HostCredentialWhereInput!]
  """
  screenshots edge predicates
  """
  hasScreenshots: Boolean
  hasScreenshotsWith: [ScreenshotWhereInput!]
}
type Link implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Unique path for accessing the asset via the CDN
  """
  path: String!
  """
  Timestamp before which the link is active. Default is MySQL minimum datetime (1000-01-01)
  """
  expiresAt: Time!
  """
  Maximum number of times this link can be clicked before it becomes inactive (if set)
  """
  downloadLimit: Int
  """
  Number of times the asset has been downloaded using this Link.
  """
  downloads: Int!
  """
  The asset that this link points to
  """
  asset: Asset!
  """
  User that created the Link if available.
  """
  creator: User
}
"""
A connection to a list of items.
"""
type LinkConnection {
  """
  A list of edges.
  """
  edges: [LinkEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type LinkEdge {
  """
  The item at the end of the edge.
  """
  node: Link
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Link connections
"""
input LinkOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Links.
  """
  field: LinkOrderField!
}
"""
Properties by which Link connections can be ordered.
"""
enum LinkOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  PATH
  EXPIRES_AT
  DOWNLOAD_LIMIT
  DOWNLOADS
}
"""
LinkWhereInput is used for filtering Link objects.
Input was generated by ent.
"""
input LinkWhereInput {
  not: LinkWhereInput
  and: [LinkWhereInput!]
  or: [LinkWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  path field predicates
  """
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathEqualFold: String
  pathContainsFold: String
  """
  expires_at field predicates
  """
  expiresAt: Time
  expiresAtNEQ: Time
  expiresAtIn: [Time!]
  expiresAtNotIn: [Time!]
  expiresAtGT: Time
  expiresAtGTE: Time
  expiresAtLT: Time
  expiresAtLTE: Time
  """
  download_limit field predicates
  """
  downloadLimit: Int
  downloadLimitNEQ: Int
  downloadLimitIn: [Int!]
  downloadLimitNotIn: [Int!]
  downloadLimitGT: Int
  downloadLimitGTE: Int
  downloadLimitLT: Int
  downloadLimitLTE: Int
  downloadLimitIsNil: Boolean
  downloadLimitNotNil: Boolean
  """
  downloads field predicates
  """
  downloads: Int
  downloadsNEQ: Int
  downloadsIn: [Int!]
  downloadsNotIn: [Int!]
  downloadsGT: Int
  downloadsGTE: Int
  downloadsLT: Int
  downloadsLTE: Int
  """
  asset edge predicates
  """
  hasAsset: Boolean
  hasAssetWith: [AssetWhereInput!]
  """
  creator edge predicates
  """
  hasCreator: Boolean
  hasCreatorWith: [UserWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "realm.pub/tavern/internal/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Portal implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Timestamp of when this portal was closed
  """
  closedAt: Time
  """
  Task that created the portal
  """
  task: Task
  """
  ShellTask that created the portal (if applicable)
  """
  shellTask: ShellTask
  """
  Beacon that created the portal
  """
  beacon: Beacon!
  """
  User that created the portal
  """
  owner: User!
  activeUsers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
}
"""
A connection to a list of items.
"""
type PortalConnection {
  """
  A list of edges.
  """
  edges: [PortalEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type PortalEdge {
  """
  The item at the end of the edge.
  """
  node: Portal
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Portal connections
"""
input PortalOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Portals.
  """
  field: PortalOrderField!
}
"""
Properties by which Portal connections can be ordered.
"""
enum PortalOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLOSED_AT
}
"""
PortalWhereInput is used for filtering Portal objects.
Input was generated by ent.
"""
input PortalWhereInput {
  not: PortalWhereInput
  and: [PortalWhereInput!]
  or: [PortalWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  closed_at field predicates
  """
  closedAt: Time
  closedAtNEQ: Time
  closedAtIn: [Time!]
  closedAtNotIn: [Time!]
  closedAtGT: Time
  closedAtGTE: Time
  closedAtLT: Time
  closedAtLTE: Time
  closedAtIsNil: Boolean
  closedAtNotNil: Boolean
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
  """
  shell_task edge predicates
  """
  hasShellTask: Boolean
  hasShellTaskWith: [ShellTaskWhereInput!]
  """
  beacon edge predicates
  """
  hasBeacon: Boolean
  hasBeaconWith: [BeaconWhereInput!]
  """
  owner edge predicates
  """
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
  """
  active_users edge predicates
  """
  hasActiveUsers: Boolean
  hasActiveUsersWith: [UserWhereInput!]
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
}
type Quest implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Name of the quest
  """
  name: String!
  """
  Value of parameters that were specified for the quest (as a JSON string).
  """
  parameters: String
  """
  JSON string describing what parameters are used with the tome at the time of this quest creation. Requires a list of JSON objects, one for each parameter.
  """
  paramDefsAtCreation: String
  """
  Eldritch script that was evaluated at the time of this quest creation.
  """
  eldritchAtCreation: String
  """
  Tome that this quest will be executing
  """
  tome: Tome!
  """
  Bundle asset that the executing tome depends on (if any)
  """
  bundle: Asset
  tasks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tasks returned from the connection.
    """
    orderBy: [TaskOrder!]

    """
    Filtering options for Tasks returned from the connection.
    """
    where: TaskWhereInput
  ): TaskConnection!
  """
  User that created the quest if available.
  """
  creator: User
}
"""
A connection to a list of items.
"""
type QuestConnection {
  """
  A list of edges.
  """
  edges: [QuestEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type QuestEdge {
  """
  The item at the end of the edge.
  """
  node: Quest
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Quest connections
"""
input QuestOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Quests.
  """
  field: QuestOrderField!
}
"""
Properties by which Quest connections can be ordered.
"""
enum QuestOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
QuestWhereInput is used for filtering Quest objects.
Input was generated by ent.
"""
input QuestWhereInput {
  not: QuestWhereInput
  and: [QuestWhereInput!]
  or: [QuestWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  parameters field predicates
  """
  parameters: String
  parametersNEQ: String
  parametersIn: [String!]
  parametersNotIn: [String!]
  parametersGT: String
  parametersGTE: String
  parametersLT: String
  parametersLTE: String
  parametersContains: String
  parametersHasPrefix: String
  parametersHasSuffix: String
  parametersIsNil: Boolean
  parametersNotNil: Boolean
  parametersEqualFold: String
  parametersContainsFold: String
  """
  param_defs_at_creation field predicates
  """
  paramDefsAtCreation: String
  paramDefsAtCreationNEQ: String
  paramDefsAtCreationIn: [String!]
  paramDefsAtCreationNotIn: [String!]
  paramDefsAtCreationGT: String
  paramDefsAtCreationGTE: String
  paramDefsAtCreationLT: String
  paramDefsAtCreationLTE: String
  paramDefsAtCreationContains: String
  paramDefsAtCreationHasPrefix: String
  paramDefsAtCreationHasSuffix: String
  paramDefsAtCreationIsNil: Boolean
  paramDefsAtCreationNotNil: Boolean
  paramDefsAtCreationEqualFold: String
  paramDefsAtCreationContainsFold: String
  """
  eldritch_at_creation field predicates
  """
  eldritchAtCreation: String
  eldritchAtCreationNEQ: String
  eldritchAtCreationIn: [String!]
  eldritchAtCreationNotIn: [String!]
  eldritchAtCreationGT: String
  eldritchAtCreationGTE: String
  eldritchAtCreationLT: String
  eldritchAtCreationLTE: String
  eldritchAtCreationContains: String
  eldritchAtCreationHasPrefix: String
  eldritchAtCreationHasSuffix: String
  eldritchAtCreationIsNil: Boolean
  eldritchAtCreationNotNil: Boolean
  eldritchAtCreationEqualFold: String
  eldritchAtCreationContainsFold: String
  """
  tome edge predicates
  """
  hasTome: Boolean
  hasTomeWith: [TomeWhereInput!]
  """
  bundle edge predicates
  """
  hasBundle: Boolean
  hasBundleWith: [AssetWhereInput!]
  """
  tasks edge predicates
  """
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
  """
  creator edge predicates
  """
  hasCreator: Boolean
  hasCreatorWith: [UserWhereInput!]
}
type Repository implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  URL of the repository
  """
  url: String!
  """
  Public key associated with this repositories private key
  """
  publicKey: String!
  """
  Timestamp of when this repo was last imported
  """
  lastImportedAt: Time
  tomes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tomes returned from the connection.
    """
    orderBy: [TomeOrder!]

    """
    Filtering options for Tomes returned from the connection.
    """
    where: TomeWhereInput
  ): TomeConnection!
  """
  User that created this repository.
  """
  owner: User
}
"""
A connection to a list of items.
"""
type RepositoryConnection {
  """
  A list of edges.
  """
  edges: [RepositoryEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type RepositoryEdge {
  """
  The item at the end of the edge.
  """
  node: Repository
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Repository connections
"""
input RepositoryOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Repositories.
  """
  field: RepositoryOrderField!
}
"""
Properties by which Repository connections can be ordered.
"""
enum RepositoryOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  LAST_IMPORTED_AT
}
"""
RepositoryWhereInput is used for filtering Repository objects.
Input was generated by ent.
"""
input RepositoryWhereInput {
  not: RepositoryWhereInput
  and: [RepositoryWhereInput!]
  or: [RepositoryWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  url field predicates
  """
  url: String
  urlNEQ: String
  urlIn: [String!]
  urlNotIn: [String!]
  urlGT: String
  urlGTE: String
  urlLT: String
  urlLTE: String
  urlContains: String
  urlHasPrefix: String
  urlHasSuffix: String
  urlEqualFold: String
  urlContainsFold: String
  """
  public_key field predicates
  """
  publicKey: String
  publicKeyNEQ: String
  publicKeyIn: [String!]
  publicKeyNotIn: [String!]
  publicKeyGT: String
  publicKeyGTE: String
  publicKeyLT: String
  publicKeyLTE: String
  publicKeyContains: String
  publicKeyHasPrefix: String
  publicKeyHasSuffix: String
  publicKeyEqualFold: String
  publicKeyContainsFold: String
  """
  last_imported_at field predicates
  """
  lastImportedAt: Time
  lastImportedAtNEQ: Time
  lastImportedAtIn: [Time!]
  lastImportedAtNotIn: [Time!]
  lastImportedAtGT: Time
  lastImportedAtGTE: Time
  lastImportedAtLT: Time
  lastImportedAtLTE: Time
  lastImportedAtIsNil: Boolean
  lastImportedAtNotNil: Boolean
  """
  tomes edge predicates
  """
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
  """
  owner edge predicates
  """
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
}
type Screenshot implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Name of the screenshot file (e.g. screenshot_<hostname>_<timestamp>_<monitor>.png).
  """
  name: String!
  """
  The size of the screenshot in bytes
  """
  size: Uint64!
  """
  A SHA3-256 digest of the content field
  """
  hash: String
  """
  Host the screenshot was taken on.
  """
  host: Host!
  """
  Task that reported this screenshot.
  """
  task: Task
  """
  Shell Task that reported this screenshot.
  """
  shellTask: ShellTask
}
"""
A connection to a list of items.
"""
type ScreenshotConnection {
  """
  A list of edges.
  """
  edges: [ScreenshotEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ScreenshotEdge {
  """
  The item at the end of the edge.
  """
  node: Screenshot
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Screenshot connections
"""
input ScreenshotOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Screenshots.
  """
  field: ScreenshotOrderField!
}
"""
Properties by which Screenshot connections can be ordered.
"""
enum ScreenshotOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
ScreenshotWhereInput is used for filtering Screenshot objects.
Input was generated by ent.
"""
input ScreenshotWhereInput {
  not: ScreenshotWhereInput
  and: [ScreenshotWhereInput!]
  or: [ScreenshotWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  size field predicates
  """
  size: Uint64
  sizeNEQ: Uint64
  sizeIn: [Uint64!]
  sizeNotIn: [Uint64!]
  sizeGT: Uint64
  sizeGTE: Uint64
  sizeLT: Uint64
  sizeLTE: Uint64
  """
  hash field predicates
  """
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashIsNil: Boolean
  hashNotNil: Boolean
  hashEqualFold: String
  hashContainsFold: String
  """
  host edge predicates
  """
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
  """
  shell_task edge predicates
  """
  hasShellTask: Boolean
  hasShellTaskWith: [ShellTaskWhereInput!]
}
type Shell implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Timestamp of when this shell was closed
  """
  closedAt: Time
  """
  Task that created the shell
  """
  task: Task
  """
  Beacon that created the shell
  """
  beacon: Beacon!
  """
  User that created the shell
  """
  owner: User!
  """
  Portals associated with this shell
  """
  portals: [Portal!]
  activeUsers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
  shellTasks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for ShellTasks returned from the connection.
    """
    orderBy: [ShellTaskOrder!]

    """
    Filtering options for ShellTasks returned from the connection.
    """
    where: ShellTaskWhereInput
  ): ShellTaskConnection!
}
"""
A connection to a list of items.
"""
type ShellConnection {
  """
  A list of edges.
  """
  edges: [ShellEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ShellEdge {
  """
  The item at the end of the edge.
  """
  node: Shell
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Shell connections
"""
input ShellOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Shells.
  """
  field: ShellOrderField!
}
"""
Properties by which Shell connections can be ordered.
"""
enum ShellOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLOSED_AT
}
type ShellTask implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  The command input sent to the shell
  """
  input: String!
  """
  Any output received from the shell
  """
  output: String
  """
  Any error received from the shell
  """
  error: String
  """
  Unique identifier for the stream that created this shell task (likely a websocket uuid)
  """
  streamID: String!
  """
  Sequence number for ordering tasks within the same stream_id
  """
  sequenceID: Int!
  """
  Timestamp of when the task was claimed, null if not yet claimed
  """
  claimedAt: Time
  """
  Timestamp of when execution of the task started, null if not yet started
  """
  execStartedAt: Time
  """
  Timestamp of when execution of the task finished, null if not yet finished
  """
  execFinishedAt: Time
  """
  The shell this task belongs to
  """
  shell: Shell!
  """
  The user who created this ShellTask
  """
  creator: User!
  """
  Credentials reported by this shell task
  """
  reportedCredentials: [HostCredential!]
  """
  Files reported by this shell task
  """
  reportedFiles: [HostFile!]
  """
  Processes reported by this shell task
  """
  reportedProcesses: [HostProcess!]
  """
  Screenshots reported by this shell task
  """
  screenshots: [Screenshot!]
}
"""
A connection to a list of items.
"""
type ShellTaskConnection {
  """
  A list of edges.
  """
  edges: [ShellTaskEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ShellTaskEdge {
  """
  The item at the end of the edge.
  """
  node: ShellTask
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for ShellTask connections
"""
input ShellTaskOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order ShellTasks.
  """
  field: ShellTaskOrderField!
}
"""
Properties by which ShellTask connections can be ordered.
"""
enum ShellTaskOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLAIMED_AT
  EXEC_STARTED_AT
  EXEC_FINISHED_AT
}
"""
ShellTaskWhereInput is used for filtering ShellTask objects.
Input was generated by ent.
"""
input ShellTaskWhereInput {
  not: ShellTaskWhereInput
  and: [ShellTaskWhereInput!]
  or: [ShellTaskWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  input field predicates
  """
  input: String
  inputNEQ: String
  inputIn: [String!]
  inputNotIn: [String!]
  inputGT: String
  inputGTE: String
  inputLT: String
  inputLTE: String
  inputContains: String
  inputHasPrefix: String
  inputHasSuffix: String
  inputEqualFold: String
  inputContainsFold: String
  """
  output field predicates
  """
  output: String
  outputNEQ: String
  outputIn: [String!]
  outputNotIn: [String!]
  outputGT: String
  outputGTE: String
  outputLT: String
  outputLTE: String
  outputContains: String
  outputHasPrefix: String
  outputHasSuffix: String
  outputIsNil: Boolean
  outputNotNil: Boolean
  outputEqualFold: String
  outputContainsFold: String
  """
  error field predicates
  """
  error: String
  errorNEQ: String
  errorIn: [String!]
  errorNotIn: [String!]
  errorGT: String
  errorGTE: String
  errorLT: String
  errorLTE: String
  errorContains: String
  errorHasPrefix: String
  errorHasSuffix: String
  errorIsNil: Boolean
  errorNotNil: Boolean
  errorEqualFold: String
  errorContainsFold: String
  """
  stream_id field predicates
  """
  streamID: String
  streamIDNEQ: String
  streamIDIn: [String!]
  streamIDNotIn: [String!]
  streamIDGT: String
  streamIDGTE: String
  streamIDLT: String
  streamIDLTE: String
  streamIDContains: String
  streamIDHasPrefix: String
  streamIDHasSuffix: String
  streamIDEqualFold: String
  streamIDContainsFold: String
  """
  sequence_id field predicates
  """
  sequenceID: Int
  sequenceIDNEQ: Int
  sequenceIDIn: [Int!]
  sequenceIDNotIn: [Int!]
  sequenceIDGT: Int
  sequenceIDGTE: Int
  sequenceIDLT: Int
  sequenceIDLTE: Int
  """
  claimed_at field predicates
  """
  claimedAt: Time
  claimedAtNEQ: Time
  claimedAtIn: [Time!]
  claimedAtNotIn: [Time!]
  claimedAtGT: Time
  claimedAtGTE: Time
  claimedAtLT: Time
  claimedAtLTE: Time
  claimedAtIsNil: Boolean
  claimedAtNotNil: Boolean
  """
  exec_started_at field predicates
  """
  execStartedAt: Time
  execStartedAtNEQ: Time
  execStartedAtIn: [Time!]
  execStartedAtNotIn: [Time!]
  execStartedAtGT: Time
  execStartedAtGTE: Time
  execStartedAtLT: Time
  execStartedAtLTE: Time
  execStartedAtIsNil: Boolean
  execStartedAtNotNil: Boolean
  """
  exec_finished_at field predicates
  """
  execFinishedAt: Time
  execFinishedAtNEQ: Time
  execFinishedAtIn: [Time!]
  execFinishedAtNotIn: [Time!]
  execFinishedAtGT: Time
  execFinishedAtGTE: Time
  execFinishedAtLT: Time
  execFinishedAtLTE: Time
  execFinishedAtIsNil: Boolean
  execFinishedAtNotNil: Boolean
  """
  shell edge predicates
  """
  hasShell: Boolean
  hasShellWith: [ShellWhereInput!]
  """
  creator edge predicates
  """
  hasCreator: Boolean
  hasCreatorWith: [UserWhereInput!]
  """
  reported_credentials edge predicates
  """
  hasReportedCredentials: Boolean
  hasReportedCredentialsWith: [HostCredentialWhereInput!]
  """
  reported_files edge predicates
  """
  hasReportedFiles: Boolean
  hasReportedFilesWith: [HostFileWhereInput!]
  """
  reported_processes edge predicates
  """
  hasReportedProcesses: Boolean
  hasReportedProcessesWith: [HostProcessWhereInput!]
  """
  screenshots edge predicates
  """
  hasScreenshots: Boolean
  hasScreenshotsWith: [ScreenshotWhereInput!]
}
"""
ShellWhereInput is used for filtering Shell objects.
Input was generated by ent.
"""
input ShellWhereInput {
  not: ShellWhereInput
  and: [ShellWhereInput!]
  or: [ShellWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  closed_at field predicates
  """
  closedAt: Time
  closedAtNEQ: Time
  closedAtIn: [Time!]
  closedAtNotIn: [Time!]
  closedAtGT: Time
  closedAtGTE: Time
  closedAtLT: Time
  closedAtLTE: Time
  closedAtIsNil: Boolean
  closedAtNotNil: Boolean
  """
  task edge predicates
  """
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
  """
  beacon edge predicates
  """
  hasBeacon: Boolean
  hasBeaconWith: [BeaconWhereInput!]
  """
  owner edge predicates
  """
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
  """
  portals edge predicates
  """
  hasPortals: Boolean
  hasPortalsWith: [PortalWhereInput!]
  """
  active_users edge predicates
  """
  hasActiveUsers: Boolean
  hasActiveUsersWith: [UserWhereInput!]
  """
  shell_tasks edge predicates
  """
  hasShellTasks: Boolean
  hasShellTasksWith: [ShellTaskWhereInput!]
}
type Tag implements Node {
  id: ID!
  """
  Name of the tag
  """
  name: String!
  """
  Describes the type of tag this is
  """
  kind: TagKind!
  hosts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Hosts returned from the connection.
    """
    orderBy: [HostOrder!]

    """
    Filtering options for Hosts returned from the connection.
    """
    where: HostWhereInput
  ): HostConnection!
}
"""
A connection to a list of items.
"""
type TagConnection {
  """
  A list of edges.
  """
  edges: [TagEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type TagEdge {
  """
  The item at the end of the edge.
  """
  node: Tag
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
TagKind is enum for the field kind
"""
enum TagKind @goModel(model: "realm.pub/tavern/internal/ent/tag.Kind") {
  group
  service
}
"""
Ordering options for Tag connections
"""
input TagOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Tags.
  """
  field: TagOrderField!
}
"""
Properties by which Tag connections can be ordered.
"""
enum TagOrderField {
  NAME
}
"""
TagWhereInput is used for filtering Tag objects.
Input was generated by ent.
"""
input TagWhereInput {
  not: TagWhereInput
  and: [TagWhereInput!]
  or: [TagWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  kind field predicates
  """
  kind: TagKind
  kindNEQ: TagKind
  kindIn: [TagKind!]
  kindNotIn: [TagKind!]
  """
  hosts edge predicates
  """
  hasHosts: Boolean
  hasHostsWith: [HostWhereInput!]
}
type Task implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Timestamp of when the task was claimed, null if not yet claimed
  """
  claimedAt: Time
  """
  Timestamp of when execution of the task started, null if not yet started
  """
  execStartedAt: Time
  """
  Timestamp of when execution of the task finished, null if not yet finished
  """
  execFinishedAt: Time
  """
  Output from executing the task
  """
  output: String
  """
  The size of the output in bytes
  """
  outputSize: Int!
  """
  Error, if any, produced while executing the Task
  """
  error: String
  quest: Quest!
  beacon: Beacon!
  reportedFiles(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostFiles returned from the connection.
    """
    orderBy: [HostFileOrder!]

    """
    Filtering options for HostFiles returned from the connection.
    """
    where: HostFileWhereInput
  ): HostFileConnection!
  reportedProcesses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostProcesses returned from the connection.
    """
    orderBy: [HostProcessOrder!]

    """
    Filtering options for HostProcesses returned from the connection.
    """
    where: HostProcessWhereInput
  ): HostProcessConnection!
  reportedCredentials(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for HostCredentials returned from the connection.
    """
    orderBy: [HostCredentialOrder!]

    """
    Filtering options for HostCredentials returned from the connection.
    """
    where: HostCredentialWhereInput
  ): HostCredentialConnection!
  shells(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Shells returned from the connection.
    """
    orderBy: [ShellOrder!]

    """
    Filtering options for Shells returned from the connection.
    """
    where: ShellWhereInput
  ): ShellConnection!
  screenshots(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Screenshots returned from the connection.
    """
    orderBy: [ScreenshotOrder!]

    """
    Filtering options for Screenshots returned from the connection.
    """
    where: ScreenshotWhereInput
  ): ScreenshotConnection!
}
"""
A connection to a list of items.
"""
type TaskConnection {
  """
  A list of edges.
  """
  edges: [TaskEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type TaskEdge {
  """
  The item at the end of the edge.
  """
  node: Task
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Task connections
"""
input TaskOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Tasks.
  """
  field: TaskOrderField!
}
"""
Properties by which Task connections can be ordered.
"""
enum TaskOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLAIMED_AT
  EXEC_STARTED_AT
  EXEC_FINISHED_AT
  OUTPUT_SIZE
}
"""
TaskWhereInput is used for filtering Task objects.
Input was generated by ent.
"""
input TaskWhereInput {
  not: TaskWhereInput
  and: [TaskWhereInput!]
  or: [TaskWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  claimed_at field predicates
  """
  claimedAt: Time
  claimedAtNEQ: Time
  claimedAtIn: [Time!]
  claimedAtNotIn: [Time!]
  claimedAtGT: Time
  claimedAtGTE: Time
  claimedAtLT: Time
  claimedAtLTE: Time
  claimedAtIsNil: Boolean
  claimedAtNotNil: Boolean
  """
  exec_started_at field predicates
  """
  execStartedAt: Time
  execStartedAtNEQ: Time
  execStartedAtIn: [Time!]
  execStartedAtNotIn: [Time!]
  execStartedAtGT: Time
  execStartedAtGTE: Time
  execStartedAtLT: Time
  execStartedAtLTE: Time
  execStartedAtIsNil: Boolean
  execStartedAtNotNil: Boolean
  """
  exec_finished_at field predicates
  """
  execFinishedAt: Time
  execFinishedAtNEQ: Time
  execFinishedAtIn: [Time!]
  execFinishedAtNotIn: [Time!]
  execFinishedAtGT: Time
  execFinishedAtGTE: Time
  execFinishedAtLT: Time
  execFinishedAtLTE: Time
  execFinishedAtIsNil: Boolean
  execFinishedAtNotNil: Boolean
  """
  output field predicates
  """
  output: String
  outputNEQ: String
  outputIn: [String!]
  outputNotIn: [String!]
  outputGT: String
  outputGTE: String
  outputLT: String
  outputLTE: String
  outputContains: String
  outputHasPrefix: String
  outputHasSuffix: String
  outputIsNil: Boolean
  outputNotNil: Boolean
  outputEqualFold: String
  outputContainsFold: String
  """
  output_size field predicates
  """
  outputSize: Int
  outputSizeNEQ: Int
  outputSizeIn: [Int!]
  outputSizeNotIn: [Int!]
  outputSizeGT: Int
  outputSizeGTE: Int
  outputSizeLT: Int
  outputSizeLTE: Int
  """
  error field predicates
  """
  error: String
  errorNEQ: String
  errorIn: [String!]
  errorNotIn: [String!]
  errorGT: String
  errorGTE: String
  errorLT: String
  errorLTE: String
  errorContains: String
  errorHasPrefix: String
  errorHasSuffix: String
  errorIsNil: Boolean
  errorNotNil: Boolean
  errorEqualFold: String
  errorContainsFold: String
  """
  quest edge predicates
  """
  hasQuest: Boolean
  hasQuestWith: [QuestWhereInput!]
  """
  beacon edge predicates
  """
  hasBeacon: Boolean
  hasBeaconWith: [BeaconWhereInput!]
  """
  reported_files edge predicates
  """
  hasReportedFiles: Boolean
  hasReportedFilesWith: [HostFileWhereInput!]
  """
  reported_processes edge predicates
  """
  hasReportedProcesses: Boolean
  hasReportedProcessesWith: [HostProcessWhereInput!]
  """
  reported_credentials edge predicates
  """
  hasReportedCredentials: Boolean
  hasReportedCredentialsWith: [HostCredentialWhereInput!]
  """
  shells edge predicates
  """
  hasShells: Boolean
  hasShellsWith: [ShellWhereInput!]
  """
  screenshots edge predicates
  """
  hasScreenshots: Boolean
  hasScreenshotsWith: [ScreenshotWhereInput!]
}
type Tome implements Node {
  id: ID!
  """
  Timestamp of when this ent was created
  """
  createdAt: Time!
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time!
  """
  Name of the tome
  """
  name: String!
  """
  Information about the tome
  """
  description: String!
  """
  Name of the author who created the tome.
  """
  author: String!
  """
  Information about the tomes support model.
  """
  supportModel: TomeSupportModel!
  """
  MITRE ATT&CK tactic provided by the tome.
  """
  tactic: TomeTactic!
  """
  If true, this tome will automatically be queued for all new Beacon callbacks.
  """
  runOnNewBeaconCallback: Boolean!
  """
  If true, this tome will automatically be queued for the first new callback on a Host.
  """
  runOnFirstHostCallback: Boolean!
  """
  Cron-like schedule for this tome to be automatically queued.
  """
  runOnSchedule: String!
  """
  JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter.
  """
  paramDefs: String
  """
  Eldritch script that will be executed when the tome is run
  """
  eldritch: String!
  assets(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Assets returned from the connection.
    """
    orderBy: [AssetOrder!]

    """
    Filtering options for Assets returned from the connection.
    """
    where: AssetWhereInput
  ): AssetConnection!
  """
  User who uploaded the tome (may be null).
  """
  uploader: User
  """
  Repository from which this Tome was imported (may be null).
  """
  repository: Repository
  scheduledHosts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Hosts returned from the connection.
    """
    orderBy: [HostOrder!]

    """
    Filtering options for Hosts returned from the connection.
    """
    where: HostWhereInput
  ): HostConnection!
}
"""
A connection to a list of items.
"""
type TomeConnection {
  """
  A list of edges.
  """
  edges: [TomeEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type TomeEdge {
  """
  The item at the end of the edge.
  """
  node: Tome
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Tome connections
"""
input TomeOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Tomes.
  """
  field: TomeOrderField!
}
"""
Properties by which Tome connections can be ordered.
"""
enum TomeOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
TomeSupportModel is enum for the field support_model
"""
enum TomeSupportModel @goModel(model: "realm.pub/tavern/internal/ent/tome.SupportModel") {
  UNSPECIFIED
  FIRST_PARTY
  COMMUNITY
}
"""
TomeTactic is enum for the field tactic
"""
enum TomeTactic @goModel(model: "realm.pub/tavern/internal/ent/tome.Tactic") {
  UNSPECIFIED
  RECON
  RESOURCE_DEVELOPMENT
  INITIAL_ACCESS
  EXECUTION
  PERSISTENCE
  PRIVILEGE_ESCALATION
  DEFENSE_EVASION
  CREDENTIAL_ACCESS
  DISCOVERY
  LATERAL_MOVEMENT
  COLLECTION
  COMMAND_AND_CONTROL
  EXFILTRATION
  IMPACT
}
"""
TomeWhereInput is used for filtering Tome objects.
Input was generated by ent.
"""
input TomeWhereInput {
  not: TomeWhereInput
  and: [TomeWhereInput!]
  or: [TomeWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  last_modified_at field predicates
  """
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  description field predicates
  """
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionEqualFold: String
  descriptionContainsFold: String
  """
  author field predicates
  """
  author: String
  authorNEQ: String
  authorIn: [String!]
  authorNotIn: [String!]
  authorGT: String
  authorGTE: String
  authorLT: String
  authorLTE: String
  authorContains: String
  authorHasPrefix: String
  authorHasSuffix: String
  authorEqualFold: String
  authorContainsFold: String
  """
  support_model field predicates
  """
  supportModel: TomeSupportModel
  supportModelNEQ: TomeSupportModel
  supportModelIn: [TomeSupportModel!]
  supportModelNotIn: [TomeSupportModel!]
  """
  tactic field predicates
  """
  tactic: TomeTactic
  tacticNEQ: TomeTactic
  tacticIn: [TomeTactic!]
  tacticNotIn: [TomeTactic!]
  """
  run_on_new_beacon_callback field predicates
  """
  runOnNewBeaconCallback: Boolean
  runOnNewBeaconCallbackNEQ: Boolean
  """
  run_on_first_host_callback field predicates
  """
  runOnFirstHostCallback: Boolean
  runOnFirstHostCallbackNEQ: Boolean
  """
  run_on_schedule field predicates
  """
  runOnSchedule: String
  runOnScheduleNEQ: String
  runOnScheduleIn: [String!]
  runOnScheduleNotIn: [String!]
  runOnScheduleGT: String
  runOnScheduleGTE: String
  runOnScheduleLT: String
  runOnScheduleLTE: String
  runOnScheduleContains: String
  runOnScheduleHasPrefix: String
  runOnScheduleHasSuffix: String
  runOnScheduleEqualFold: String
  runOnScheduleContainsFold: String
  """
  param_defs field predicates
  """
  paramDefs: String
  paramDefsNEQ: String
  paramDefsIn: [String!]
  paramDefsNotIn: [String!]
  paramDefsGT: String
  paramDefsGTE: String
  paramDefsLT: String
  paramDefsLTE: String
  paramDefsContains: String
  paramDefsHasPrefix: String
  paramDefsHasSuffix: String
  paramDefsIsNil: Boolean
  paramDefsNotNil: Boolean
  paramDefsEqualFold: String
  paramDefsContainsFold: String
  """
  eldritch field predicates
  """
  eldritch: String
  eldritchNEQ: String
  eldritchIn: [String!]
  eldritchNotIn: [String!]
  eldritchGT: String
  eldritchGTE: String
  eldritchLT: String
  eldritchLTE: String
  eldritchContains: String
  eldritchHasPrefix: String
  eldritchHasSuffix: String
  eldritchEqualFold: String
  eldritchContainsFold: String
  """
  assets edge predicates
  """
  hasAssets: Boolean
  hasAssetsWith: [AssetWhereInput!]
  """
  uploader edge predicates
  """
  hasUploader: Boolean
  hasUploaderWith: [UserWhereInput!]
  """
  repository edge predicates
  """
  hasRepository: Boolean
  hasRepositoryWith: [RepositoryWhereInput!]
  """
  scheduled_hosts edge predicates
  """
  hasScheduledHosts: Boolean
  hasScheduledHostsWith: [HostWhereInput!]
}
"""
UpdateBeaconInput is used for update Beacon object.
Input was generated by ent.
"""
input UpdateBeaconInput {
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time
  hostID: ID
}
"""
UpdateHostInput is used for update Host object.
Input was generated by ent.
"""
input UpdateHostInput {
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time
  """
  A human readable identifier for the host.
  """
  name: String
  clearName: Boolean
  addTagIDs: [ID!]
  removeTagIDs: [ID!]
  clearTags: Boolean
  addBeaconIDs: [ID!]
  removeBeaconIDs: [ID!]
  clearBeacons: Boolean
  addFileIDs: [ID!]
  removeFileIDs: [ID!]
  clearFiles: Boolean
  addProcessIDs: [ID!]
  removeProcessIDs: [ID!]
  clearProcesses: Boolean
  addCredentialIDs: [ID!]
  removeCredentialIDs: [ID!]
  clearCredentials: Boolean
  addScreenshotIDs: [ID!]
  removeScreenshotIDs: [ID!]
  clearScreenshots: Boolean
}
"""
UpdateLinkInput is used for update Link object.
Input was generated by ent.
"""
input UpdateLinkInput {
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time
  """
  Unique path for accessing the asset via the CDN
  """
  path: String
  """
  Timestamp before which the link is active. Default is MySQL minimum datetime (1000-01-01)
  """
  expiresAt: Time
  """
  Maximum number of times this link can be clicked before it becomes inactive (if set)
  """
  downloadLimit: Int
  clearDownloadLimit: Boolean
  """
  Number of times the asset has been downloaded using this Link.
  """
  downloads: Int
  creatorID: ID
  clearCreator: Boolean
}
"""
UpdateTagInput is used for update Tag object.
Input was generated by ent.
"""
input UpdateTagInput {
  """
  Name of the tag
  """
  name: String
  """
  Describes the type of tag this is
  """
  kind: TagKind
  addHostIDs: [ID!]
  removeHostIDs: [ID!]
  clearHosts: Boolean
}
"""
UpdateTomeInput is used for update Tome object.
Input was generated by ent.
"""
input UpdateTomeInput {
  """
  Timestamp of when this ent was last updated
  """
  lastModifiedAt: Time
  """
  Name of the tome
  """
  name: String
  """
  Information about the tome
  """
  description: String
  """
  Name of the author who created the tome.
  """
  author: String
  """
  Information about the tomes support model.
  """
  supportModel: TomeSupportModel
  """
  MITRE ATT&CK tactic provided by the tome.
  """
  tactic: TomeTactic
  """
  If true, this tome will automatically be queued for all new Beacon callbacks.
  """
  runOnNewBeaconCallback: Boolean
  """
  If true, this tome will automatically be queued for the first new callback on a Host.
  """
  runOnFirstHostCallback: Boolean
  """
  Cron-like schedule for this tome to be automatically queued.
  """
  runOnSchedule: String
  """
  JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter.
  """
  paramDefs: String
  clearParamDefs: Boolean
  """
  Eldritch script that will be executed when the tome is run
  """
  eldritch: String
  addAssetIDs: [ID!]
  removeAssetIDs: [ID!]
  clearAssets: Boolean
  addScheduledHostIDs: [ID!]
  removeScheduledHostIDs: [ID!]
  clearScheduledHosts: Boolean
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  """
  The name displayed for the user
  """
  name: String
  """
  URL to the user's profile photo.
  """
  photoURL: String
  """
  True if the user is active and able to authenticate
  """
  isActivated: Boolean
  """
  True if the user is an Admin
  """
  isAdmin: Boolean
  addTomeIDs: [ID!]
  removeTomeIDs: [ID!]
  clearTomes: Boolean
  addActiveShellIDs: [ID!]
  removeActiveShellIDs: [ID!]
  clearActiveShells: Boolean
}
type User implements Node {
  id: ID!
  """
  The name displayed for the user
  """
  name: String!
  """
  URL to the user's profile photo.
  """
  photoURL: String!
  """
  True if the user is active and able to authenticate
  """
  isActivated: Boolean!
  """
  True if the user is an Admin
  """
  isAdmin: Boolean!
  tomes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Tomes returned from the connection.
    """
    orderBy: [TomeOrder!]

    """
    Filtering options for Tomes returned from the connection.
    """
    where: TomeWhereInput
  ): TomeConnection!
  activeShells(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Shells returned from the connection.
    """
    orderBy: [ShellOrder!]

    """
    Filtering options for Shells returned from the connection.
    """
    where: ShellWhereInput
  ): ShellConnection!
}
"""
A connection to a list of items.
"""
type UserConnection {
  """
  A list of edges.
  """
  edges: [UserEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type UserEdge {
  """
  The item at the end of the edge.
  """
  node: User
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for User connections
"""
input UserOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Users.
  """
  field: UserOrderField!
}
"""
Properties by which User connections can be ordered.
"""
enum UserOrderField {
  NAME
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  photo_url field predicates
  """
  photoURL: String
  photoURLNEQ: String
  photoURLIn: [String!]
  photoURLNotIn: [String!]
  photoURLGT: String
  photoURLGTE: String
  photoURLLT: String
  photoURLLTE: String
  photoURLContains: String
  photoURLHasPrefix: String
  photoURLHasSuffix: String
  photoURLEqualFold: String
  photoURLContainsFold: String
  """
  is_activated field predicates
  """
  isActivated: Boolean
  isActivatedNEQ: Boolean
  """
  is_admin field predicates
  """
  isAdmin: Boolean
  isAdminNEQ: Boolean
  """
  tomes edge predicates
  """
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
  """
  active_shells edge predicates
  """
  hasActiveShells: Boolean
  hasActiveShellsWith: [ShellWhereInput!]
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphql", Input: `scalar Time
scalar Uint64
`, BuiltIn: false},
	{Name: "../schema/query.graphql", Input: `extend type Query {
  assets(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Assets returned from the connection."""
    orderBy: [AssetOrder!]

    """Filtering options for Assets returned from the connection."""
    where: AssetWhereInput
  ): AssetConnection! @requireRole(role: USER)
  quests(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Quests returned from the connection."""
    orderBy: [QuestOrder!]

    """Filtering options for Quests returned from the connection."""
    where: QuestWhereInput
  ): QuestConnection! @requireRole(role: USER)
  tasks(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tasks returned from the connection."""
    orderBy: [TaskOrder!]

    """Filtering options for Tasks returned from the connection."""
    where: TaskWhereInput
  ): TaskConnection! @requireRole(role: USER)
  repositories(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Repositories returned from the connection."""
    orderBy: [RepositoryOrder!]

    """Filtering options for Repositories returned from the connection."""
    where: RepositoryWhereInput
  ): RepositoryConnection! @requireRole(role: USER)
  beacons(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Beacons returned from the connection."""
    orderBy: [BeaconOrder!]

    """Filtering options for Beacons returned from the connection."""
    where: BeaconWhereInput
  ): BeaconConnection! @requireRole(role: USER)
  hosts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Hosts returned from the connection."""
    orderBy: [HostOrder!]

    """Filtering options for Hosts returned from the connection."""
    where: HostWhereInput
  ): HostConnection! @requireRole(role: USER)
  tags(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Repositories returned from the connection."""
    orderBy: [TagOrder!]

    """Filtering options for Repositories returned from the connection."""
    where: TagWhereInput
  ): TagConnection! @requireRole(role: USER)
  tomes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tomes returned from the connection."""
    orderBy: [TomeOrder!]

    """Filtering options for Tomes returned from the connection."""
    where: TomeWhereInput
  ): TomeConnection! @requireRole(role: USER)
  users(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Users returned from the connection."""
    orderBy: [UserOrder!]

    """Filtering options for Users returned from the connection."""
    where: UserWhereInput
  ): UserConnection! @requireRole(role: USER)

  portals(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Portals returned from the connection."""
    orderBy: [PortalOrder!]

    """Filtering options for Portals returned from the connection."""
    where: PortalWhereInput): PortalConnection! @requireRole(role: USER)

  shells(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Shells returned from the connection."""
    orderBy: [ShellOrder!]

    """Filtering options for Shells returned from the connection."""
    where: ShellWhereInput): ShellConnection! @requireRole(role: USER)
  buildTasks(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for BuildTasks returned from the connection."""
    orderBy: [BuildTaskOrder!]

    """Filtering options for BuildTasks returned from the connection."""
    where: BuildTaskWhereInput
  ): BuildTaskConnection! @requireRole(role: USER)
  builders(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Builders returned from the connection."""
    orderBy: [BuilderOrder!]

    """Filtering options for Builders returned from the connection."""
    where: BuilderWhereInput
  ): BuilderConnection! @requireRole(role: ADMIN)
  me: User!
}
`, BuiltIn: false},
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
    ####
    # Admin
    ####
    dropAllData: Boolean! @requireRole(role: ADMIN)

    ###
    # Quest
    ###
    createQuest(beaconIDs: [ID!]!, input: CreateQuestInput!): Quest @requireRole(role: USER)

    ###
    # Beacon
    ###
    updateBeacon(beaconID: ID!, input: UpdateBeaconInput!): Beacon! @requireRole(role: USER)

    ###
    # Shell
    ###
    createShell(input: CreateShellInput!): Shell! @requireRole(role: USER)

    ###
    # Host
    ###
    updateHost(hostID: ID!, input: UpdateHostInput!): Host! @requireRole(role: USER)

    ###
    # Tag
    ###
    createTag(input: CreateTagInput!): Tag! @requireRole(role: ADMIN)
    updateTag(tagID: ID!, input: UpdateTagInput!): Tag! @requireRole(role: USER)

    ###
    # Tome
    ###
    createTome(input: CreateTomeInput!,): Tome! @requireRole(role: USER)
    updateTome(tomeID: ID!, input: UpdateTomeInput!,): Tome! @requireRole(role: ADMIN)
    deleteTome(tomeID: ID!): ID! @requireRole(role: ADMIN)

    ###
    # Repository
    ###
    createRepository(input: CreateRepositoryInput!): Repository! @requireRole(role: USER)
    importRepository(repoID: ID!, input: ImportRepositoryInput): Repository! @requireRole(role: USER)

    ###
    # User
    ###
    updateUser(userID: ID!, input: UpdateUserInput!): User @requireRole(role: ADMIN)

    ###
    # Credential
    ###
    createCredential(input: CreateHostCredentialInput!): HostCredential! @requireRole(role: USER)

    ###
    # Link
    ###
    createLink(input: CreateLinkInput!): Link! @requireRole(role: USER)
    updateLink(linkID: ID!, input: UpdateLinkInput!): Link! @requireRole(role: USER)
    disableLink(linkID: ID!): Link! @requireRole(role: USER)

    ###
    # Builder
    ###
    registerBuilder(input: CreateBuilderInput!): RegisterBuilderOutput! @requireRole(role: ADMIN)
    deleteBuilder(builderID: ID!): ID! @requireRole(role: ADMIN)

    ###
    # BuildTask
    ###
    createBuildTask(input: CreateBuildTaskInput!): BuildTask! @requireRole(role: ADMIN)
}
`, BuiltIn: false},
	{Name: "../schema/inputs.graphql", Input: `input ClaimTasksInput {
  """The identity the beacon is authenticated as (e.g. 'root')"""
  principal: String!

  """The hostname of the system the beacon is running on."""
  hostname: String!

  """The platform the agent is operating on."""
  hostPlatform: HostPlatform!

  """The IP address of the hosts primary interface (if available)."""
  hostPrimaryIP: String

  """Unique identifier of the beacon, each running instance will be different."""
  beaconIdentifier: String!

  """Unique identifier of the underlying host system the beacon is running on."""
  hostIdentifier: String!

  """Name of the agent program the beacon is running as (e.g. 'imix')"""
  agentIdentifier: String!
}

input SubmitTaskResultInput {
  """ID of the task to submit results for."""
  taskID: ID!

  """Timestamp of when the task execution began. Format as RFC3339Nano."""
  execStartedAt: Time!

  """Timestamp of when the task execution finished (set only if it has completed). Format as RFC3339Nano."""
  execFinishedAt: Time

  """
  Output captured as the result of task execution.
  Submitting multiple outputs will result in appending new output to the previous output.
  """
  output: String!

  """Error message captured as the result of task execution failure."""
  error: String
}
input ImportRepositoryInput {
  """
  Optionally, specify directories to include.
  Only tomes that have a main.eldritch in one of these directory prefixes will be included.
  """
  includeDirs: [String!]
}

"""A single transport configuration for a build task."""
type BuildTaskTransport @goModel(model: "realm.pub/tavern/internal/builder/builderpb.BuildTaskTransport") {
  """The URI for the IMIX agent."""
  uri: String!

  """The callback interval in seconds."""
  interval: Int!

  """The transport type."""
  type: BeaconTransport_Type!

  """Extra transport configuration."""
  extra: String
}

"""Input for a single transport configuration."""
input BuildTaskTransportInput {
  """The URI for the IMIX agent."""
  uri: String!

  """The callback interval in seconds."""
  interval: Int! = 5

  """The transport type."""
  type: BeaconTransport_Type!

  """Extra transport configuration."""
  extra: String
}

"""Input for creating a new build task."""
input CreateBuildTaskInput {
  """The target operating system for the build."""
  targetOS: HostPlatform!

  """The output format for the build. Defaults to BIN."""
  targetFormat: BuildTaskTargetFormat

  """Docker container image name to use for the build. Defaults to spellshift/devcontainer:main."""
  buildImage: String

  """List of transport configurations. Defaults to a single gRPC transport at http://127.0.0.1:8000."""
  transports: [BuildTaskTransportInput!]

  """Path inside the build container to extract the artifact from. Defaults to the derived path based on target OS."""
  artifactPath: String
}

"""Output returned when registering a new builder."""
type RegisterBuilderOutput {
  """The created builder entity."""
  builder: Builder!

  """mTLS certificate PEM bundle for the builder to authenticate."""
  mtlsCert: String!

  """YAML-formatted configuration for the builder."""
  config: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
