// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"realm.pub/tavern/internal/ent"
	"realm.pub/tavern/internal/graphql/models"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Process() ProcessResolver
	Query() QueryResolver
	ProcessWhereInput() ProcessWhereInputResolver
}

type DirectiveRoot struct {
	RequireRole func(ctx context.Context, obj interface{}, next graphql.Resolver, role models.Role) (res interface{}, err error)
}

type ComplexityRoot struct {
	Beacon struct {
		AgentIdentifier func(childComplexity int) int
		Host            func(childComplexity int) int
		ID              func(childComplexity int) int
		Identifier      func(childComplexity int) int
		Interval        func(childComplexity int) int
		LastSeenAt      func(childComplexity int) int
		Name            func(childComplexity int) int
		Principal       func(childComplexity int) int
		Tasks           func(childComplexity int) int
	}

	File struct {
		CreatedAt      func(childComplexity int) int
		Hash           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Size           func(childComplexity int) int
		Tomes          func(childComplexity int) int
	}

	Host struct {
		Beacons    func(childComplexity int) int
		ID         func(childComplexity int) int
		Identifier func(childComplexity int) int
		LastSeenAt func(childComplexity int) int
		Name       func(childComplexity int) int
		Platform   func(childComplexity int) int
		PrimaryIP  func(childComplexity int) int
		Processes  func(childComplexity int) int
		Tags       func(childComplexity int) int
	}

	Mutation struct {
		ClaimTasks       func(childComplexity int, input models.ClaimTasksInput) int
		CreateQuest      func(childComplexity int, beaconIDs []int, input ent.CreateQuestInput) int
		CreateTag        func(childComplexity int, input ent.CreateTagInput) int
		CreateTome       func(childComplexity int, input ent.CreateTomeInput) int
		SubmitTaskResult func(childComplexity int, input models.SubmitTaskResultInput) int
		UpdateBeacon     func(childComplexity int, beaconID int, input ent.UpdateBeaconInput) int
		UpdateHost       func(childComplexity int, hostID int, input ent.UpdateHostInput) int
		UpdateTag        func(childComplexity int, tagID int, input ent.UpdateTagInput) int
		UpdateUser       func(childComplexity int, userID int, input ent.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Process struct {
		CreatedAt      func(childComplexity int) int
		Host           func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Pid            func(childComplexity int) int
		Principal      func(childComplexity int) int
		Task           func(childComplexity int) int
	}

	Query struct {
		Beacons func(childComplexity int, where *ent.BeaconWhereInput) int
		Files   func(childComplexity int, where *ent.FileWhereInput) int
		Hosts   func(childComplexity int, where *ent.HostWhereInput) int
		Me      func(childComplexity int) int
		Node    func(childComplexity int, id int) int
		Nodes   func(childComplexity int, ids []int) int
		Quests  func(childComplexity int, where *ent.QuestWhereInput) int
		Tags    func(childComplexity int, where *ent.TagWhereInput) int
		Tasks   func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Tomes   func(childComplexity int, where *ent.TomeWhereInput) int
		Users   func(childComplexity int, where *ent.UserWhereInput) int
	}

	Quest struct {
		Bundle         func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Creator        func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		Parameters     func(childComplexity int) int
		Tasks          func(childComplexity int) int
		Tome           func(childComplexity int) int
	}

	Tag struct {
		Hosts func(childComplexity int) int
		ID    func(childComplexity int) int
		Kind  func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	Task struct {
		Beacon            func(childComplexity int) int
		ClaimedAt         func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		Error             func(childComplexity int) int
		ExecFinishedAt    func(childComplexity int) int
		ExecStartedAt     func(childComplexity int) int
		ID                func(childComplexity int) int
		LastModifiedAt    func(childComplexity int) int
		Output            func(childComplexity int) int
		OutputSize        func(childComplexity int) int
		Quest             func(childComplexity int) int
		ReportedProcesses func(childComplexity int) int
	}

	TaskConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TaskEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Tome struct {
		CreatedAt      func(childComplexity int) int
		Description    func(childComplexity int) int
		Eldritch       func(childComplexity int) int
		Files          func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
		ParamDefs      func(childComplexity int) int
	}

	User struct {
		ID          func(childComplexity int) int
		IsActivated func(childComplexity int) int
		IsAdmin     func(childComplexity int) int
		Name        func(childComplexity int) int
		PhotoURL    func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Beacon.agentIdentifier":
		if e.complexity.Beacon.AgentIdentifier == nil {
			break
		}

		return e.complexity.Beacon.AgentIdentifier(childComplexity), true

	case "Beacon.host":
		if e.complexity.Beacon.Host == nil {
			break
		}

		return e.complexity.Beacon.Host(childComplexity), true

	case "Beacon.id":
		if e.complexity.Beacon.ID == nil {
			break
		}

		return e.complexity.Beacon.ID(childComplexity), true

	case "Beacon.identifier":
		if e.complexity.Beacon.Identifier == nil {
			break
		}

		return e.complexity.Beacon.Identifier(childComplexity), true

	case "Beacon.interval":
		if e.complexity.Beacon.Interval == nil {
			break
		}

		return e.complexity.Beacon.Interval(childComplexity), true

	case "Beacon.lastSeenAt":
		if e.complexity.Beacon.LastSeenAt == nil {
			break
		}

		return e.complexity.Beacon.LastSeenAt(childComplexity), true

	case "Beacon.name":
		if e.complexity.Beacon.Name == nil {
			break
		}

		return e.complexity.Beacon.Name(childComplexity), true

	case "Beacon.principal":
		if e.complexity.Beacon.Principal == nil {
			break
		}

		return e.complexity.Beacon.Principal(childComplexity), true

	case "Beacon.tasks":
		if e.complexity.Beacon.Tasks == nil {
			break
		}

		return e.complexity.Beacon.Tasks(childComplexity), true

	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.hash":
		if e.complexity.File.Hash == nil {
			break
		}

		return e.complexity.File.Hash(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.lastModifiedAt":
		if e.complexity.File.LastModifiedAt == nil {
			break
		}

		return e.complexity.File.LastModifiedAt(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "File.tomes":
		if e.complexity.File.Tomes == nil {
			break
		}

		return e.complexity.File.Tomes(childComplexity), true

	case "Host.beacons":
		if e.complexity.Host.Beacons == nil {
			break
		}

		return e.complexity.Host.Beacons(childComplexity), true

	case "Host.id":
		if e.complexity.Host.ID == nil {
			break
		}

		return e.complexity.Host.ID(childComplexity), true

	case "Host.identifier":
		if e.complexity.Host.Identifier == nil {
			break
		}

		return e.complexity.Host.Identifier(childComplexity), true

	case "Host.lastSeenAt":
		if e.complexity.Host.LastSeenAt == nil {
			break
		}

		return e.complexity.Host.LastSeenAt(childComplexity), true

	case "Host.name":
		if e.complexity.Host.Name == nil {
			break
		}

		return e.complexity.Host.Name(childComplexity), true

	case "Host.platform":
		if e.complexity.Host.Platform == nil {
			break
		}

		return e.complexity.Host.Platform(childComplexity), true

	case "Host.primaryIP":
		if e.complexity.Host.PrimaryIP == nil {
			break
		}

		return e.complexity.Host.PrimaryIP(childComplexity), true

	case "Host.processes":
		if e.complexity.Host.Processes == nil {
			break
		}

		return e.complexity.Host.Processes(childComplexity), true

	case "Host.tags":
		if e.complexity.Host.Tags == nil {
			break
		}

		return e.complexity.Host.Tags(childComplexity), true

	case "Mutation.claimTasks":
		if e.complexity.Mutation.ClaimTasks == nil {
			break
		}

		args, err := ec.field_Mutation_claimTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ClaimTasks(childComplexity, args["input"].(models.ClaimTasksInput)), true

	case "Mutation.createQuest":
		if e.complexity.Mutation.CreateQuest == nil {
			break
		}

		args, err := ec.field_Mutation_createQuest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateQuest(childComplexity, args["beaconIDs"].([]int), args["input"].(ent.CreateQuestInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(ent.CreateTagInput)), true

	case "Mutation.createTome":
		if e.complexity.Mutation.CreateTome == nil {
			break
		}

		args, err := ec.field_Mutation_createTome_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTome(childComplexity, args["input"].(ent.CreateTomeInput)), true

	case "Mutation.submitTaskResult":
		if e.complexity.Mutation.SubmitTaskResult == nil {
			break
		}

		args, err := ec.field_Mutation_submitTaskResult_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SubmitTaskResult(childComplexity, args["input"].(models.SubmitTaskResultInput)), true

	case "Mutation.updateBeacon":
		if e.complexity.Mutation.UpdateBeacon == nil {
			break
		}

		args, err := ec.field_Mutation_updateBeacon_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBeacon(childComplexity, args["beaconID"].(int), args["input"].(ent.UpdateBeaconInput)), true

	case "Mutation.updateHost":
		if e.complexity.Mutation.UpdateHost == nil {
			break
		}

		args, err := ec.field_Mutation_updateHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHost(childComplexity, args["hostID"].(int), args["input"].(ent.UpdateHostInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["tagID"].(int), args["input"].(ent.UpdateTagInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["userID"].(int), args["input"].(ent.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Process.createdAt":
		if e.complexity.Process.CreatedAt == nil {
			break
		}

		return e.complexity.Process.CreatedAt(childComplexity), true

	case "Process.host":
		if e.complexity.Process.Host == nil {
			break
		}

		return e.complexity.Process.Host(childComplexity), true

	case "Process.id":
		if e.complexity.Process.ID == nil {
			break
		}

		return e.complexity.Process.ID(childComplexity), true

	case "Process.lastModifiedAt":
		if e.complexity.Process.LastModifiedAt == nil {
			break
		}

		return e.complexity.Process.LastModifiedAt(childComplexity), true

	case "Process.name":
		if e.complexity.Process.Name == nil {
			break
		}

		return e.complexity.Process.Name(childComplexity), true

	case "Process.pid":
		if e.complexity.Process.Pid == nil {
			break
		}

		return e.complexity.Process.Pid(childComplexity), true

	case "Process.principal":
		if e.complexity.Process.Principal == nil {
			break
		}

		return e.complexity.Process.Principal(childComplexity), true

	case "Process.task":
		if e.complexity.Process.Task == nil {
			break
		}

		return e.complexity.Process.Task(childComplexity), true

	case "Query.beacons":
		if e.complexity.Query.Beacons == nil {
			break
		}

		args, err := ec.field_Query_beacons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Beacons(childComplexity, args["where"].(*ent.BeaconWhereInput)), true

	case "Query.files":
		if e.complexity.Query.Files == nil {
			break
		}

		args, err := ec.field_Query_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Files(childComplexity, args["where"].(*ent.FileWhereInput)), true

	case "Query.hosts":
		if e.complexity.Query.Hosts == nil {
			break
		}

		args, err := ec.field_Query_hosts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hosts(childComplexity, args["where"].(*ent.HostWhereInput)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.quests":
		if e.complexity.Query.Quests == nil {
			break
		}

		args, err := ec.field_Query_quests_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Quests(childComplexity, args["where"].(*ent.QuestWhereInput)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		args, err := ec.field_Query_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tags(childComplexity, args["where"].(*ent.TagWhereInput)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		args, err := ec.field_Query_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tasks(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Query.tomes":
		if e.complexity.Query.Tomes == nil {
			break
		}

		args, err := ec.field_Query_tomes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tomes(childComplexity, args["where"].(*ent.TomeWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["where"].(*ent.UserWhereInput)), true

	case "Quest.bundle":
		if e.complexity.Quest.Bundle == nil {
			break
		}

		return e.complexity.Quest.Bundle(childComplexity), true

	case "Quest.createdAt":
		if e.complexity.Quest.CreatedAt == nil {
			break
		}

		return e.complexity.Quest.CreatedAt(childComplexity), true

	case "Quest.creator":
		if e.complexity.Quest.Creator == nil {
			break
		}

		return e.complexity.Quest.Creator(childComplexity), true

	case "Quest.id":
		if e.complexity.Quest.ID == nil {
			break
		}

		return e.complexity.Quest.ID(childComplexity), true

	case "Quest.lastModifiedAt":
		if e.complexity.Quest.LastModifiedAt == nil {
			break
		}

		return e.complexity.Quest.LastModifiedAt(childComplexity), true

	case "Quest.name":
		if e.complexity.Quest.Name == nil {
			break
		}

		return e.complexity.Quest.Name(childComplexity), true

	case "Quest.parameters":
		if e.complexity.Quest.Parameters == nil {
			break
		}

		return e.complexity.Quest.Parameters(childComplexity), true

	case "Quest.tasks":
		if e.complexity.Quest.Tasks == nil {
			break
		}

		return e.complexity.Quest.Tasks(childComplexity), true

	case "Quest.tome":
		if e.complexity.Quest.Tome == nil {
			break
		}

		return e.complexity.Quest.Tome(childComplexity), true

	case "Tag.hosts":
		if e.complexity.Tag.Hosts == nil {
			break
		}

		return e.complexity.Tag.Hosts(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.kind":
		if e.complexity.Tag.Kind == nil {
			break
		}

		return e.complexity.Tag.Kind(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Task.beacon":
		if e.complexity.Task.Beacon == nil {
			break
		}

		return e.complexity.Task.Beacon(childComplexity), true

	case "Task.claimedAt":
		if e.complexity.Task.ClaimedAt == nil {
			break
		}

		return e.complexity.Task.ClaimedAt(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.error":
		if e.complexity.Task.Error == nil {
			break
		}

		return e.complexity.Task.Error(childComplexity), true

	case "Task.execFinishedAt":
		if e.complexity.Task.ExecFinishedAt == nil {
			break
		}

		return e.complexity.Task.ExecFinishedAt(childComplexity), true

	case "Task.execStartedAt":
		if e.complexity.Task.ExecStartedAt == nil {
			break
		}

		return e.complexity.Task.ExecStartedAt(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.lastModifiedAt":
		if e.complexity.Task.LastModifiedAt == nil {
			break
		}

		return e.complexity.Task.LastModifiedAt(childComplexity), true

	case "Task.output":
		if e.complexity.Task.Output == nil {
			break
		}

		return e.complexity.Task.Output(childComplexity), true

	case "Task.outputSize":
		if e.complexity.Task.OutputSize == nil {
			break
		}

		return e.complexity.Task.OutputSize(childComplexity), true

	case "Task.quest":
		if e.complexity.Task.Quest == nil {
			break
		}

		return e.complexity.Task.Quest(childComplexity), true

	case "Task.reportedProcesses":
		if e.complexity.Task.ReportedProcesses == nil {
			break
		}

		return e.complexity.Task.ReportedProcesses(childComplexity), true

	case "TaskConnection.edges":
		if e.complexity.TaskConnection.Edges == nil {
			break
		}

		return e.complexity.TaskConnection.Edges(childComplexity), true

	case "TaskConnection.pageInfo":
		if e.complexity.TaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.TaskConnection.PageInfo(childComplexity), true

	case "TaskConnection.totalCount":
		if e.complexity.TaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.TaskConnection.TotalCount(childComplexity), true

	case "TaskEdge.cursor":
		if e.complexity.TaskEdge.Cursor == nil {
			break
		}

		return e.complexity.TaskEdge.Cursor(childComplexity), true

	case "TaskEdge.node":
		if e.complexity.TaskEdge.Node == nil {
			break
		}

		return e.complexity.TaskEdge.Node(childComplexity), true

	case "Tome.createdAt":
		if e.complexity.Tome.CreatedAt == nil {
			break
		}

		return e.complexity.Tome.CreatedAt(childComplexity), true

	case "Tome.description":
		if e.complexity.Tome.Description == nil {
			break
		}

		return e.complexity.Tome.Description(childComplexity), true

	case "Tome.eldritch":
		if e.complexity.Tome.Eldritch == nil {
			break
		}

		return e.complexity.Tome.Eldritch(childComplexity), true

	case "Tome.files":
		if e.complexity.Tome.Files == nil {
			break
		}

		return e.complexity.Tome.Files(childComplexity), true

	case "Tome.id":
		if e.complexity.Tome.ID == nil {
			break
		}

		return e.complexity.Tome.ID(childComplexity), true

	case "Tome.lastModifiedAt":
		if e.complexity.Tome.LastModifiedAt == nil {
			break
		}

		return e.complexity.Tome.LastModifiedAt(childComplexity), true

	case "Tome.name":
		if e.complexity.Tome.Name == nil {
			break
		}

		return e.complexity.Tome.Name(childComplexity), true

	case "Tome.paramDefs":
		if e.complexity.Tome.ParamDefs == nil {
			break
		}

		return e.complexity.Tome.ParamDefs(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isActivated":
		if e.complexity.User.IsActivated == nil {
			break
		}

		return e.complexity.User.IsActivated(childComplexity), true

	case "User.isAdmin":
		if e.complexity.User.IsAdmin == nil {
			break
		}

		return e.complexity.User.IsAdmin(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.photoURL":
		if e.complexity.User.PhotoURL == nil {
			break
		}

		return e.complexity.User.PhotoURL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBeaconOrder,
		ec.unmarshalInputBeaconWhereInput,
		ec.unmarshalInputClaimTasksInput,
		ec.unmarshalInputCreateQuestInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputCreateTomeInput,
		ec.unmarshalInputFileOrder,
		ec.unmarshalInputFileWhereInput,
		ec.unmarshalInputHostOrder,
		ec.unmarshalInputHostWhereInput,
		ec.unmarshalInputProcessOrder,
		ec.unmarshalInputProcessWhereInput,
		ec.unmarshalInputQuestOrder,
		ec.unmarshalInputQuestWhereInput,
		ec.unmarshalInputSubmitTaskResultInput,
		ec.unmarshalInputTagOrder,
		ec.unmarshalInputTagWhereInput,
		ec.unmarshalInputTaskOrder,
		ec.unmarshalInputTaskWhereInput,
		ec.unmarshalInputTomeOrder,
		ec.unmarshalInputTomeWhereInput,
		ec.unmarshalInputUpdateBeaconInput,
		ec.unmarshalInputUpdateHostInput,
		ec.unmarshalInputUpdateTagInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/directives.graphql", Input: `directive @requireRole(role: Role!) on FIELD_DEFINITION

enum Role {
    ADMIN
    USER
}`, BuiltIn: false},
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Beacon implements Node {
  id: ID!
  """A human readable identifier for the beacon."""
  name: String!
  """The identity the beacon is authenticated as (e.g. 'root')"""
  principal: String
  """Unique identifier for the beacon. Unique to each instance of the beacon."""
  identifier: String!
  """Identifies the agent that the beacon is running as (e.g. 'imix')."""
  agentIdentifier: String
  """Timestamp of when a task was last claimed or updated for the beacon."""
  lastSeenAt: Time
  """Duration until next callback, in seconds."""
  interval: Uint64
  """Host this beacon is running on."""
  host: Host!
  """Tasks that have been assigned to the beacon."""
  tasks: [Task!]
}
"""Ordering options for Beacon connections"""
input BeaconOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Beacons."""
  field: BeaconOrderField!
}
"""Properties by which Beacon connections can be ordered."""
enum BeaconOrderField {
  LAST_SEEN_AT
  INTERVAL
}
"""
BeaconWhereInput is used for filtering Beacon objects.
Input was generated by ent.
"""
input BeaconWhereInput {
  not: BeaconWhereInput
  and: [BeaconWhereInput!]
  or: [BeaconWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """principal field predicates"""
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalIsNil: Boolean
  principalNotNil: Boolean
  principalEqualFold: String
  principalContainsFold: String
  """identifier field predicates"""
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """agent_identifier field predicates"""
  agentIdentifier: String
  agentIdentifierNEQ: String
  agentIdentifierIn: [String!]
  agentIdentifierNotIn: [String!]
  agentIdentifierGT: String
  agentIdentifierGTE: String
  agentIdentifierLT: String
  agentIdentifierLTE: String
  agentIdentifierContains: String
  agentIdentifierHasPrefix: String
  agentIdentifierHasSuffix: String
  agentIdentifierIsNil: Boolean
  agentIdentifierNotNil: Boolean
  agentIdentifierEqualFold: String
  agentIdentifierContainsFold: String
  """last_seen_at field predicates"""
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """interval field predicates"""
  interval: Uint64
  intervalNEQ: Uint64
  intervalIn: [Uint64!]
  intervalNotIn: [Uint64!]
  intervalGT: Uint64
  intervalGTE: Uint64
  intervalLT: Uint64
  intervalLTE: Uint64
  intervalIsNil: Boolean
  intervalNotNil: Boolean
  """host edge predicates"""
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """tasks edge predicates"""
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
}
"""
CreateQuestInput is used for create Quest object.
Input was generated by ent.
"""
input CreateQuestInput {
  """Name of the quest"""
  name: String!
  """Value of parameters that were specified for the quest (as a JSON string)."""
  parameters: String
  tomeID: ID!
}
"""
CreateTagInput is used for create Tag object.
Input was generated by ent.
"""
input CreateTagInput {
  """Name of the tag"""
  name: String!
  """Describes the type of tag this is"""
  kind: TagKind!
  hostIDs: [ID!]
}
"""
CreateTomeInput is used for create Tome object.
Input was generated by ent.
"""
input CreateTomeInput {
  """Name of the tome"""
  name: String!
  """Information about the tome"""
  description: String!
  """JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter."""
  paramDefs: String
  """Eldritch script that will be executed when the tome is run"""
  eldritch: String!
  fileIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type File implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """The name of the file, used to reference it for downloads"""
  name: String!
  """The size of the file in bytes"""
  size: Int!
  """A SHA3 digest of the content field"""
  hash: String!
  tomes: [Tome!]
}
"""Ordering options for File connections"""
input FileOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Files."""
  field: FileOrderField!
}
"""Properties by which File connections can be ordered."""
enum FileOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
  SIZE
}
"""
FileWhereInput is used for filtering File objects.
Input was generated by ent.
"""
input FileWhereInput {
  not: FileWhereInput
  and: [FileWhereInput!]
  or: [FileWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """size field predicates"""
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """hash field predicates"""
  hash: String
  hashNEQ: String
  hashIn: [String!]
  hashNotIn: [String!]
  hashGT: String
  hashGTE: String
  hashLT: String
  hashLTE: String
  hashContains: String
  hashHasPrefix: String
  hashHasSuffix: String
  hashEqualFold: String
  hashContainsFold: String
  """tomes edge predicates"""
  hasTomes: Boolean
  hasTomesWith: [TomeWhereInput!]
}
type Host implements Node {
  id: ID!
  """Unique identifier for the host. Unique to each host."""
  identifier: String!
  """A human readable identifier for the host."""
  name: String
  """Primary interface IP address reported by the agent."""
  primaryIP: String
  """Platform the agent is operating on."""
  platform: HostPlatform!
  """Timestamp of when a task was last claimed or updated for the host."""
  lastSeenAt: Time
  """Tags used to group this host with other hosts."""
  tags: [Tag!]
  """Beacons that are present on this host system."""
  beacons: [Beacon!]
  """Processes reported as running on this host system."""
  processes: [Process!]
}
"""Ordering options for Host connections"""
input HostOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Hosts."""
  field: HostOrderField!
}
"""Properties by which Host connections can be ordered."""
enum HostOrderField {
  LAST_SEEN_AT
}
"""HostPlatform is enum for the field platform"""
enum HostPlatform @goModel(model: "realm.pub/tavern/internal/ent/host.Platform") {
  Windows
  Linux
  MacOS
  BSD
  Unknown
}
"""
HostWhereInput is used for filtering Host objects.
Input was generated by ent.
"""
input HostWhereInput {
  not: HostWhereInput
  and: [HostWhereInput!]
  or: [HostWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """identifier field predicates"""
  identifier: String
  identifierNEQ: String
  identifierIn: [String!]
  identifierNotIn: [String!]
  identifierGT: String
  identifierGTE: String
  identifierLT: String
  identifierLTE: String
  identifierContains: String
  identifierHasPrefix: String
  identifierHasSuffix: String
  identifierEqualFold: String
  identifierContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """primary_ip field predicates"""
  primaryIP: String
  primaryIPNEQ: String
  primaryIPIn: [String!]
  primaryIPNotIn: [String!]
  primaryIPGT: String
  primaryIPGTE: String
  primaryIPLT: String
  primaryIPLTE: String
  primaryIPContains: String
  primaryIPHasPrefix: String
  primaryIPHasSuffix: String
  primaryIPIsNil: Boolean
  primaryIPNotNil: Boolean
  primaryIPEqualFold: String
  primaryIPContainsFold: String
  """platform field predicates"""
  platform: HostPlatform
  platformNEQ: HostPlatform
  platformIn: [HostPlatform!]
  platformNotIn: [HostPlatform!]
  """last_seen_at field predicates"""
  lastSeenAt: Time
  lastSeenAtNEQ: Time
  lastSeenAtIn: [Time!]
  lastSeenAtNotIn: [Time!]
  lastSeenAtGT: Time
  lastSeenAtGTE: Time
  lastSeenAtLT: Time
  lastSeenAtLTE: Time
  lastSeenAtIsNil: Boolean
  lastSeenAtNotNil: Boolean
  """tags edge predicates"""
  hasTags: Boolean
  hasTagsWith: [TagWhereInput!]
  """beacons edge predicates"""
  hasBeacons: Boolean
  hasBeaconsWith: [BeaconWhereInput!]
  """processes edge predicates"""
  hasProcesses: Boolean
  hasProcessesWith: [ProcessWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "realm.pub/tavern/internal/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Process implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """ID of the process."""
  pid: Int!
  """The name of the process."""
  name: String!
  """The user the process is running as."""
  principal: String!
  """Host the process was reported on."""
  host: Host!
  """Task that reported this process."""
  task: Task!
}
"""Ordering options for Process connections"""
input ProcessOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Processes."""
  field: ProcessOrderField!
}
"""Properties by which Process connections can be ordered."""
enum ProcessOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  PROCESS_ID
  NAME
}
"""
ProcessWhereInput is used for filtering Process objects.
Input was generated by ent.
"""
input ProcessWhereInput {
  not: ProcessWhereInput
  and: [ProcessWhereInput!]
  or: [ProcessWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """pid field predicates"""
  pid: Int
  pidNEQ: Int
  pidIn: [Int!]
  pidNotIn: [Int!]
  pidGT: Int
  pidGTE: Int
  pidLT: Int
  pidLTE: Int
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """principal field predicates"""
  principal: String
  principalNEQ: String
  principalIn: [String!]
  principalNotIn: [String!]
  principalGT: String
  principalGTE: String
  principalLT: String
  principalLTE: String
  principalContains: String
  principalHasPrefix: String
  principalHasSuffix: String
  principalEqualFold: String
  principalContainsFold: String
  """host edge predicates"""
  hasHost: Boolean
  hasHostWith: [HostWhereInput!]
  """task edge predicates"""
  hasTask: Boolean
  hasTaskWith: [TaskWhereInput!]
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
}
type Quest implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """Name of the quest"""
  name: String!
  """Value of parameters that were specified for the quest (as a JSON string)."""
  parameters: String
  """Tome that this quest will be executing"""
  tome: Tome!
  """Bundle file that the executing tome depends on (if any)"""
  bundle: File
  """Tasks tracking the status and output of individual tome execution on targets"""
  tasks: [Task!]
  """User that created the quest if available."""
  creator: User
}
"""Ordering options for Quest connections"""
input QuestOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Quests."""
  field: QuestOrderField!
}
"""Properties by which Quest connections can be ordered."""
enum QuestOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
QuestWhereInput is used for filtering Quest objects.
Input was generated by ent.
"""
input QuestWhereInput {
  not: QuestWhereInput
  and: [QuestWhereInput!]
  or: [QuestWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """parameters field predicates"""
  parameters: String
  parametersNEQ: String
  parametersIn: [String!]
  parametersNotIn: [String!]
  parametersGT: String
  parametersGTE: String
  parametersLT: String
  parametersLTE: String
  parametersContains: String
  parametersHasPrefix: String
  parametersHasSuffix: String
  parametersIsNil: Boolean
  parametersNotNil: Boolean
  parametersEqualFold: String
  parametersContainsFold: String
  """tome edge predicates"""
  hasTome: Boolean
  hasTomeWith: [TomeWhereInput!]
  """bundle edge predicates"""
  hasBundle: Boolean
  hasBundleWith: [FileWhereInput!]
  """tasks edge predicates"""
  hasTasks: Boolean
  hasTasksWith: [TaskWhereInput!]
  """creator edge predicates"""
  hasCreator: Boolean
  hasCreatorWith: [UserWhereInput!]
}
type Tag implements Node {
  id: ID!
  """Name of the tag"""
  name: String!
  """Describes the type of tag this is"""
  kind: TagKind!
  hosts: [Host!]
}
"""TagKind is enum for the field kind"""
enum TagKind @goModel(model: "realm.pub/tavern/internal/ent/tag.Kind") {
  group
  service
}
"""Ordering options for Tag connections"""
input TagOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tags."""
  field: TagOrderField!
}
"""Properties by which Tag connections can be ordered."""
enum TagOrderField {
  NAME
}
"""
TagWhereInput is used for filtering Tag objects.
Input was generated by ent.
"""
input TagWhereInput {
  not: TagWhereInput
  and: [TagWhereInput!]
  or: [TagWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """kind field predicates"""
  kind: TagKind
  kindNEQ: TagKind
  kindIn: [TagKind!]
  kindNotIn: [TagKind!]
  """hosts edge predicates"""
  hasHosts: Boolean
  hasHostsWith: [HostWhereInput!]
}
type Task implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """Timestamp of when the task was claimed, null if not yet claimed"""
  claimedAt: Time
  """Timestamp of when execution of the task started, null if not yet started"""
  execStartedAt: Time
  """Timestamp of when execution of the task finished, null if not yet finished"""
  execFinishedAt: Time
  """Output from executing the task"""
  output: String
  """The size of the output in bytes"""
  outputSize: Int!
  """Error, if any, produced while executing the Task"""
  error: String
  quest: Quest!
  beacon: Beacon!
  """Processes that have been reported by this task."""
  reportedProcesses: [Process!]
}
"""A connection to a list of items."""
type TaskConnection {
  """A list of edges."""
  edges: [TaskEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type TaskEdge {
  """The item at the end of the edge."""
  node: Task
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Task connections"""
input TaskOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tasks."""
  field: TaskOrderField!
}
"""Properties by which Task connections can be ordered."""
enum TaskOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  CLAIMED_AT
  EXEC_STARTED_AT
  EXEC_FINISHED_AT
  OUTPUT_SIZE
}
"""
TaskWhereInput is used for filtering Task objects.
Input was generated by ent.
"""
input TaskWhereInput {
  not: TaskWhereInput
  and: [TaskWhereInput!]
  or: [TaskWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """claimed_at field predicates"""
  claimedAt: Time
  claimedAtNEQ: Time
  claimedAtIn: [Time!]
  claimedAtNotIn: [Time!]
  claimedAtGT: Time
  claimedAtGTE: Time
  claimedAtLT: Time
  claimedAtLTE: Time
  claimedAtIsNil: Boolean
  claimedAtNotNil: Boolean
  """exec_started_at field predicates"""
  execStartedAt: Time
  execStartedAtNEQ: Time
  execStartedAtIn: [Time!]
  execStartedAtNotIn: [Time!]
  execStartedAtGT: Time
  execStartedAtGTE: Time
  execStartedAtLT: Time
  execStartedAtLTE: Time
  execStartedAtIsNil: Boolean
  execStartedAtNotNil: Boolean
  """exec_finished_at field predicates"""
  execFinishedAt: Time
  execFinishedAtNEQ: Time
  execFinishedAtIn: [Time!]
  execFinishedAtNotIn: [Time!]
  execFinishedAtGT: Time
  execFinishedAtGTE: Time
  execFinishedAtLT: Time
  execFinishedAtLTE: Time
  execFinishedAtIsNil: Boolean
  execFinishedAtNotNil: Boolean
  """output field predicates"""
  output: String
  outputNEQ: String
  outputIn: [String!]
  outputNotIn: [String!]
  outputGT: String
  outputGTE: String
  outputLT: String
  outputLTE: String
  outputContains: String
  outputHasPrefix: String
  outputHasSuffix: String
  outputIsNil: Boolean
  outputNotNil: Boolean
  outputEqualFold: String
  outputContainsFold: String
  """output_size field predicates"""
  outputSize: Int
  outputSizeNEQ: Int
  outputSizeIn: [Int!]
  outputSizeNotIn: [Int!]
  outputSizeGT: Int
  outputSizeGTE: Int
  outputSizeLT: Int
  outputSizeLTE: Int
  """error field predicates"""
  error: String
  errorNEQ: String
  errorIn: [String!]
  errorNotIn: [String!]
  errorGT: String
  errorGTE: String
  errorLT: String
  errorLTE: String
  errorContains: String
  errorHasPrefix: String
  errorHasSuffix: String
  errorIsNil: Boolean
  errorNotNil: Boolean
  errorEqualFold: String
  errorContainsFold: String
  """quest edge predicates"""
  hasQuest: Boolean
  hasQuestWith: [QuestWhereInput!]
  """beacon edge predicates"""
  hasBeacon: Boolean
  hasBeaconWith: [BeaconWhereInput!]
  """reported_processes edge predicates"""
  hasReportedProcesses: Boolean
  hasReportedProcessesWith: [ProcessWhereInput!]
}
type Tome implements Node {
  id: ID!
  """Timestamp of when this ent was created"""
  createdAt: Time!
  """Timestamp of when this ent was last updated"""
  lastModifiedAt: Time!
  """Name of the tome"""
  name: String!
  """Information about the tome"""
  description: String!
  """JSON string describing what parameters are used with the tome. Requires a list of JSON objects, one for each parameter."""
  paramDefs: String
  """Eldritch script that will be executed when the tome is run"""
  eldritch: String!
  """Any files required for tome execution that will be bundled and provided to the agent for download"""
  files: [File!]
}
"""Ordering options for Tome connections"""
input TomeOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tomes."""
  field: TomeOrderField!
}
"""Properties by which Tome connections can be ordered."""
enum TomeOrderField {
  CREATED_AT
  LAST_MODIFIED_AT
  NAME
}
"""
TomeWhereInput is used for filtering Tome objects.
Input was generated by ent.
"""
input TomeWhereInput {
  not: TomeWhereInput
  and: [TomeWhereInput!]
  or: [TomeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """last_modified_at field predicates"""
  lastModifiedAt: Time
  lastModifiedAtNEQ: Time
  lastModifiedAtIn: [Time!]
  lastModifiedAtNotIn: [Time!]
  lastModifiedAtGT: Time
  lastModifiedAtGTE: Time
  lastModifiedAtLT: Time
  lastModifiedAtLTE: Time
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionEqualFold: String
  descriptionContainsFold: String
  """param_defs field predicates"""
  paramDefs: String
  paramDefsNEQ: String
  paramDefsIn: [String!]
  paramDefsNotIn: [String!]
  paramDefsGT: String
  paramDefsGTE: String
  paramDefsLT: String
  paramDefsLTE: String
  paramDefsContains: String
  paramDefsHasPrefix: String
  paramDefsHasSuffix: String
  paramDefsIsNil: Boolean
  paramDefsNotNil: Boolean
  paramDefsEqualFold: String
  paramDefsContainsFold: String
  """eldritch field predicates"""
  eldritch: String
  eldritchNEQ: String
  eldritchIn: [String!]
  eldritchNotIn: [String!]
  eldritchGT: String
  eldritchGTE: String
  eldritchLT: String
  eldritchLTE: String
  eldritchContains: String
  eldritchHasPrefix: String
  eldritchHasSuffix: String
  eldritchEqualFold: String
  eldritchContainsFold: String
  """files edge predicates"""
  hasFiles: Boolean
  hasFilesWith: [FileWhereInput!]
}
"""
UpdateBeaconInput is used for update Beacon object.
Input was generated by ent.
"""
input UpdateBeaconInput {
  hostID: ID
}
"""
UpdateHostInput is used for update Host object.
Input was generated by ent.
"""
input UpdateHostInput {
  """A human readable identifier for the host."""
  name: String
  clearName: Boolean
  addTagIDs: [ID!]
  removeTagIDs: [ID!]
  clearTags: Boolean
  addBeaconIDs: [ID!]
  removeBeaconIDs: [ID!]
  clearBeacons: Boolean
  addProcessIDs: [ID!]
  removeProcessIDs: [ID!]
  clearProcesses: Boolean
}
"""
UpdateTagInput is used for update Tag object.
Input was generated by ent.
"""
input UpdateTagInput {
  """Name of the tag"""
  name: String
  """Describes the type of tag this is"""
  kind: TagKind
  addHostIDs: [ID!]
  removeHostIDs: [ID!]
  clearHosts: Boolean
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  """The name displayed for the user"""
  name: String
  """URL to the user's profile photo."""
  photoURL: String
  """True if the user is active and able to authenticate"""
  isActivated: Boolean
  """True if the user is an Admin"""
  isAdmin: Boolean
}
type User implements Node {
  id: ID!
  """The name displayed for the user"""
  name: String!
  """URL to the user's profile photo."""
  photoURL: String!
  """True if the user is active and able to authenticate"""
  isActivated: Boolean!
  """True if the user is an Admin"""
  isAdmin: Boolean!
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """photo_url field predicates"""
  photoURL: String
  photoURLNEQ: String
  photoURLIn: [String!]
  photoURLNotIn: [String!]
  photoURLGT: String
  photoURLGTE: String
  photoURLLT: String
  photoURLLTE: String
  photoURLContains: String
  photoURLHasPrefix: String
  photoURLHasSuffix: String
  photoURLEqualFold: String
  photoURLContainsFold: String
  """is_activated field predicates"""
  isActivated: Boolean
  isActivatedNEQ: Boolean
  """is_admin field predicates"""
  isAdmin: Boolean
  isAdminNEQ: Boolean
}
`, BuiltIn: false},
	{Name: "../schema/scalars.graphql", Input: `scalar Time
scalar Uint64
`, BuiltIn: false},
	{Name: "../schema/query.graphql", Input: `extend type Query {
  files(where: FileWhereInput): [File!]! @requireRole(role: USER)
  quests(where: QuestWhereInput): [Quest!]! @requireRole(role: USER)
  tasks(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tasks returned from the connection."""
    orderBy: [TaskOrder!]

    """Filtering options for Tasks returned from the connection."""
    where: TaskWhereInput
  ): TaskConnection! @requireRole(role: USER)
  beacons(where: BeaconWhereInput): [Beacon!]! @requireRole(role: USER)
  hosts(where: HostWhereInput): [Host!]! @requireRole(role: USER)
  tags(where: TagWhereInput): [Tag!]! @requireRole(role: USER)
  tomes(where: TomeWhereInput): [Tome!]! @requireRole(role: USER)
  users(where: UserWhereInput): [User!]! @requireRole(role: USER)
  me: User!
}
`, BuiltIn: false},
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
    ###
    # Quest
    ###
    createQuest(beaconIDs: [ID!]!, input: CreateQuestInput!): Quest @requireRole(role: USER)

    ###
    # Beacon
    ###
    updateBeacon(beaconID: ID!, input: UpdateBeaconInput!): Beacon! @requireRole(role: USER)

    ###
    # Host
    ###
    updateHost(hostID: ID!, input: UpdateHostInput!): Host! @requireRole(role: USER)

    ###
    # Tag
    ###
    createTag(input: CreateTagInput!): Tag! @requireRole(role: ADMIN)
    updateTag(tagID: ID!, input: UpdateTagInput!): Tag! @requireRole(role: USER)

    ###
    # Task
    ###
    claimTasks(input: ClaimTasksInput!,): [Task!]!
    submitTaskResult(input: SubmitTaskResultInput!,): Task

    ###
    # Tome
    ###
    createTome(input: CreateTomeInput!,): Tome! @requireRole(role: USER)

    ###
    # User
    ###
    updateUser(userID: ID!, input: UpdateUserInput!): User @requireRole(role: ADMIN)
}
`, BuiltIn: false},
	{Name: "../schema/inputs.graphql", Input: `input ClaimTasksInput {
  """The identity the beacon is authenticated as (e.g. 'root')"""
  principal: String!

  """The hostname of the system the beacon is running on."""
  hostname: String!

  """The platform the agent is operating on."""
  hostPlatform: HostPlatform!

  """The IP address of the hosts primary interface (if available)."""
  hostPrimaryIP: String

  """Unique identifier of the beacon, each running instance will be different."""
  beaconIdentifier: String!

  """Unique identifier of the underlying host system the beacon is running on."""
  hostIdentifier: String!

  """Name of the agent program the beacon is running as (e.g. 'imix')"""
  agentIdentifier: String!
}

input SubmitTaskResultInput {
  """ID of the task to submit results for."""
  taskID: ID!

  """Timestamp of when the task execution began. Format as RFC3339Nano."""
  execStartedAt: Time!

  """Timestamp of when the task execution finished (set only if it has completed). Format as RFC3339Nano."""
  execFinishedAt: Time

  """
  Output captured as the result of task execution.
  Submitting multiple outputs will result in appending new output to the previous output.
  """
  output: String!

  """Error message captured as the result of task execution failure."""
  error: String
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
