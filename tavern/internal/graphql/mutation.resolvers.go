package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"math/rand"
	"strings"
	"time"

	yaml "gopkg.in/yaml.v3"
	"realm.pub/tavern/internal/auth"
	"realm.pub/tavern/internal/builder"
	"realm.pub/tavern/internal/builder/builderpb"
	"realm.pub/tavern/internal/c2/c2pb"
	"realm.pub/tavern/internal/ent"
	"realm.pub/tavern/internal/ent/asset"
	entbuilder "realm.pub/tavern/internal/ent/builder"
	"realm.pub/tavern/internal/graphql/generated"
	"realm.pub/tavern/internal/graphql/models"
)

// DropAllData is the resolver for the dropAllData field.
func (r *mutationResolver) DropAllData(ctx context.Context) (bool, error) {
	// Initialize Transaction
	tx, err := r.client.Tx(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to initialize transaction: %w", err)
	}
	client := tx.Client()

	// Delete relevant ents
	// We must delete children before parents to avoid foreign key constraint violations
	if _, err := client.Shell.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete shells: %w", err))
	}
	if _, err := client.HostCredential.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete hostcredentials: %w", err))
	}
	if _, err := client.HostFile.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete hostfiles: %w", err))
	}
	if _, err := client.HostProcess.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete hostprocesses: %w", err))
	}
	if _, err := client.Task.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete tasks: %w", err))
	}
	if _, err := client.Beacon.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete beacons: %w", err))
	}
	if _, err := client.Quest.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete quests: %w", err))
	}
	if _, err := client.Host.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete hosts: %w", err))
	}
	if _, err := client.Tag.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete tags: %w", err))
	}
	if _, err := client.BuildTask.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete build tasks: %w", err))
	}
	if _, err := client.Builder.Delete().Exec(ctx); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to delete builders: %w", err))
	}

	// Commit
	if err := tx.Commit(); err != nil {
		return false, rollback(tx, fmt.Errorf("failed to commit transaction: %w", err))
	}

	return true, nil
}

// CreateQuest is the resolver for the createQuest field.
func (r *mutationResolver) CreateQuest(ctx context.Context, beaconIDs []int, input ent.CreateQuestInput) (*ent.Quest, error) {
	// Ensure at least one Beacon ID provided
	if len(beaconIDs) < 1 {
		return nil, fmt.Errorf("must provide at least one beacon id")
	}

	// 1. Begin Transaction
	tx, err := r.client.Tx(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize transaction: %w", err)
	}
	client := tx.Client()

	// 2. Rollback transaction if we panic
	defer func() {
		if v := recover(); v != nil {
			tx.Rollback()
			panic(v)
		}
	}()

	// 3. Load Tome
	questTome, err := client.Tome.Get(ctx, input.TomeID)
	if err != nil {
		return nil, rollback(tx, fmt.Errorf("failed to load tome: %w", err))
	}

	// 4. Load Tome Assets (ordered so that hashing is always the same)
	bundleAssets, err := questTome.QueryAssets().
		Order(ent.Asc(asset.FieldID)).
		All(ctx)
	if err != nil {
		return nil, rollback(tx, fmt.Errorf("failed to load tome assets: %w", err))
	}

	// 5. Create bundle (if tome has assets)
	var bundleID *int
	if len(bundleAssets) > 0 {
		bundle, err := createBundle(ctx, client, bundleAssets)
		if err != nil || bundle == nil {
			return nil, rollback(tx, fmt.Errorf("failed to create bundle: %w", err))
		}
		bundleID = &bundle.ID
	}

	// 6. Get creator from context (if available)
	var creatorID *int
	if creator := auth.UserFromContext(ctx); creator != nil {
		creatorID = &creator.ID
	}

	// 7. Create Quest
	quest, err := client.Quest.Create().
		SetInput(input).
		SetNillableBundleID(bundleID).
		SetEldritchAtCreation(questTome.Eldritch).
		SetParamDefsAtCreation(questTome.ParamDefs).
		SetTome(questTome).
		SetNillableCreatorID(creatorID).
		Save(ctx)
	if err != nil {
		return nil, rollback(tx, fmt.Errorf("failed to create quest: %w", err))
	}

	// 8. Create tasks for each beacon
	for _, sid := range beaconIDs {
		_, err := client.Task.Create().
			SetQuest(quest).
			SetBeaconID(sid).
			Save(ctx)
		if err != nil {
			return nil, rollback(tx, fmt.Errorf("failed to create task for beacon (%q): %w", sid, err))
		}
	}

	// 9. Commit the transaction
	if err := tx.Commit(); err != nil {
		return nil, rollback(tx, fmt.Errorf("failed to commit transaction: %w", err))
	}

	// 10. Load the quest with our non transactional client (cannot use transaction after commit)
	quest, err = r.client.Quest.Get(ctx, quest.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to load created quest: %w", err)
	}

	return quest, nil
}

// UpdateBeacon is the resolver for the updateBeacon field.
func (r *mutationResolver) UpdateBeacon(ctx context.Context, beaconID int, input ent.UpdateBeaconInput) (*ent.Beacon, error) {
	return r.client.Beacon.UpdateOneID(beaconID).SetInput(input).Save(ctx)
}

// UpdateHost is the resolver for the updateHost field.
func (r *mutationResolver) UpdateHost(ctx context.Context, hostID int, input ent.UpdateHostInput) (*ent.Host, error) {
	return r.client.Host.UpdateOneID(hostID).SetInput(input).Save(ctx)
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input ent.CreateTagInput) (*ent.Tag, error) {
	return r.client.Tag.Create().SetInput(input).Save(ctx)
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, tagID int, input ent.UpdateTagInput) (*ent.Tag, error) {
	return r.client.Tag.UpdateOneID(tagID).SetInput(input).Save(ctx)
}

// CreateTome is the resolver for the createTome field.
func (r *mutationResolver) CreateTome(ctx context.Context, input ent.CreateTomeInput) (*ent.Tome, error) {
	var uploaderID *int
	if uploader := auth.UserFromContext(ctx); uploader != nil {
		uploaderID = &uploader.ID
	}

	return r.client.Tome.Create().
		SetNillableUploaderID(uploaderID).
		SetInput(input).
		Save(ctx)
}

// UpdateTome is the resolver for the updateTome field.
func (r *mutationResolver) UpdateTome(ctx context.Context, tomeID int, input ent.UpdateTomeInput) (*ent.Tome, error) {
	return r.client.Tome.UpdateOneID(tomeID).SetInput(input).Save(ctx)
}

// DeleteTome is the resolver for the deleteTome field.
func (r *mutationResolver) DeleteTome(ctx context.Context, tomeID int) (int, error) {
	if err := r.client.Tome.DeleteOneID(tomeID).Exec(ctx); err != nil {
		return 0, err
	}
	return tomeID, nil
}

// CreateRepository is the resolver for the createRepository field.
func (r *mutationResolver) CreateRepository(ctx context.Context, input ent.CreateRepositoryInput) (*ent.Repository, error) {
	var ownerID *int
	if owner := auth.UserFromContext(ctx); owner != nil {
		ownerID = &owner.ID
	}

	return r.client.Repository.Create().
		SetInput(input).
		SetNillableOwnerID(ownerID).
		Save(ctx)
}

// ImportRepository is the resolver for the importRepository field.
func (r *mutationResolver) ImportRepository(ctx context.Context, repoID int, input *models.ImportRepositoryInput) (*ent.Repository, error) {
	// Load Repository
	repo, err := r.client.Repository.Get(ctx, repoID)
	if err != nil {
		return nil, err
	}

	// Configure Filters
	filter := func(string) bool { return true }
	if input != nil && input.IncludeDirs != nil {
		filter = func(path string) bool {
			for _, prefix := range input.IncludeDirs {
				// Ignore Leading /
				path = strings.TrimPrefix(path, "/")
				prefix = strings.TrimPrefix(prefix, "/")

				// Include if matching
				if strings.HasPrefix(path, prefix) {
					return true
				}
			}
			return false
		}
	}

	// Import Tomes
	if err := r.importer.Import(ctx, repo, filter); err != nil {
		return nil, err
	}

	return repo.Update().SetLastImportedAt(time.Now()).Save(ctx)
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID int, input ent.UpdateUserInput) (*ent.User, error) {
	return r.client.User.UpdateOneID(userID).SetInput(input).Save(ctx)
}

// CreateCredential is the resolver for the createCredential field.
func (r *mutationResolver) CreateCredential(ctx context.Context, input ent.CreateHostCredentialInput) (*ent.HostCredential, error) {
	return r.client.HostCredential.Create().SetInput(input).Save(ctx)
}

// CreateLink is the resolver for the createLink field.
func (r *mutationResolver) CreateLink(ctx context.Context, input ent.CreateLinkInput) (*ent.Link, error) {
	var creatorID *int
	if creator := auth.UserFromContext(ctx); creator != nil {
		creatorID = &creator.ID
	}
	return r.client.Link.Create().
		SetNillableCreatorID(creatorID).
		SetInput(input).
		Save(ctx)
}

// UpdateLink is the resolver for the updateLink field.
func (r *mutationResolver) UpdateLink(ctx context.Context, linkID int, input ent.UpdateLinkInput) (*ent.Link, error) {
	return r.client.Link.UpdateOneID(linkID).SetInput(input).Save(ctx)
}

// DisableLink is the resolver for the disableLink field.
func (r *mutationResolver) DisableLink(ctx context.Context, linkID int) (*ent.Link, error) {
	return r.client.Link.UpdateOneID(linkID).
		SetExpiresAt(time.Now().Add(-1 * time.Second)).
		Save(ctx)
}

// RegisterBuilder is the resolver for the registerBuilder field.
func (r *mutationResolver) RegisterBuilder(ctx context.Context, input ent.CreateBuilderInput) (*models.RegisterBuilderOutput, error) {
	// 1. Create builder ent (identifier is auto-generated)
	b, err := r.client.Builder.Create().SetInput(input).Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create builder: %w", err)
	}

	// 2. Generate CA-signed X.509 certificate for mTLS
	certPEM, keyPEM, err := builder.SignBuilderCertificate(r.builderCA, r.builderCAKey, b.Identifier)
	if err != nil {
		return nil, fmt.Errorf("failed to sign builder certificate: %w", err)
	}

	// Combine cert and key into a single PEM bundle
	combinedPEM := append(certPEM, keyPEM...)
	mtlsCert := string(combinedPEM)

	// 3. Build YAML config
	targetNames := make([]string, len(b.SupportedTargets))
	for i, t := range b.SupportedTargets {
		targetNames[i] = strings.ToLower(strings.TrimPrefix(t.String(), "PLATFORM_"))
	}

	configData := struct {
		ID               string   `yaml:"id"`
		SupportedTargets []string `yaml:"supported_targets"`
		MTLS             string   `yaml:"mtls"`
		Upstream         string   `yaml:"upstream"`
	}{
		ID:               b.Identifier,
		SupportedTargets: targetNames,
		MTLS:             mtlsCert,
		Upstream:         b.Upstream,
	}

	configBytes, err := yaml.Marshal(configData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal builder config: %w", err)
	}

	return &models.RegisterBuilderOutput{
		Builder:  b,
		MtlsCert: mtlsCert,
		Config:   string(configBytes),
	}, nil
}

// DeleteBuilder is the resolver for the deleteBuilder field.
func (r *mutationResolver) DeleteBuilder(ctx context.Context, builderID int) (int, error) {
	if err := r.client.Builder.DeleteOneID(builderID).Exec(ctx); err != nil {
		return 0, err
	}
	return builderID, nil
}

// CreateBuildTask is the resolver for the createBuildTask field.
func (r *mutationResolver) CreateBuildTask(ctx context.Context, input models.CreateBuildTaskInput) (*ent.BuildTask, error) {
	// 1. Resolve defaults for optional fields
	targetFormat := builder.DefaultTargetFormat
	if input.TargetFormat != nil {
		targetFormat = *input.TargetFormat
	}

	buildImage := builder.DefaultBuildImage
	if input.BuildImage != nil {
		buildImage = *input.BuildImage
	}

	// Resolve transports: use default if none provided
	transports := builder.DefaultTransports
	if len(input.Transports) > 0 {
		transports = make([]builderpb.BuildTaskTransport, len(input.Transports))
		for i, t := range input.Transports {
			var extra string
			if t.Extra != nil {
				extra = *t.Extra
			}
			transports[i] = builderpb.BuildTaskTransport{
				URI:      t.URI,
				Interval: t.Interval,
				Type:     c2pb.Transport_Type(t.Type),
				Extra:    extra,
			}
		}
	}

	artifactPath := builder.DeriveArtifactPath(input.TargetOs)
	if input.ArtifactPath != nil {
		artifactPath = *input.ArtifactPath
	}

	// 2. Validate target format for the given OS
	if err := builder.ValidateTargetFormat(input.TargetOs, targetFormat); err != nil {
		return nil, err
	}

	// 3. Derive the build script from configuration
	buildScript, err := builder.GenerateBuildScript(input.TargetOs, targetFormat)
	if err != nil {
		return nil, fmt.Errorf("failed to generate build script: %w", err)
	}

	// 4. Query healthy builders (checked in within the stale threshold).
	// Use the first transport's interval for the stale threshold.
	staleThreshold := time.Duration(transports[0].Interval) * time.Second
	staleCutoff := time.Now().Add(-staleThreshold)
	healthyBuilders, err := r.client.Builder.Query().
		Where(
			entbuilder.LastSeenAtNotNil(),
			entbuilder.LastSeenAtGTE(staleCutoff),
		).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query builders: %w", err)
	}

	// 5. Filter builders that support the target OS.
	// SupportedTargets is a JSON field so it must be filtered in application code.
	var candidates []*ent.Builder
	for _, b := range healthyBuilders {
		for _, target := range b.SupportedTargets {
			if target == input.TargetOs {
				candidates = append(candidates, b)
				break
			}
		}
	}

	if len(candidates) == 0 {
		return nil, fmt.Errorf("no builder available that supports target %s (or all matching builders are offline)", input.TargetOs.String())
	}

	// 6. Randomly select one builder
	selected := candidates[rand.Intn(len(candidates))]

	// 7. Create the build task
	create := r.client.BuildTask.Create().
		SetTargetOs(input.TargetOs).
		SetTargetFormat(targetFormat).
		SetBuildImage(buildImage).
		SetBuildScript(buildScript).
		SetTransports(transports).
		SetArtifactPath(artifactPath).
		SetBuilder(selected)

	bt, err := create.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create build task: %w", err)
	}

	return bt, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
